const {
  IExtensionService
} = require('./vscode/src/vs/workbench/services/extensions/common/extensions.service.js');
const {
  URI
} = require('./vscode/src/vs/base/common/uri.js');
const {
  getExtensionId
} = require('./vscode/src/vs/platform/extensionManagement/common/extensionManagementUtil.js');
const {
  DisposableStore
} = require('./vscode/src/vs/base/common/lifecycle.js');
const {
  joinPath
} = require('./vscode/src/vs/base/common/resources.js');
const {
  Schemas,
  FileAccess
} = require('./vscode/src/vs/base/common/network.js');
exports.ExtensionHostKind = {};
const {
  IWorkbenchEnvironmentService
} = require('./vscode/src/vs/workbench/services/environment/common/environmentService.service.js');
const {
  parse
} = require('./vscode/src/vs/base/common/json.js');
const {
  IFileService
} = require('./vscode/src/vs/platform/files/common/files.service.js');
const {
  IInstantiationService
} = require('./vscode/src/vs/platform/instantiation/common/instantiation.js');
const {
  IWorkbenchExtensionEnablementService
} = require('./vscode/src/vs/workbench/services/extensionManagement/common/extensionManagement.service.js');
const {
  StandaloneServices
} = require('./vscode/src/vs/editor/standalone/browser/standaloneServices.js');
const {
  ExtensionManifestTranslator
} = require('./vscode/src/vs/platform/extensionManagement/common/extensionsScannerService.js');
const {
  language
} = require('./vscode/src/vs/base/common/platform.js');
const {
  CustomSchemas,
  registerExtensionFile
} = require('@codingame/monaco-vscode-files-service-override');
const {
  waitServicesReady
} = require('./lifecycle.js');
const {
  throttle,
  memoized
} = require('./tools.js');
const {
  setDefaultApi
} = require('./api.js');
const {
  getBuiltInExtensionTranslationsUris
} = require('./l10n.js');
let apiFactory;
function registerLocalApiFactory(_apiFactory) {
  apiFactory = _apiFactory;
}
function registerExtensionFileUrl(extensionLocation, filePath, url, mimeType) {
  const fileDisposable = new DisposableStore();
  fileDisposable.add(FileAccess.registerStaticBrowserUri(joinPath(extensionLocation, filePath), URI.parse(url)));
  fileDisposable.add(registerExtensionFile(extensionLocation, filePath, memoized(async () => {
    const response = await fetch(url, {
      headers: mimeType != null ? {
        Accept: mimeType
      } : {}
    });
    if (response.status !== 200) {
      throw new Error(response.statusText);
    }
    return new Uint8Array(await response.arrayBuffer());
  })));
  return fileDisposable;
}
const deltaExtensions = throttle(async ({
  toAdd,
  toRemove
}) => {
  await waitServicesReady();
  const extensionService = StandaloneServices.get(IExtensionService);
  await extensionService.deltaExtensions(toAdd, toRemove);
}, (a, b) => ({
  toAdd: [...a.toAdd, ...b.toAdd],
  toRemove: [...a.toRemove, ...b.toRemove]
}), 0);
async function registerRemoteExtension(directory) {
  await waitServicesReady();
  const fileService = StandaloneServices.get(IFileService);
  const remoteAuthority = StandaloneServices.get(IWorkbenchEnvironmentService).remoteAuthority;
  const content = await fileService.readFile(joinPath(URI.from({
    scheme: Schemas.vscodeRemote,
    authority: remoteAuthority,
    path: directory
  }), 'package.json'));
  const manifest = parse(content.value.toString());
  return registerExtension(manifest, 3, {
    path: directory
  });
}
const forcedExtensionHostKinds = new Map();
const extensions = [];
function getExtensionManifests() {
  return extensions;
}
function getForcedExtensionHostKind(id) {
  return forcedExtensionHostKinds.get(id);
}
function registerExtension(manifest, extHostKind, {
  path = '/',
  system = false,
  readmePath,
  changelogPath
} = {}) {
  const id = getExtensionId(manifest.publisher, manifest.name);
  const location = URI.from({
    scheme: CustomSchemas.extensionFile,
    authority: id,
    path
  });
  const addExtensionPromise = (async () => {
    await waitServicesReady();
    const remoteAuthority = StandaloneServices.get(IWorkbenchEnvironmentService).remoteAuthority;
    let realLocation = location;
    if (extHostKind === 3) {
      realLocation = URI.from({
        scheme: Schemas.vscodeRemote,
        authority: remoteAuthority,
        path
      });
    }
    const instantiationService = StandaloneServices.get(IInstantiationService);
    const translator = instantiationService.createInstance(ExtensionManifestTranslator);
    const nlsConfiguration = {
      devMode: false,
      language: language,
      pseudo: language === 'pseudo',
      translations: getBuiltInExtensionTranslationsUris(language) ?? {}
    };
    const localizedManifest = await translator.translateManifest(realLocation, manifest, nlsConfiguration);
    const extension = {
      manifest: localizedManifest,
      type: system ? 0 : 1,
      isBuiltin: true,
      identifier: {
        id
      },
      location: realLocation,
      targetPlatform: "web",
      isValid: true,
      validations: [],
      extHostKind,
      readmeUrl: readmePath != null ? URI.joinPath(realLocation, readmePath) : undefined,
      changelogUrl: changelogPath != null ? URI.joinPath(realLocation, changelogPath) : undefined
    };
    if (extHostKind != null) {
      forcedExtensionHostKinds.set(id, extHostKind);
    }
    if (extHostKind !== 3) {
      extensions.push(extension);
    }
    const extensionEnablementService = StandaloneServices.get(IWorkbenchExtensionEnablementService);
    if (extensionEnablementService.isEnabled(extension)) {
      await deltaExtensions({
        toAdd: [extension],
        toRemove: []
      });
    }
    return extension;
  })();
  let api = {
    id,
    async whenReady() {
      await addExtensionPromise;
    },
    async isEnabled() {
      await waitServicesReady();
      const extensionEnablementService = StandaloneServices.get(IWorkbenchExtensionEnablementService);
      const extension = await addExtensionPromise;
      return extensionEnablementService.isEnabled(extension);
    },
    async dispose() {
      const extension = await addExtensionPromise;
      const index = extensions.indexOf(extension);
      if (index >= 0) {
        extensions.splice(extensions.indexOf(extension), 1);
      }
      forcedExtensionHostKinds.delete(id);
      await deltaExtensions({
        toAdd: [],
        toRemove: [extension]
      });
    }
  };
  if (extHostKind !== 3) {
    function registerFileUrl(path, url, mimeType) {
      return registerExtensionFileUrl(location, path, url, mimeType);
    }
    api = {
      ...api,
      registerFileUrl
    };
  }
  if (extHostKind === 1) {
    async function getApi() {
      await addExtensionPromise;
      if (apiFactory == null) {
        throw new Error('The local api can\'t be used without registering the local extension host by importing `vscode/localExtensionHost`');
      }
      return apiFactory(id);
    }
    api = {
      ...api,
      getApi,
      async setAsDefaultApi() {
        setDefaultApi(await getApi());
      }
    };
  }
  return api;
}
exports.getExtensionManifests = getExtensionManifests;
exports.getForcedExtensionHostKind = getForcedExtensionHostKind;
exports.registerExtension = registerExtension;
exports.registerLocalApiFactory = registerLocalApiFactory;
exports.registerRemoteExtension = registerRemoteExtension;