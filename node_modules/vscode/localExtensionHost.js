const {
  __decorate,
  __param
} = require('./external/tslib/tslib.es6.js');
const {} = require('./missing-services.js');
const {} = require('./vscode/src/vs/workbench/api/common/extHost.common.services.js');
const {
  ExtensionHostMain
} = require('./vscode/src/vs/workbench/api/common/extensionHostMain.js');
const {
  BufferedEmitter
} = require('./vscode/src/vs/base/parts/ipc/common/ipc.net.js');
const {
  isLoggingOnly
} = require('./vscode/src/vs/platform/telemetry/common/telemetryUtils.js');
const {
  joinPath
} = require('./vscode/src/vs/base/common/resources.js');
const {
  UIKind
} = require('./vscode/src/vs/workbench/services/extensions/common/extensionHostProtocol.js');
const {
  Language,
  isWeb,
  language
} = require('./vscode/src/vs/base/common/platform.js');
const {
  IExtHostExtensionService
} = require('./vscode/src/vs/workbench/api/common/extHostExtensionService.js');
const {
  nullExtensionDescription
} = require('./vscode/src/vs/workbench/services/extensions/common/extensions.js');
const {
  IExtensionService
} = require('./vscode/src/vs/workbench/services/extensions/common/extensions.service.js');
const {
  ITelemetryService
} = require('./vscode/src/vs/platform/telemetry/common/telemetry.service.js');
const {
  IWorkspaceContextService
} = require('./vscode/src/vs/platform/workspace/common/workspace.service.js');
const {
  ILabelService
} = require('./vscode/src/vs/platform/label/common/label.service.js');
const {
  ILogService,
  ILoggerService
} = require('./vscode/src/vs/platform/log/common/log.service.js');
const {
  IBrowserWorkbenchEnvironmentService
} = require('./vscode/src/vs/workbench/services/environment/browser/environmentService.service.js');
const {
  IProductService
} = require('./vscode/src/vs/platform/product/common/productService.service.js');
const {
  IUserDataProfilesService
} = require('./vscode/src/vs/platform/userDataProfile/common/userDataProfile.service.js');
const {
  URI
} = require('./vscode/src/vs/base/common/uri.js');
const {
  Event
} = require('./vscode/src/vs/base/common/event.js');
const {
  registerSingleton
} = require('./vscode/src/vs/platform/instantiation/common/extensions.js');
const {
  ExtensionStoragePaths,
  IExtensionStoragePaths
} = require('./vscode/src/vs/workbench/api/common/extHostStoragePaths.js');
const {
  ExtHostExtensionService
} = require('./vscode/src/vs/workbench/api/worker/extHostExtensionService.js');
const {
  ExtensionIdentifierMap
} = require('./vscode/src/vs/platform/extensions/common/extensions.js');
const {
  DeferredPromise
} = require('./vscode/src/vs/base/common/async.js');
const {
  setLocalExtensionHost
} = require('@codingame/monaco-vscode-extensions-service-override')
  const {
  unsupported
} = require('./tools.js');
const {
  registerLocalApiFactory
} = require('./extensions.js');
const {
  setDefaultApi
} = require('./api.js');
const {
  registerServiceInitializePostParticipant
} = require('./lifecycle.js');
const apiFactoryDeferred = new DeferredPromise();
class LocalExtHostExtensionService extends ExtHostExtensionService {
  constructor() {
    super(...arguments);
    this._extApiImpl = new ExtensionIdentifierMap();
  }
  async getApi(extensionId) {
    const [myRegistry, configProvider] = await Promise.all([this.getExtensionRegistry(), this._extHostConfiguration.getConfigProvider()]);
    const extensionRegistry = {
      mine: myRegistry,
      all: this._globalRegistry
    };
    if (extensionId == null) {
      if (this._defaultApiImpl == null) {
        this._defaultApiImpl = this._apiFactory(nullExtensionDescription, extensionRegistry, configProvider);
      }
      return this._defaultApiImpl;
    }
    const ext = myRegistry.getExtensionDescription(extensionId);
    if (ext == null) {
      throw new Error(`Extension ${extensionId} does not exist or is disabled`);
    }
    let apiImpl = this._extApiImpl.get(ext.identifier);
    if (apiImpl == null) {
      apiImpl = this._apiFactory(ext, extensionRegistry, configProvider);
      this._extApiImpl.set(ext.identifier, apiImpl);
    }
    return apiImpl;
  }
}
registerSingleton(IExtHostExtensionService, LocalExtHostExtensionService, 0);
registerSingleton(IExtensionStoragePaths, ExtensionStoragePaths, 0);
function createMessagePassingProtocolPair() {
  const emitterA = new BufferedEmitter();
  const emitterB = new BufferedEmitter();
  class SimpleMessagePassingProtocol {
    constructor(emitterIn, emitterOut) {
      this.emitterIn = emitterIn;
      this.emitterOut = emitterOut;
      this.onMessage = this.emitterIn.event;
    }
    send(buffer) {
      this.emitterOut.fire(buffer);
    }
  }
  return [new SimpleMessagePassingProtocol(emitterA, emitterB), new SimpleMessagePassingProtocol(emitterB, emitterA)];
}
const hostUtil = new class {
  constructor() {
    this.pid = undefined;
    this.exit = unsupported;
  }
  async exists(_path) {
    return true;
  }
  async realpath(path) {
    return path;
  }
}();
let LocalExtensionHost = class LocalExtensionHost {
  constructor(runningLocation, startup, _initDataProvider, _telemetryService, _contextService, _labelService, _logService, _loggerService, _environmentService, _productService, _userDataProfilesService) {
    this.runningLocation = runningLocation;
    this.startup = startup;
    this._initDataProvider = _initDataProvider;
    this._telemetryService = _telemetryService;
    this._contextService = _contextService;
    this._labelService = _labelService;
    this._logService = _logService;
    this._loggerService = _loggerService;
    this._environmentService = _environmentService;
    this._productService = _productService;
    this._userDataProfilesService = _userDataProfilesService;
    this.remoteAuthority = null;
    this.extensions = null;
    this.pid = null;
    this.onExit = Event.None;
    this._protocolPromise = null;
    this._extensionHostLogsLocation = joinPath(this._environmentService.extHostLogsPath, 'local');
  }
  async start() {
    if (this._protocolPromise == null) {
      this._protocolPromise = this._start();
    }
    return this._protocolPromise;
  }
  async _start() {
    const [mainThreadMessagePassingProtocol, extHostMessagePassingProtocol] = createMessagePassingProtocolPair();
    const initData = await this._createExtHostInitData();
    const hostMain = new ExtensionHostMain(extHostMessagePassingProtocol, initData, hostUtil, null);
    const localExtHostExtensionService = hostMain.getExtHostExtensionService();
    await apiFactoryDeferred.complete(extensionId => localExtHostExtensionService.getApi(extensionId));
    return mainThreadMessagePassingProtocol;
  }
  async _createExtHostInitData() {
    const initData = await this._initDataProvider.getInitData();
    this.extensions = initData.extensions;
    const workspace = this._contextService.getWorkspace();
    const nlsBaseUrl = this._productService.extensionsGallery?.nlsBaseUrl;
    let nlsUrlWithDetails;
    if (nlsBaseUrl != null && this._productService.commit != null && !Language.isDefaultVariant()) {
      nlsUrlWithDetails = URI.joinPath(URI.parse(nlsBaseUrl), this._productService.commit, this._productService.version, Language.value());
    }
    return {
      commit: this._productService.commit,
      version: this._productService.version,
      quality: this._productService.quality,
      parentPid: 0,
      environment: {
        isExtensionDevelopmentDebug: this._environmentService.debugRenderer,
        appName: this._productService.nameLong,
        appHost: this._productService.embedderIdentifier ?? (isWeb ? 'web' : 'desktop'),
        appUriScheme: this._productService.urlProtocol,
        appLanguage: language,
        extensionTelemetryLogResource: this._environmentService.extHostTelemetryLogFile,
        isExtensionTelemetryLoggingOnly: isLoggingOnly(this._productService, this._environmentService),
        extensionDevelopmentLocationURI: this._environmentService.extensionDevelopmentLocationURI,
        extensionTestsLocationURI: this._environmentService.extensionTestsLocationURI,
        globalStorageHome: this._userDataProfilesService.defaultProfile.globalStorageHome,
        workspaceStorageHome: this._environmentService.workspaceStorageHome,
        extensionLogLevel: this._environmentService.extensionLogLevel
      },
      workspace: this._contextService.getWorkbenchState() === 1 ? undefined : {
        configuration: workspace.configuration ?? undefined,
        id: workspace.id,
        name: this._labelService.getWorkspaceLabel(workspace),
        transient: workspace.transient
      },
      consoleForward: {
        includeStack: false,
        logNative: this._environmentService.debugRenderer
      },
      extensions: initData.extensions.toSnapshot(),
      nlsBaseUrl: nlsUrlWithDetails,
      telemetryInfo: {
        sessionId: this._telemetryService.sessionId,
        machineId: this._telemetryService.machineId,
        firstSessionDate: this._telemetryService.firstSessionDate,
        msftInternal: this._telemetryService.msftInternal,
        sqmId: this._telemetryService.sqmId
      },
      logLevel: this._logService.getLevel(),
      loggers: [...this._loggerService.getRegisteredLoggers()],
      logsLocation: this._extensionHostLogsLocation,
      autoStart: this.startup === 1,
      remote: {
        authority: this._environmentService.remoteAuthority,
        connectionData: null,
        isRemote: false
      },
      uiKind: isWeb ? UIKind.Web : UIKind.Desktop
    };
  }
  getInspectPort() {
    return undefined;
  }
  enableInspectPort() {
    return Promise.resolve(false);
  }
  dispose() {}
};
LocalExtensionHost = __decorate([__param(3, ITelemetryService), __param(4, IWorkspaceContextService), __param(5, ILabelService), __param(6, ILogService), __param(7, ILoggerService), __param(8, IBrowserWorkbenchEnvironmentService), __param(9, IProductService), __param(10, IUserDataProfilesService)], LocalExtensionHost);
async function createLocalApi(extensionId) {
  const apiFactory = await apiFactoryDeferred.p;
  return apiFactory(extensionId);
}
setLocalExtensionHost(LocalExtensionHost);
registerLocalApiFactory(createLocalApi);
  registerServiceInitializePostParticipant(async accessor => {
  console.log("attempting to create local api")
  accessor.get(IExtensionService);
  setDefaultApi(await createLocalApi());
});



