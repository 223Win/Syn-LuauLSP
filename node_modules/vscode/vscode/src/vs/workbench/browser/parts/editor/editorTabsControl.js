const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {} = require('./media/editortabscontrol.css.js');
const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  DataTransfers,
  applyDragImage
} = require('../../../../base/browser/dnd.js');
const {
  getActiveWindow,
  isMouseEvent,
  getWindow
} = require('../../../../base/browser/dom.js');
const {
  StandardMouseEvent
} = require('../../../../base/browser/mouseEvent.js');
const {
  prepareActions
} = require('../../../../base/browser/ui/actionbar/actionbar.js');
const {
  ActionRunner
} = require('../../../../base/common/actions.js');
const {
  DisposableStore
} = require('../../../../base/common/lifecycle.js');
const {
  createActionViewItem
} = require('../../../../platform/actions/browser/menuEntryActionViewItem.js');
const {
  MenuId
} = require('../../../../platform/actions/common/actions.js');
const {
  IContextKeyService
} = require('../../../../platform/contextkey/common/contextkey.service.js');
const {
  IContextMenuService
} = require('../../../../platform/contextview/browser/contextView.service.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {
  IKeybindingService
} = require('../../../../platform/keybinding/common/keybinding.service.js');
const {
  INotificationService
} = require('../../../../platform/notification/common/notification.service.js');
const {
  IQuickInputService
} = require('../../../../platform/quickinput/common/quickInput.service.js');
const {} = require('../../../../platform/theme/common/colorUtils.js');
const {} = require('../../../../platform/theme/common/colors/baseColors.js');
const {} = require('../../../../platform/theme/common/colors/chartsColors.js');
const {} = require('../../../../platform/theme/common/colors/editorColors.js');
const {} = require('../../../../platform/theme/common/colors/inputColors.js');
const {
  listActiveSelectionForeground,
  listActiveSelectionBackground
} = require('../../../../platform/theme/common/colors/listColors.js');
const {} = require('../../../../platform/theme/common/colors/menuColors.js');
const {} = require('../../../../platform/theme/common/colors/minimapColors.js');
const {} = require('../../../../platform/theme/common/colors/miscColors.js');
const {} = require('../../../../platform/theme/common/colors/quickpickColors.js');
const {} = require('../../../../platform/theme/common/colors/searchColors.js');
const {
  Themable
} = require('../../../../platform/theme/common/themeService.js');
const {
  IThemeService
} = require('../../../../platform/theme/common/themeService.service.js');
const {
  DraggedEditorGroupIdentifier,
  isWindowDraggedOver,
  fillEditorsDragData
} = require('../../dnd.js');
const {
  EditorPane
} = require('./editorPane.js');
const {
  EditorResourceAccessor,
  SideBySideEditor
} = require('../../../common/editor.js');
const {
  ResourceContextKey,
  ActiveEditorPinnedContext,
  ActiveEditorFirstInGroupContext,
  ActiveEditorLastInGroupContext,
  ActiveEditorStickyContext,
  ActiveEditorAvailableEditorIdsContext,
  ActiveEditorCanSplitInGroupContext,
  SideBySideEditorActiveContext,
  ActiveEditorGroupLockedContext,
  applyAvailableEditorIds
} = require('../../../common/contextkeys.js');
const {
  assertIsDefined
} = require('../../../../base/common/types.js');
const {
  isFirefox
} = require('../../../../base/browser/browser.js');
const {
  isCancellationError
} = require('../../../../base/common/errors.js');
const {
  SideBySideEditorInput
} = require('../../../common/editor/sideBySideEditorInput.js');
const {
  WorkbenchToolBar
} = require('../../../../platform/actions/browser/toolbar.js');
const {
  LocalSelectionTransfer
} = require('../../../../platform/dnd/browser/dnd.js');
const {
  IEditorResolverService
} = require('../../../services/editor/common/editorResolverService.service.js');
const {
  EDITOR_CORE_NAVIGATION_COMMANDS
} = require('./editorCommands.js');
const {
  isMacintosh
} = require('../../../../base/common/platform.js');
const {
  IHostService
} = require('../../../services/host/browser/host.service.js');
const {
  ServiceCollection
} = require('../../../../platform/instantiation/common/serviceCollection.js');
const {
  getDefaultHoverDelegate
} = require('../../../../base/browser/ui/hover/hoverDelegateFactory.js');
var EditorTabsControl_1;
const _moduleId = "vs/workbench/browser/parts/editor/editorTabsControl";
class EditorCommandsContextActionRunner extends ActionRunner {
  constructor(context) {
    super();
    this.context = context;
  }
  run(action, context) {
    let mergedContext = this.context;
    if (context?.preserveFocus) {
      mergedContext = {
        ...this.context,
        preserveFocus: true
      };
    }
    return super.run(action, mergedContext);
  }
}
let EditorTabsControl = class EditorTabsControl extends Themable {
  static {
    EditorTabsControl_1 = this;
  }
  static {
    this.EDITOR_TAB_HEIGHT = {
      normal: 35,
      compact: 22
    };
  }
  constructor(parent, editorPartsView, groupsView, groupView, tabsModel, contextMenuService, instantiationService, contextKeyService, keybindingService, notificationService, quickInputService, themeService, editorResolverService, hostService) {
    super(themeService);
    this.parent = parent;
    this.editorPartsView = editorPartsView;
    this.groupsView = groupsView;
    this.groupView = groupView;
    this.tabsModel = tabsModel;
    this.contextMenuService = contextMenuService;
    this.instantiationService = instantiationService;
    this.contextKeyService = contextKeyService;
    this.keybindingService = keybindingService;
    this.notificationService = notificationService;
    this.quickInputService = quickInputService;
    this.editorResolverService = editorResolverService;
    this.hostService = hostService;
    this.editorTransfer = LocalSelectionTransfer.getInstance();
    this.groupTransfer = LocalSelectionTransfer.getInstance();
    this.treeItemsTransfer = LocalSelectionTransfer.getInstance();
    this.editorActionsToolbarDisposables = this._register(new DisposableStore());
    this.editorActionsDisposables = this._register(new DisposableStore());
    this.contextMenuContextKeyService = this._register(this.contextKeyService.createScoped(parent));
    const scopedInstantiationService = this.instantiationService.createChild(new ServiceCollection([IContextKeyService, this.contextMenuContextKeyService]));
    this.resourceContext = this._register(scopedInstantiationService.createInstance(ResourceContextKey));
    this.editorPinnedContext = ActiveEditorPinnedContext.bindTo(this.contextMenuContextKeyService);
    this.editorIsFirstContext = ActiveEditorFirstInGroupContext.bindTo(this.contextMenuContextKeyService);
    this.editorIsLastContext = ActiveEditorLastInGroupContext.bindTo(this.contextMenuContextKeyService);
    this.editorStickyContext = ActiveEditorStickyContext.bindTo(this.contextMenuContextKeyService);
    this.editorAvailableEditorIds = ActiveEditorAvailableEditorIdsContext.bindTo(this.contextMenuContextKeyService);
    this.editorCanSplitInGroupContext = ActiveEditorCanSplitInGroupContext.bindTo(this.contextMenuContextKeyService);
    this.sideBySideEditorContext = SideBySideEditorActiveContext.bindTo(this.contextMenuContextKeyService);
    this.groupLockedContext = ActiveEditorGroupLockedContext.bindTo(this.contextMenuContextKeyService);
    this.renderDropdownAsChildElement = false;
    this.tabsHoverDelegate = getDefaultHoverDelegate('mouse');
    this.create(parent);
  }
  create(parent) {
    this.updateTabHeight();
  }
  get editorActionsEnabled() {
    return this.groupsView.partOptions.editorActionsLocation === 'default' && this.groupsView.partOptions.showTabs !== 'none';
  }
  createEditorActionsToolBar(parent, classes) {
    this.editorActionsToolbarContainer = document.createElement('div');
    this.editorActionsToolbarContainer.classList.add(...classes);
    parent.appendChild(this.editorActionsToolbarContainer);
    this.handleEditorActionToolBarVisibility(this.editorActionsToolbarContainer);
  }
  handleEditorActionToolBarVisibility(container) {
    const editorActionsEnabled = this.editorActionsEnabled;
    const editorActionsVisible = !!this.editorActionsToolbar;
    if (editorActionsEnabled && !editorActionsVisible) {
      this.doCreateEditorActionsToolBar(container);
    } else if (!editorActionsEnabled && editorActionsVisible) {
      this.editorActionsToolbar?.getElement().remove();
      this.editorActionsToolbar = undefined;
      this.editorActionsToolbarDisposables.clear();
      this.editorActionsDisposables.clear();
    }
    container.classList.toggle('hidden', !editorActionsEnabled);
  }
  doCreateEditorActionsToolBar(container) {
    const context = {
      groupId: this.groupView.id
    };
    this.editorActionsToolbar = this.editorActionsToolbarDisposables.add(this.instantiationService.createInstance(WorkbenchToolBar, container, {
      actionViewItemProvider: (action, options) => this.actionViewItemProvider(action, options),
      orientation: 0,
      ariaLabel: localizeWithPath(_moduleId, 0, "Editor actions"),
      getKeyBinding: action => this.getKeybinding(action),
      actionRunner: this.editorActionsToolbarDisposables.add(new EditorCommandsContextActionRunner(context)),
      anchorAlignmentProvider: () => 1,
      renderDropdownAsChildElement: this.renderDropdownAsChildElement,
      telemetrySource: 'editorPart',
      resetMenu: MenuId.EditorTitle,
      overflowBehavior: {
        maxItems: 9,
        exempted: EDITOR_CORE_NAVIGATION_COMMANDS
      },
      highlightToggledItems: true
    }));
    this.editorActionsToolbar.context = context;
    this.editorActionsToolbarDisposables.add(this.editorActionsToolbar.actionRunner.onDidRun(e => {
      if (e.error && !isCancellationError(e.error)) {
        this.notificationService.error(e.error);
      }
    }));
  }
  actionViewItemProvider(action, options) {
    const activeEditorPane = this.groupView.activeEditorPane;
    if (activeEditorPane instanceof EditorPane) {
      const result = activeEditorPane.getActionViewItem(action, options);
      if (result) {
        return result;
      }
    }
    return createActionViewItem(this.instantiationService, action, {
      ...options,
      menuAsChild: this.renderDropdownAsChildElement
    });
  }
  updateEditorActionsToolbar() {
    if (!this.editorActionsEnabled) {
      return;
    }
    this.editorActionsDisposables.clear();
    const editorActions = this.groupView.createEditorActions(this.editorActionsDisposables);
    this.editorActionsDisposables.add(editorActions.onDidChange(() => this.updateEditorActionsToolbar()));
    const editorActionsToolbar = assertIsDefined(this.editorActionsToolbar);
    const {
      primary,
      secondary
    } = this.prepareEditorActions(editorActions.actions);
    editorActionsToolbar.setActions(prepareActions(primary), prepareActions(secondary));
  }
  getEditorPaneAwareContextKeyService() {
    return this.groupView.activeEditorPane?.scopedContextKeyService ?? this.contextKeyService;
  }
  clearEditorActionsToolbar() {
    if (!this.editorActionsEnabled) {
      return;
    }
    const editorActionsToolbar = assertIsDefined(this.editorActionsToolbar);
    editorActionsToolbar.setActions([], []);
  }
  onGroupDragStart(e, element) {
    if (e.target !== element) {
      return false;
    }
    const isNewWindowOperation = this.isNewWindowOperation(e);
    this.groupTransfer.setData([new DraggedEditorGroupIdentifier(this.groupView.id)], DraggedEditorGroupIdentifier.prototype);
    if (e.dataTransfer) {
      e.dataTransfer.effectAllowed = 'copyMove';
    }
    let hasDataTransfer = false;
    if (this.groupsView.partOptions.showTabs === 'multiple') {
      hasDataTransfer = this.doFillResourceDataTransfers(this.groupView.getEditors(1), e, isNewWindowOperation);
    } else {
      if (this.groupView.activeEditor) {
        hasDataTransfer = this.doFillResourceDataTransfers([this.groupView.activeEditor], e, isNewWindowOperation);
      }
    }
    if (!hasDataTransfer && isFirefox) {
      e.dataTransfer?.setData(DataTransfers.TEXT, String(this.groupView.label));
    }
    if (this.groupView.activeEditor) {
      let label = this.groupView.activeEditor.getName();
      if (this.groupsView.partOptions.showTabs === 'multiple' && this.groupView.count > 1) {
        label = localizeWithPath(_moduleId, 1, "{0} (+{1})", label, this.groupView.count - 1);
      }
      applyDragImage(e, label, 'monaco-editor-group-drag-image', this.getColor(listActiveSelectionBackground), this.getColor(listActiveSelectionForeground));
    }
    return isNewWindowOperation;
  }
  async onGroupDragEnd(e, previousDragEvent, element, isNewWindowOperation) {
    this.groupTransfer.clearData(DraggedEditorGroupIdentifier.prototype);
    if (e.target !== element || !isNewWindowOperation || isWindowDraggedOver()) {
      return;
    }
    const auxiliaryEditorPart = await this.maybeCreateAuxiliaryEditorPartAt(e, element);
    if (!auxiliaryEditorPart) {
      return;
    }
    const targetGroup = auxiliaryEditorPart.activeGroup;
    this.groupsView.mergeGroup(this.groupView, targetGroup.id, {
      mode: this.isMoveOperation(previousDragEvent ?? e, targetGroup.id) ? 1 : 0
    });
    targetGroup.focus();
  }
  async maybeCreateAuxiliaryEditorPartAt(e, offsetElement) {
    const {
      point,
      display
    } = (await this.hostService.getCursorScreenPoint()) ?? {
      point: {
        x: e.screenX,
        y: e.screenY
      }
    };
    const window = getActiveWindow();
    if (window.document.visibilityState === 'visible' && window.document.hasFocus()) {
      if (point.x >= window.screenX && point.x <= window.screenX + window.outerWidth && point.y >= window.screenY && point.y <= window.screenY + window.outerHeight) {
        return;
      }
    }
    const offsetX = offsetElement.offsetWidth / 2;
    const offsetY = 30 + offsetElement.offsetHeight / 2;
    const bounds = {
      x: point.x - offsetX,
      y: point.y - offsetY
    };
    if (display) {
      if (bounds.x < display.x) {
        bounds.x = display.x;
      }
      if (bounds.y < display.y) {
        bounds.y = display.y;
      }
    }
    return this.editorPartsView.createAuxiliaryEditorPart({
      bounds
    });
  }
  isNewWindowOperation(e) {
    if (this.groupsView.partOptions.dragToOpenWindow) {
      return !e.altKey;
    }
    return e.altKey;
  }
  isMoveOperation(e, sourceGroup, sourceEditor) {
    if (sourceEditor?.hasCapability(8)) {
      return true;
    }
    const isCopy = e.ctrlKey && !isMacintosh || e.altKey && isMacintosh;
    return !isCopy || sourceGroup === this.groupView.id;
  }
  doFillResourceDataTransfers(editors, e, disableStandardTransfer) {
    if (editors.length) {
      this.instantiationService.invokeFunction(fillEditorsDragData, editors.map(editor => ({
        editor,
        groupId: this.groupView.id
      })), e, {
        disableStandardTransfer
      });
      return true;
    }
    return false;
  }
  onTabContextMenu(editor, e, node) {
    this.resourceContext.set(EditorResourceAccessor.getOriginalUri(editor, {
      supportSideBySide: SideBySideEditor.PRIMARY
    }));
    this.editorPinnedContext.set(this.tabsModel.isPinned(editor));
    this.editorIsFirstContext.set(this.tabsModel.isFirst(editor));
    this.editorIsLastContext.set(this.tabsModel.isLast(editor));
    this.editorStickyContext.set(this.tabsModel.isSticky(editor));
    this.groupLockedContext.set(this.tabsModel.isLocked);
    this.editorCanSplitInGroupContext.set(editor.hasCapability(32));
    this.sideBySideEditorContext.set(editor.typeId === SideBySideEditorInput.ID);
    applyAvailableEditorIds(this.editorAvailableEditorIds, editor, this.editorResolverService);
    let anchor = node;
    if (isMouseEvent(e)) {
      anchor = new StandardMouseEvent(getWindow(node), e);
    }
    this.contextMenuService.showContextMenu({
      getAnchor: () => anchor,
      menuId: MenuId.EditorTitleContext,
      menuActionOptions: {
        shouldForwardArgs: true,
        arg: this.resourceContext.get()
      },
      contextKeyService: this.contextMenuContextKeyService,
      getActionsContext: () => ({
        groupId: this.groupView.id,
        editorIndex: this.groupView.getIndexOfEditor(editor)
      }),
      getKeyBinding: action => this.keybindingService.lookupKeybinding(action.id, this.contextMenuContextKeyService),
      onHide: () => this.groupsView.activeGroup.focus()
    });
  }
  getKeybinding(action) {
    return this.keybindingService.lookupKeybinding(action.id, this.getEditorPaneAwareContextKeyService());
  }
  getKeybindingLabel(action) {
    const keybinding = this.getKeybinding(action);
    return keybinding ? keybinding.getLabel() ?? undefined : undefined;
  }
  get tabHeight() {
    return this.groupsView.partOptions.tabHeight !== 'compact' ? EditorTabsControl_1.EDITOR_TAB_HEIGHT.normal : EditorTabsControl_1.EDITOR_TAB_HEIGHT.compact;
  }
  getHoverTitle(editor) {
    return editor.getTitle(2);
  }
  getHoverDelegate() {
    return this.tabsHoverDelegate;
  }
  updateTabHeight() {
    this.parent.style.setProperty('--editor-group-tab-height', `${this.tabHeight}px`);
  }
  updateOptions(oldOptions, newOptions) {
    if (oldOptions.tabHeight !== newOptions.tabHeight) {
      this.updateTabHeight();
    }
    if (oldOptions.editorActionsLocation !== newOptions.editorActionsLocation || oldOptions.showTabs !== newOptions.showTabs) {
      if (this.editorActionsToolbarContainer) {
        this.handleEditorActionToolBarVisibility(this.editorActionsToolbarContainer);
        this.updateEditorActionsToolbar();
      }
    }
  }
};
EditorTabsControl = EditorTabsControl_1 = __decorate([__param(5, IContextMenuService), __param(6, IInstantiationService), __param(7, IContextKeyService), __param(8, IKeybindingService), __param(9, INotificationService), __param(10, IQuickInputService), __param(11, IThemeService), __param(12, IEditorResolverService), __param(13, IHostService)], EditorTabsControl);
exports.EditorCommandsContextActionRunner = EditorCommandsContextActionRunner;
exports.EditorTabsControl = EditorTabsControl;