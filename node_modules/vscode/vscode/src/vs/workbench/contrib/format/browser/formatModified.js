const {
  isNonEmptyArray
} = require('../../../../base/common/arrays.js');
const {
  CancellationToken
} = require('../../../../base/common/cancellation.js');
const {
  registerEditorAction,
  EditorAction
} = require('../../../../editor/browser/editorExtensions.js');
const {
  Range
} = require('../../../../editor/common/core/range.js');
const {
  EditorContextKeys
} = require('../../../../editor/common/editorContextKeys.js');
const {
  shouldSynchronizeModel
} = require('../../../../editor/common/model.js');
const {
  IEditorWorkerService
} = require('../../../../editor/common/services/editorWorker.js');
const {
  ITextModelService
} = require('../../../../editor/common/services/resolverService.js');
const {
  formatDocumentRangesWithSelectedProvider
} = require('../../../../editor/contrib/format/browser/format.js');
const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  ContextKeyExpr
} = require('../../../../platform/contextkey/common/contextkey.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {
  Progress
} = require('../../../../platform/progress/common/progress.js');
const {
  getOriginalResource
} = require('../../scm/browser/dirtydiffDecorator.js');
const {
  IQuickDiffService
} = require('../../scm/common/quickDiff.service.js');
const _moduleId = "vs/workbench/contrib/format/browser/formatModified";
registerEditorAction(class FormatModifiedAction extends EditorAction {
  constructor() {
    super({
      id: 'editor.action.formatChanges',
      label: localizeWithPath(_moduleId, 0, "Format Modified Lines"),
      alias: 'Format Modified Lines',
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasDocumentSelectionFormattingProvider)
    });
  }
  async run(accessor, editor) {
    const instaService = accessor.get(IInstantiationService);
    if (!editor.hasModel()) {
      return;
    }
    const ranges = await instaService.invokeFunction(getModifiedRanges, editor.getModel());
    if (isNonEmptyArray(ranges)) {
      return instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor, ranges, 1, Progress.None, CancellationToken.None, true);
    }
  }
});
async function getModifiedRanges(accessor, modified) {
  const quickDiffService = accessor.get(IQuickDiffService);
  const workerService = accessor.get(IEditorWorkerService);
  const modelService = accessor.get(ITextModelService);
  const original = await getOriginalResource(quickDiffService, modified.uri, modified.getLanguageId(), shouldSynchronizeModel(modified));
  if (!original) {
    return null;
  }
  const ranges = [];
  const ref = await modelService.createModelReference(original);
  try {
    if (!workerService.canComputeDirtyDiff(original, modified.uri)) {
      return undefined;
    }
    const changes = await workerService.computeDirtyDiff(original, modified.uri, false);
    if (!isNonEmptyArray(changes)) {
      return undefined;
    }
    for (const change of changes) {
      ranges.push(modified.validateRange(new Range(change.modifiedStartLineNumber, 1, change.modifiedEndLineNumber || change.modifiedStartLineNumber, Number.MAX_SAFE_INTEGER)));
    }
  } finally {
    ref.dispose();
  }
  return ranges;
}
exports.getModifiedRanges = getModifiedRanges;