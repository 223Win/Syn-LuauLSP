const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  URI
} = require('../../../../base/common/uri.js');
const {
  normalize,
  isAbsolute
} = require('../../../../base/common/path.js');
const {
  basenameOrAuthority
} = require('../../../../base/common/resources.js');
const {
  DEBUG_SCHEME
} = require('./debug.js');
const {
  SIDE_GROUP,
  ACTIVE_GROUP
} = require('../../../services/editor/common/editorService.js');
const {
  Schemas
} = require('../../../../base/common/network.js');
const {
  isUri
} = require('./debugUtils.js');
const _moduleId = "vs/workbench/contrib/debug/common/debugSource";
const UNKNOWN_SOURCE_LABEL = localizeWithPath(_moduleId, 0, "Unknown Source");
class Source {
  constructor(raw_, sessionId, uriIdentityService, logService) {
    let path;
    if (raw_) {
      this.raw = raw_;
      path = this.raw.path || this.raw.name || '';
      this.available = true;
    } else {
      this.raw = {
        name: UNKNOWN_SOURCE_LABEL
      };
      this.available = false;
      path = `${DEBUG_SCHEME}:${UNKNOWN_SOURCE_LABEL}`;
    }
    this.uri = getUriFromSource(this.raw, path, sessionId, uriIdentityService, logService);
  }
  get name() {
    return this.raw.name || basenameOrAuthority(this.uri);
  }
  get origin() {
    return this.raw.origin;
  }
  get presentationHint() {
    return this.raw.presentationHint;
  }
  get reference() {
    return this.raw.sourceReference;
  }
  get inMemory() {
    return this.uri.scheme === DEBUG_SCHEME;
  }
  openInEditor(editorService, selection, preserveFocus, sideBySide, pinned) {
    return !this.available ? Promise.resolve(undefined) : editorService.openEditor({
      resource: this.uri,
      description: this.origin,
      options: {
        preserveFocus,
        selection,
        revealIfOpened: true,
        selectionRevealType: 1,
        pinned
      }
    }, sideBySide ? SIDE_GROUP : ACTIVE_GROUP);
  }
  static getEncodedDebugData(modelUri) {
    let path;
    let sourceReference;
    let sessionId;
    switch (modelUri.scheme) {
      case Schemas.file:
        path = normalize(modelUri.fsPath);
        break;
      case DEBUG_SCHEME:
        path = modelUri.path;
        if (modelUri.query) {
          const keyvalues = modelUri.query.split('&');
          for (const keyvalue of keyvalues) {
            const pair = keyvalue.split('=');
            if (pair.length === 2) {
              switch (pair[0]) {
                case 'session':
                  sessionId = pair[1];
                  break;
                case 'ref':
                  sourceReference = parseInt(pair[1]);
                  break;
              }
            }
          }
        }
        break;
      default:
        path = modelUri.toString();
        break;
    }
    return {
      name: basenameOrAuthority(modelUri),
      path,
      sourceReference,
      sessionId
    };
  }
}
function getUriFromSource(raw, path, sessionId, uriIdentityService, logService) {
  const _getUriFromSource = path => {
    if (typeof raw.sourceReference === 'number' && raw.sourceReference > 0) {
      return URI.from({
        scheme: DEBUG_SCHEME,
        path: path?.replace(/^\/+/g, '/'),
        query: `session=${sessionId}&ref=${raw.sourceReference}`
      });
    }
    if (path && isUri(path)) {
      return uriIdentityService.asCanonicalUri(URI.parse(path));
    }
    if (path && isAbsolute(path)) {
      return uriIdentityService.asCanonicalUri(URI.file(path));
    }
    return uriIdentityService.asCanonicalUri(URI.from({
      scheme: DEBUG_SCHEME,
      path,
      query: `session=${sessionId}`
    }));
  };
  try {
    return _getUriFromSource(path);
  } catch (err) {
    logService.error('Invalid path from debug adapter: ' + path);
    return _getUriFromSource('/invalidDebugSource');
  }
}
exports.Source = Source;
exports.UNKNOWN_SOURCE_LABEL = UNKNOWN_SOURCE_LABEL;
exports.getUriFromSource = getUriFromSource;