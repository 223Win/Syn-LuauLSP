const {
  toAction
} = require('../../../../base/common/actions.js');
const {
  coalesce
} = require('../../../../base/common/arrays.js');
const {
  toErrorMessage
} = require('../../../../base/common/errorMessage.js');
const {
  isCancellationError
} = require('../../../../base/common/errors.js');
const {
  hash
} = require('../../../../base/common/hash.js');
const {
  KeyChord
} = require('../../../../base/common/keyCodes.js');
const {
  isEqual
} = require('../../../../base/common/resources.js');
const {
  ICodeEditorService
} = require('../../../../editor/browser/services/codeEditorService.js');
const {
  EmbeddedCodeEditorWidget
} = require('../../../../editor/browser/widget/codeEditor/embeddedCodeEditorWidget.js');
const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  CommandsRegistry
} = require('../../../../platform/commands/common/commands.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {
  KeybindingsRegistry
} = require('../../../../platform/keybinding/common/keybindingsRegistry.js');
const {
  IListService
} = require('../../../../platform/list/browser/listService.service.js');
const {} = require('../../../../platform/notification/common/notification.js');
const {
  INotificationService
} = require('../../../../platform/notification/common/notification.service.js');
const {
  getMultiSelectedEditorContexts
} = require('../../../browser/parts/editor/editorCommands.js');
const {
  EditorResourceAccessor,
  SideBySideEditor
} = require('../../../common/editor.js');
const {
  SideBySideEditorInput
} = require('../../../common/editor/sideBySideEditorInput.js');
const {
  getOpenEditorsViewMultiSelection
} = require('./files.js');
const {
  IEditorGroupsService
} = require('../../../services/editor/common/editorGroupsService.service.js');
const {
  IEditorService
} = require('../../../services/editor/common/editorService.service.js');
const {
  ITextFileService
} = require('../../../services/textfile/common/textfiles.service.js');
const {
  SAVE_FILE_COMMAND_ID,
  SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID,
  SAVE_FILE_AS_COMMAND_ID,
  SAVE_ALL_COMMAND_ID,
  SAVE_ALL_IN_GROUP_COMMAND_ID,
  SAVE_FILES_COMMAND_ID
} = require('./fileConstants.js');
const Severity$1 = require('../../../../base/common/severity.js');
const _moduleId = "vs/workbench/contrib/files/browser/fileCommands";
async function saveSelectedEditors(accessor, options) {
  const listService = accessor.get(IListService);
  const editorGroupService = accessor.get(IEditorGroupsService);
  const codeEditorService = accessor.get(ICodeEditorService);
  const textFileService = accessor.get(ITextFileService);
  let editors = getOpenEditorsViewMultiSelection(listService);
  if (!editors) {
    const activeGroup = editorGroupService.activeGroup;
    if (activeGroup.activeEditor) {
      editors = [];
      if (activeGroup.activeEditor instanceof SideBySideEditorInput && !options?.saveAs && !(activeGroup.activeEditor.primary.hasCapability(4) || activeGroup.activeEditor.secondary.hasCapability(4)) && activeGroup.activeEditor.secondary.isModified()) {
        editors.push({
          groupId: activeGroup.id,
          editor: activeGroup.activeEditor.primary
        });
        editors.push({
          groupId: activeGroup.id,
          editor: activeGroup.activeEditor.secondary
        });
      } else {
        editors.push({
          groupId: activeGroup.id,
          editor: activeGroup.activeEditor
        });
      }
    }
  }
  if (!editors || editors.length === 0) {
    return;
  }
  await doSaveEditors(accessor, editors, options);
  const focusedCodeEditor = codeEditorService.getFocusedCodeEditor();
  if (focusedCodeEditor instanceof EmbeddedCodeEditorWidget && !focusedCodeEditor.isSimpleWidget) {
    const resource = focusedCodeEditor.getModel()?.uri;
    if (resource && !editors.some(({
      editor
    }) => isEqual(EditorResourceAccessor.getCanonicalUri(editor, {
      supportSideBySide: SideBySideEditor.PRIMARY
    }), resource))) {
      const model = textFileService.files.get(resource);
      if (!model?.isReadonly()) {
        await textFileService.save(resource, options);
      }
    }
  }
}
function saveDirtyEditorsOfGroups(accessor, groups, options) {
  const dirtyEditors = [];
  for (const group of groups) {
    for (const editor of group.getEditors(0)) {
      if (editor.isDirty()) {
        dirtyEditors.push({
          groupId: group.id,
          editor
        });
      }
    }
  }
  return doSaveEditors(accessor, dirtyEditors, options);
}
async function doSaveEditors(accessor, editors, options) {
  const editorService = accessor.get(IEditorService);
  const notificationService = accessor.get(INotificationService);
  const instantiationService = accessor.get(IInstantiationService);
  try {
    await editorService.save(editors, options);
  } catch (error) {
    if (!isCancellationError(error)) {
      notificationService.notify({
        id: editors.map(({
          editor
        }) => hash(editor.resource?.toString())).join(),
        severity: Severity$1.Error,
        message: localizeWithPath(_moduleId, 3, "Failed to save '{0}': {1}", editors.map(({
          editor
        }) => editor.getName()).join(', '), toErrorMessage(error, false)),
        actions: {
          primary: [toAction({
            id: 'workbench.action.files.saveEditors',
            label: localizeWithPath(_moduleId, 4, "Retry"),
            run: () => instantiationService.invokeFunction(accessor => doSaveEditors(accessor, editors, options))
          }), toAction({
            id: 'workbench.action.files.revertEditors',
            label: localizeWithPath(_moduleId, 5, "Discard"),
            run: () => editorService.revert(editors)
          })]
        }
      });
    }
  }
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
  when: undefined,
  weight: 200,
  primary: 2048 | 49,
  id: SAVE_FILE_COMMAND_ID,
  handler: accessor => {
    return saveSelectedEditors(accessor, {
      reason: 1,
      force: true
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  when: undefined,
  weight: 200,
  primary: KeyChord(2048 | 41, 49),
  win: {
    primary: KeyChord(2048 | 41, 2048 | 1024 | 49)
  },
  id: SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID,
  handler: accessor => {
    return saveSelectedEditors(accessor, {
      reason: 1,
      force: true,
      skipSaveParticipants: true
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: SAVE_FILE_AS_COMMAND_ID,
  weight: 200,
  when: undefined,
  primary: 2048 | 1024 | 49,
  handler: accessor => {
    return saveSelectedEditors(accessor, {
      reason: 1,
      saveAs: true
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  when: undefined,
  weight: 200,
  primary: undefined,
  mac: {
    primary: 2048 | 512 | 49
  },
  win: {
    primary: KeyChord(2048 | 41, 49)
  },
  id: SAVE_ALL_COMMAND_ID,
  handler: accessor => {
    return saveDirtyEditorsOfGroups(accessor, accessor.get(IEditorGroupsService).getGroups(1), {
      reason: 1
    });
  }
});
CommandsRegistry.registerCommand({
  id: SAVE_ALL_IN_GROUP_COMMAND_ID,
  handler: (accessor, _, editorContext) => {
    const editorGroupService = accessor.get(IEditorGroupsService);
    const contexts = getMultiSelectedEditorContexts(editorContext, accessor.get(IListService), accessor.get(IEditorGroupsService));
    let groups = undefined;
    if (!contexts.length) {
      groups = editorGroupService.getGroups(1);
    } else {
      groups = coalesce(contexts.map(context => editorGroupService.getGroup(context.groupId)));
    }
    return saveDirtyEditorsOfGroups(accessor, groups, {
      reason: 1
    });
  }
});
CommandsRegistry.registerCommand({
  id: SAVE_FILES_COMMAND_ID,
  handler: async accessor => {
    const editorService = accessor.get(IEditorService);
    const res = await editorService.saveAll({
      includeUntitled: false,
      reason: 1
    });
    return res.success;
  }
});