const {
  __decorate,
  __param
} = require('../../../../../../../../external/tslib/tslib.es6.js');
const {
  Disposable
} = require('../../../../../base/common/lifecycle.js');
const {
  URI
} = require('../../../../../base/common/uri.js');
const {
  ITextEditorService
} = require('../../../../services/textfile/common/textEditorService.service.js');
const {
  isEqual
} = require('../../../../../base/common/resources.js');
const {
  NO_TYPE_ID
} = require('../../../../services/workingCopy/common/workingCopy.js');
const {
  IWorkingCopyEditorService
} = require('../../../../services/workingCopy/common/workingCopyEditorService.service.js');
const {
  IFileService
} = require('../../../../../platform/files/common/files.service.js');
class FileEditorInputSerializer {
  canSerialize(editorInput) {
    return true;
  }
  serialize(editorInput) {
    const fileEditorInput = editorInput;
    const resource = fileEditorInput.resource;
    const preferredResource = fileEditorInput.preferredResource;
    const serializedFileEditorInput = {
      resourceJSON: resource.toJSON(),
      preferredResourceJSON: isEqual(resource, preferredResource) ? undefined : preferredResource,
      name: fileEditorInput.getPreferredName(),
      description: fileEditorInput.getPreferredDescription(),
      encoding: fileEditorInput.getEncoding(),
      modeId: fileEditorInput.getPreferredLanguageId()
    };
    return JSON.stringify(serializedFileEditorInput);
  }
  deserialize(instantiationService, serializedEditorInput) {
    return instantiationService.invokeFunction(accessor => {
      const serializedFileEditorInput = JSON.parse(serializedEditorInput);
      const resource = URI.revive(serializedFileEditorInput.resourceJSON);
      const preferredResource = URI.revive(serializedFileEditorInput.preferredResourceJSON);
      const name = serializedFileEditorInput.name;
      const description = serializedFileEditorInput.description;
      const encoding = serializedFileEditorInput.encoding;
      const languageId = serializedFileEditorInput.modeId;
      const fileEditorInput = accessor.get(ITextEditorService).createTextEditor({
        resource,
        label: name,
        description,
        encoding,
        languageId,
        forceFile: true
      });
      if (preferredResource) {
        fileEditorInput.setPreferredResource(preferredResource);
      }
      return fileEditorInput;
    });
  }
}
let FileEditorWorkingCopyEditorHandler = class FileEditorWorkingCopyEditorHandler extends Disposable {
  static {
    this.ID = 'workbench.contrib.fileEditorWorkingCopyEditorHandler';
  }
  constructor(workingCopyEditorService, textEditorService, fileService) {
    super();
    this.textEditorService = textEditorService;
    this.fileService = fileService;
    this._register(workingCopyEditorService.registerHandler(this));
  }
  handles(workingCopy) {
    return workingCopy.typeId === NO_TYPE_ID && this.fileService.canHandleResource(workingCopy.resource);
  }
  handlesSync(workingCopy) {
    return workingCopy.typeId === NO_TYPE_ID && this.fileService.hasProvider(workingCopy.resource);
  }
  isOpen(workingCopy, editor) {
    if (!this.handlesSync(workingCopy)) {
      return false;
    }
    return isEqual(workingCopy.resource, editor.resource);
  }
  createEditor(workingCopy) {
    return this.textEditorService.createTextEditor({
      resource: workingCopy.resource,
      forceFile: true
    });
  }
};
FileEditorWorkingCopyEditorHandler = __decorate([__param(0, IWorkingCopyEditorService), __param(1, ITextEditorService), __param(2, IFileService)], FileEditorWorkingCopyEditorHandler);
exports.FileEditorInputSerializer = FileEditorInputSerializer;
exports.FileEditorWorkingCopyEditorHandler = FileEditorWorkingCopyEditorHandler;