const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  Disposable
} = require('../../../../base/common/lifecycle.js');
const {
  ResourceMap
} = require('../../../../base/common/map.js');
const {
  Schemas
} = require('../../../../base/common/network.js');
const {
  URI
} = require('../../../../base/common/uri.js');
const {
  Range
} = require('../../../../editor/common/core/range.js');
const {
  ILanguageService
} = require('../../../../editor/common/languages/language.js');
const {
  ITextModelService
} = require('../../../../editor/common/services/resolverService.js');
const {
  isResponseVM
} = require('./chatViewModel.js');
const {
  extractVulnerabilitiesFromText
} = require('./annotations.js');
let CodeBlockModelCollection = class CodeBlockModelCollection extends Disposable {
  constructor(languageService, textModelService) {
    super();
    this.languageService = languageService;
    this.textModelService = textModelService;
    this._models = new ResourceMap();
  }
  dispose() {
    super.dispose();
    this.clear();
  }
  get(sessionId, chat, codeBlockIndex) {
    const uri = this.getUri(sessionId, chat, codeBlockIndex);
    const entry = this._models.get(uri);
    if (!entry) {
      return;
    }
    return {
      model: entry.model.then(ref => ref.object),
      vulns: entry.vulns
    };
  }
  getOrCreate(sessionId, chat, codeBlockIndex) {
    const existing = this.get(sessionId, chat, codeBlockIndex);
    if (existing) {
      return existing;
    }
    const uri = this.getUri(sessionId, chat, codeBlockIndex);
    const ref = this.textModelService.createModelReference(uri);
    this._models.set(uri, {
      model: ref,
      vulns: []
    });
    return {
      model: ref.then(ref => ref.object),
      vulns: []
    };
  }
  clear() {
    this._models.forEach(async entry => (await entry.model).dispose());
    this._models.clear();
  }
  async update(sessionId, chat, codeBlockIndex, content) {
    const entry = this.getOrCreate(sessionId, chat, codeBlockIndex);
    const extractedVulns = extractVulnerabilitiesFromText(content.text);
    const newText = extractedVulns.newText;
    this.setVulns(sessionId, chat, codeBlockIndex, extractedVulns.vulnerabilities);
    const textModel = (await entry.model).textEditorModel;
    if (content.languageId) {
      const vscodeLanguageId = this.languageService.getLanguageIdByLanguageName(content.languageId);
      if (vscodeLanguageId && vscodeLanguageId !== textModel.getLanguageId()) {
        textModel.setLanguage(vscodeLanguageId);
      }
    }
    const currentText = textModel.getValue(1);
    if (newText === currentText) {
      return;
    }
    if (newText.startsWith(currentText)) {
      const text = newText.slice(currentText.length);
      const lastLine = textModel.getLineCount();
      const lastCol = textModel.getLineMaxColumn(lastLine);
      textModel.applyEdits([{
        range: new Range(lastLine, lastCol, lastLine, lastCol),
        text
      }]);
    } else {
      textModel.setValue(newText);
    }
  }
  setVulns(sessionId, chat, codeBlockIndex, vulnerabilities) {
    const uri = this.getUri(sessionId, chat, codeBlockIndex);
    const entry = this._models.get(uri);
    if (entry) {
      entry.vulns = vulnerabilities;
    }
  }
  getUri(sessionId, chat, index) {
    const metadata = this.getUriMetaData(chat);
    return URI.from({
      scheme: Schemas.vscodeChatCodeBlock,
      authority: sessionId,
      path: `/${chat.id}/${index}`,
      fragment: metadata ? JSON.stringify(metadata) : undefined
    });
  }
  getUriMetaData(chat) {
    if (!isResponseVM(chat)) {
      return undefined;
    }
    return {
      references: chat.contentReferences.map(ref => {
        const uriOrLocation = 'variableName' in ref.reference ? ref.reference.value : ref.reference;
        if (!uriOrLocation) {
          return;
        }
        if (URI.isUri(uriOrLocation)) {
          return {
            uri: uriOrLocation.toJSON()
          };
        }
        return {
          uri: uriOrLocation.uri.toJSON(),
          range: uriOrLocation.range
        };
      })
    };
  }
};
CodeBlockModelCollection = __decorate([__param(0, ILanguageService), __param(1, ITextModelService)], CodeBlockModelCollection);
exports.CodeBlockModelCollection = CodeBlockModelCollection;