const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {} = require('./codeBlockPart.css.js');
const {
  append,
  hide,
  show,
  clearNode,
  reset,
  $$1
} = require('../../../../base/browser/dom.js');
const {
  Button
} = require('../../../../base/browser/ui/button/button.js');
const {
  Codicon
} = require('../../../../base/common/codicons.js');
const {
  Emitter
} = require('../../../../base/common/event.js');
const {
  Disposable,
  DisposableStore,
  MutableDisposable
} = require('../../../../base/common/lifecycle.js');
const {
  Schemas
} = require('../../../../base/common/network.js');
const {
  URI
} = require('../../../../base/common/uri.js');
const {
  EditorExtensionsRegistry
} = require('../../../../editor/browser/editorExtensions.js');
const {
  CodeEditorWidget
} = require('../../../../editor/browser/widget/codeEditor/codeEditorWidget.js');
const {
  EDITOR_FONT_DEFAULTS
} = require('../../../../editor/common/config/editorOptions.js');
const {
  Range
} = require('../../../../editor/common/core/range.js');
const {
  IModelService
} = require('../../../../editor/common/services/model.js');
const {
  ITextModelService
} = require('../../../../editor/common/services/resolverService.js');
const {
  BracketMatchingController
} = require('../../../../editor/contrib/bracketMatching/browser/bracketMatching.js');
const {
  ContextMenuController
} = require('../../../../editor/contrib/contextmenu/browser/contextmenu.js');
const {
  GotoDefinitionAtPositionEditorContribution
} = require('../../../../editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.js');
const {
  ViewportSemanticTokensContribution
} = require('../../../../editor/contrib/semanticTokens/browser/viewportSemanticTokens.js');
const {
  SmartSelectController
} = require('../../../../editor/contrib/smartSelect/browser/smartSelect.js');
const {
  WordHighlighterContribution
} = require('../../../../editor/contrib/wordHighlighter/browser/wordHighlighter.js');
const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  IAccessibilityService
} = require('../../../../platform/accessibility/common/accessibility.service.js');
const {
  MenuWorkbenchToolBar
} = require('../../../../platform/actions/browser/toolbar.js');
const {
  IConfigurationService
} = require('../../../../platform/configuration/common/configuration.service.js');
const {
  IContextKeyService
} = require('../../../../platform/contextkey/common/contextkey.service.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {
  ServiceCollection
} = require('../../../../platform/instantiation/common/serviceCollection.js');
const {
  isResponseVM
} = require('../common/chatViewModel.js');
const {
  MenuPreventer
} = require('../../codeEditor/browser/menuPreventer.js');
const {
  SelectionClipboardContributionID
} = require('../../codeEditor/browser/selectionClipboard.js');
const {
  getSimpleEditorOptions
} = require('../../codeEditor/browser/simpleEditorOptions.js');
const {
  TabFocus
} = require('../../../../editor/browser/config/tabFocus.js');
const {
  DiffEditorWidget
} = require('../../../../editor/browser/widget/diffEditor/diffEditorWidget.js');
const {
  HoverController
} = require('../../../../editor/contrib/hover/browser/hoverController.js');
const {
  CONTEXT_CHAT_EDIT_APPLIED
} = require('../common/chatContextKeys.js');
const {
  ILabelService
} = require('../../../../platform/label/common/label.service.js');
const {
  renderFormattedText
} = require('../../../../base/browser/formattedTextRenderer.js');
const {
  IOpenerService
} = require('../../../../platform/opener/common/opener.service.js');
const {
  TextEdit
} = require('../../../../editor/common/languages.js');
const {
  ICodeEditorService
} = require('../../../../editor/browser/services/codeEditorService.js');
const {
  isEqual
} = require('../../../../base/common/resources.js');
const {
  DefaultModelSHA1Computer
} = require('../../../../editor/common/services/modelService.js');
const {
  IDialogService
} = require('../../../../platform/dialogs/common/dialogs.service.js');
const {
  TextModelText
} = require('../../../../editor/common/model/textModelText.js');
const _moduleId = "vs/workbench/contrib/chat/browser/codeBlockPart";
const $ = $$1;
const localFileLanguageId = 'vscode-local-file';
function parseLocalFileData(text) {
  let data;
  try {
    data = JSON.parse(text);
  } catch (e) {
    throw new Error('Could not parse code block local file data');
  }
  let uri;
  try {
    uri = URI.revive(data?.uri);
  } catch (e) {
    throw new Error('Invalid code block local file data URI');
  }
  let range;
  if (data.range) {
    range = new Range(data.range.startLineNumber + 1, data.range.startColumn + 1, data.range.endLineNumber + 1, data.range.endColumn + 1);
  }
  return {
    uri,
    range
  };
}
const defaultCodeblockPadding = 10;
let CodeBlockPart = class CodeBlockPart extends Disposable {
  constructor(options, menuId, delegate, overflowWidgetsDomNode, instantiationService, contextKeyService, modelService, configurationService, accessibilityService) {
    super();
    this.options = options;
    this.menuId = menuId;
    this.modelService = modelService;
    this.configurationService = configurationService;
    this.accessibilityService = accessibilityService;
    this._onDidChangeContentHeight = this._register(new Emitter());
    this.onDidChangeContentHeight = this._onDidChangeContentHeight.event;
    this.currentScrollWidth = 0;
    this.disposableStore = this._register(new DisposableStore());
    this.element = $('.interactive-result-code-block');
    this.contextKeyService = this._register(contextKeyService.createScoped(this.element));
    const scopedInstantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, this.contextKeyService]));
    const editorElement = append(this.element, $('.interactive-result-editor'));
    this.editor = this.createEditor(scopedInstantiationService, editorElement, {
      ...getSimpleEditorOptions(this.configurationService),
      readOnly: true,
      lineNumbers: 'off',
      selectOnLineNumbers: true,
      scrollBeyondLastLine: false,
      lineDecorationsWidth: 8,
      dragAndDrop: false,
      padding: {
        top: defaultCodeblockPadding,
        bottom: defaultCodeblockPadding
      },
      mouseWheelZoom: false,
      scrollbar: {
        vertical: 'hidden',
        alwaysConsumeMouseWheel: false
      },
      definitionLinkOpensInPeek: false,
      gotoLocation: {
        multiple: 'goto',
        multipleDeclarations: 'goto',
        multipleDefinitions: 'goto',
        multipleImplementations: 'goto'
      },
      ariaLabel: localizeWithPath(_moduleId, 0, 'Code block'),
      overflowWidgetsDomNode,
      ...this.getEditorOptionsFromConfig()
    });
    const toolbarElement = append(this.element, $('.interactive-result-code-block-toolbar'));
    const editorScopedService = this.editor.contextKeyService.createScoped(toolbarElement);
    const editorScopedInstantiationService = scopedInstantiationService.createChild(new ServiceCollection([IContextKeyService, editorScopedService]));
    this.toolbar = this._register(editorScopedInstantiationService.createInstance(MenuWorkbenchToolBar, toolbarElement, menuId, {
      menuOptions: {
        shouldForwardArgs: true
      }
    }));
    const vulnsContainer = append(this.element, $('.interactive-result-vulns'));
    const vulnsHeaderElement = append(vulnsContainer, $('.interactive-result-vulns-header', undefined));
    this.vulnsButton = this._register(new Button(vulnsHeaderElement, {
      buttonBackground: undefined,
      buttonBorder: undefined,
      buttonForeground: undefined,
      buttonHoverBackground: undefined,
      buttonSecondaryBackground: undefined,
      buttonSecondaryForeground: undefined,
      buttonSecondaryHoverBackground: undefined,
      buttonSeparator: undefined,
      supportIcons: true
    }));
    this.vulnsListElement = append(vulnsContainer, $('ul.interactive-result-vulns-list'));
    this._register(this.vulnsButton.onDidClick(() => {
      const element = this.currentCodeBlockData.element;
      element.vulnerabilitiesListExpanded = !element.vulnerabilitiesListExpanded;
      this.vulnsButton.label = this.getVulnerabilitiesLabel();
      this.element.classList.toggle('chat-vulnerabilities-collapsed', !element.vulnerabilitiesListExpanded);
      this._onDidChangeContentHeight.fire();
    }));
    this._register(this.toolbar.onDidChangeDropdownVisibility(e => {
      toolbarElement.classList.toggle('force-visibility', e);
    }));
    this._configureForScreenReader();
    this._register(this.accessibilityService.onDidChangeScreenReaderOptimized(() => this._configureForScreenReader()));
    this._register(this.configurationService.onDidChangeConfiguration(e => {
      if (e.affectedKeys.has("accessibility.verbosity.panelChat")) {
        this._configureForScreenReader();
      }
    }));
    this._register(this.options.onDidChange(() => {
      this.editor.updateOptions(this.getEditorOptionsFromConfig());
    }));
    this._register(this.editor.onDidScrollChange(e => {
      this.currentScrollWidth = e.scrollWidth;
    }));
    this._register(this.editor.onDidContentSizeChange(e => {
      if (e.contentHeightChanged) {
        this._onDidChangeContentHeight.fire();
      }
    }));
    this._register(this.editor.onDidBlurEditorWidget(() => {
      this.element.classList.remove('focused');
      WordHighlighterContribution.get(this.editor)?.stopHighlighting();
      this.clearWidgets();
    }));
    this._register(this.editor.onDidFocusEditorWidget(() => {
      this.element.classList.add('focused');
      WordHighlighterContribution.get(this.editor)?.restoreViewState(true);
    }));
    if (delegate.onDidScroll) {
      this._register(delegate.onDidScroll(e => {
        this.clearWidgets();
      }));
    }
  }
  get uri() {
    return this.editor.getModel()?.uri;
  }
  createEditor(instantiationService, parent, options) {
    return this._register(instantiationService.createInstance(CodeEditorWidget, parent, options, {
      isSimpleWidget: false,
      contributions: EditorExtensionsRegistry.getSomeEditorContributions([MenuPreventer.ID, SelectionClipboardContributionID, ContextMenuController.ID, WordHighlighterContribution.ID, ViewportSemanticTokensContribution.ID, BracketMatchingController.ID, SmartSelectController.ID, HoverController.ID, GotoDefinitionAtPositionEditorContribution.ID])
    }));
  }
  focus() {
    this.editor.focus();
  }
  updatePaddingForLayout() {
    const horizontalScrollbarVisible = this.currentScrollWidth > this.editor.getLayoutInfo().contentWidth;
    const scrollbarHeight = this.editor.getLayoutInfo().horizontalScrollbarHeight;
    const bottomPadding = horizontalScrollbarVisible ? Math.max(defaultCodeblockPadding - scrollbarHeight, 2) : defaultCodeblockPadding;
    this.editor.updateOptions({
      padding: {
        top: defaultCodeblockPadding,
        bottom: bottomPadding
      }
    });
  }
  _configureForScreenReader() {
    const toolbarElt = this.toolbar.getElement();
    if (this.accessibilityService.isScreenReaderOptimized()) {
      toolbarElt.style.display = 'block';
      toolbarElt.ariaLabel = this.configurationService.getValue("accessibility.verbosity.panelChat") ? localizeWithPath(_moduleId, 1, 'Toolbar for code block which can be reached via tab') : localizeWithPath(_moduleId, 2, 'Code block toolbar');
    } else {
      toolbarElt.style.display = '';
    }
  }
  getEditorOptionsFromConfig() {
    return {
      wordWrap: this.options.configuration.resultEditor.wordWrap,
      fontLigatures: this.options.configuration.resultEditor.fontLigatures,
      bracketPairColorization: this.options.configuration.resultEditor.bracketPairColorization,
      fontFamily: this.options.configuration.resultEditor.fontFamily === 'default' ? EDITOR_FONT_DEFAULTS.fontFamily : this.options.configuration.resultEditor.fontFamily,
      fontSize: this.options.configuration.resultEditor.fontSize,
      fontWeight: this.options.configuration.resultEditor.fontWeight,
      lineHeight: this.options.configuration.resultEditor.lineHeight
    };
  }
  layout(width) {
    const contentHeight = this.getContentHeight();
    const editorBorder = 2;
    this.editor.layout({
      width: width - editorBorder,
      height: contentHeight
    });
    this.updatePaddingForLayout();
  }
  getContentHeight() {
    if (this.currentCodeBlockData?.range) {
      const lineCount = this.currentCodeBlockData.range.endLineNumber - this.currentCodeBlockData.range.startLineNumber + 1;
      const lineHeight = this.editor.getOption(67);
      return lineCount * lineHeight;
    }
    return this.editor.getContentHeight();
  }
  async render(data, width, editable) {
    this.currentCodeBlockData = data;
    if (data.parentContextKeyService) {
      this.contextKeyService.updateParent(data.parentContextKeyService);
    }
    if (this.options.configuration.resultEditor.wordWrap === 'on') {
      this.layout(width);
    }
    await this.updateEditor(data);
    this.layout(width);
    if (editable) {
      this.disposableStore.clear();
      this.disposableStore.add(this.editor.onDidFocusEditorWidget(() => TabFocus.setTabFocusMode(true)));
      this.disposableStore.add(this.editor.onDidBlurEditorWidget(() => TabFocus.setTabFocusMode(false)));
    }
    this.editor.updateOptions({
      ariaLabel: localizeWithPath(_moduleId, 3, "Code block {0}", data.codeBlockIndex + 1),
      readOnly: !editable
    });
    if (data.hideToolbar) {
      hide(this.toolbar.getElement());
    } else {
      show(this.toolbar.getElement());
    }
    if (data.vulns?.length && isResponseVM(data.element)) {
      clearNode(this.vulnsListElement);
      this.element.classList.remove('no-vulns');
      this.element.classList.toggle('chat-vulnerabilities-collapsed', !data.element.vulnerabilitiesListExpanded);
      append(this.vulnsListElement, ...data.vulns.map(v => $('li', undefined, $('span.chat-vuln-title', undefined, v.title), ' ' + v.description)));
      this.vulnsButton.label = this.getVulnerabilitiesLabel();
    } else {
      this.element.classList.add('no-vulns');
    }
  }
  reset() {
    this.clearWidgets();
  }
  clearWidgets() {
    HoverController.get(this.editor)?.hideContentHover();
  }
  async updateEditor(data) {
    const textModel = (await data.textModel).textEditorModel;
    this.editor.setModel(textModel);
    if (data.range) {
      this.editor.setSelection(data.range);
      this.editor.revealRangeInCenter(data.range, 1);
    }
    this.toolbar.context = {
      code: textModel.getTextBuffer().getValueInRange(data.range ?? textModel.getFullModelRange(), 0),
      codeBlockIndex: data.codeBlockIndex,
      element: data.element,
      languageId: textModel.getLanguageId()
    };
  }
  getVulnerabilitiesLabel() {
    if (!this.currentCodeBlockData || !this.currentCodeBlockData.vulns) {
      return '';
    }
    const referencesLabel = this.currentCodeBlockData.vulns.length > 1 ? localizeWithPath(_moduleId, 4, "{0} vulnerabilities", this.currentCodeBlockData.vulns.length) : localizeWithPath(_moduleId, 5, "{0} vulnerability", 1);
    const icon = element => element.vulnerabilitiesListExpanded ? Codicon.chevronDown : Codicon.chevronRight;
    return `${referencesLabel} $(${icon(this.currentCodeBlockData.element).id})`;
  }
};
CodeBlockPart = __decorate([__param(4, IInstantiationService), __param(5, IContextKeyService), __param(6, IModelService), __param(7, IConfigurationService), __param(8, IAccessibilityService)], CodeBlockPart);
let ChatCodeBlockContentProvider = class ChatCodeBlockContentProvider extends Disposable {
  constructor(textModelService, _modelService) {
    super();
    this._modelService = _modelService;
    this._register(textModelService.registerTextModelContentProvider(Schemas.vscodeChatCodeBlock, this));
  }
  async provideTextContent(resource) {
    const existing = this._modelService.getModel(resource);
    if (existing) {
      return existing;
    }
    return this._modelService.createModel('', null, resource);
  }
};
ChatCodeBlockContentProvider = __decorate([__param(0, ITextModelService), __param(1, IModelService)], ChatCodeBlockContentProvider);
let CodeCompareBlockPart = class CodeCompareBlockPart extends Disposable {
  constructor(options, menuId, delegate, overflowWidgetsDomNode, instantiationService, contextKeyService, modelService, configurationService, accessibilityService, labelService, openerService) {
    super();
    this.options = options;
    this.menuId = menuId;
    this.modelService = modelService;
    this.configurationService = configurationService;
    this.accessibilityService = accessibilityService;
    this.labelService = labelService;
    this.openerService = openerService;
    this._onDidChangeContentHeight = this._register(new Emitter());
    this.onDidChangeContentHeight = this._onDidChangeContentHeight.event;
    this._lastDiffEditorViewModel = this._store.add(new MutableDisposable());
    this.currentScrollWidth = 0;
    this.element = $('.interactive-result-code-block');
    this.element.classList.add('compare');
    this.messageElement = append(this.element, $('.message'));
    this.messageElement.setAttribute('role', 'status');
    this.messageElement.tabIndex = 0;
    this.contextKeyService = this._register(contextKeyService.createScoped(this.element));
    const scopedInstantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, this.contextKeyService]));
    const editorElement = append(this.element, $('.interactive-result-editor'));
    this.diffEditor = this.createDiffEditor(scopedInstantiationService, editorElement, {
      ...getSimpleEditorOptions(this.configurationService),
      lineNumbers: 'on',
      selectOnLineNumbers: true,
      scrollBeyondLastLine: false,
      lineDecorationsWidth: 12,
      dragAndDrop: false,
      padding: {
        top: defaultCodeblockPadding,
        bottom: defaultCodeblockPadding
      },
      mouseWheelZoom: false,
      scrollbar: {
        vertical: 'hidden',
        alwaysConsumeMouseWheel: false
      },
      definitionLinkOpensInPeek: false,
      gotoLocation: {
        multiple: 'goto',
        multipleDeclarations: 'goto',
        multipleDefinitions: 'goto',
        multipleImplementations: 'goto'
      },
      ariaLabel: localizeWithPath(_moduleId, 0, 'Code block'),
      overflowWidgetsDomNode,
      ...this.getEditorOptionsFromConfig()
    });
    const toolbarElement = append(this.element, $('.interactive-result-code-block-toolbar'));
    const editorScopedService = this.diffEditor.getModifiedEditor().contextKeyService.createScoped(toolbarElement);
    const editorScopedInstantiationService = scopedInstantiationService.createChild(new ServiceCollection([IContextKeyService, editorScopedService]));
    this.toolbar = this._register(editorScopedInstantiationService.createInstance(MenuWorkbenchToolBar, toolbarElement, menuId, {
      menuOptions: {
        shouldForwardArgs: true
      }
    }));
    this._register(this.toolbar.onDidChangeDropdownVisibility(e => {
      toolbarElement.classList.toggle('force-visibility', e);
    }));
    this._configureForScreenReader();
    this._register(this.accessibilityService.onDidChangeScreenReaderOptimized(() => this._configureForScreenReader()));
    this._register(this.configurationService.onDidChangeConfiguration(e => {
      if (e.affectedKeys.has("accessibility.verbosity.panelChat")) {
        this._configureForScreenReader();
      }
    }));
    this._register(this.options.onDidChange(() => {
      this.diffEditor.updateOptions(this.getEditorOptionsFromConfig());
    }));
    this._register(this.diffEditor.getModifiedEditor().onDidScrollChange(e => {
      this.currentScrollWidth = e.scrollWidth;
    }));
    this._register(this.diffEditor.onDidContentSizeChange(e => {
      if (e.contentHeightChanged) {
        this._onDidChangeContentHeight.fire();
      }
    }));
    this._register(this.diffEditor.getModifiedEditor().onDidBlurEditorWidget(() => {
      this.element.classList.remove('focused');
      WordHighlighterContribution.get(this.diffEditor.getModifiedEditor())?.stopHighlighting();
      this.clearWidgets();
    }));
    this._register(this.diffEditor.getModifiedEditor().onDidFocusEditorWidget(() => {
      this.element.classList.add('focused');
      WordHighlighterContribution.get(this.diffEditor.getModifiedEditor())?.restoreViewState(true);
    }));
    if (delegate.onDidScroll) {
      this._register(delegate.onDidScroll(e => {
        this.clearWidgets();
      }));
    }
  }
  get uri() {
    return this.diffEditor.getModifiedEditor().getModel()?.uri;
  }
  createDiffEditor(instantiationService, parent, options) {
    const widgetOptions = {
      isSimpleWidget: false,
      contributions: EditorExtensionsRegistry.getSomeEditorContributions([MenuPreventer.ID, SelectionClipboardContributionID, ContextMenuController.ID, WordHighlighterContribution.ID, ViewportSemanticTokensContribution.ID, BracketMatchingController.ID, SmartSelectController.ID, HoverController.ID, GotoDefinitionAtPositionEditorContribution.ID])
    };
    return this._register(instantiationService.createInstance(DiffEditorWidget, parent, {
      scrollbar: {
        useShadows: false,
        alwaysConsumeMouseWheel: false,
        ignoreHorizontalScrollbarInContentHeight: true
      },
      renderMarginRevertIcon: false,
      diffCodeLens: false,
      scrollBeyondLastLine: false,
      stickyScroll: {
        enabled: false
      },
      originalAriaLabel: localizeWithPath(_moduleId, 6, 'Original'),
      modifiedAriaLabel: localizeWithPath(_moduleId, 7, 'Modified'),
      diffAlgorithm: 'advanced',
      readOnly: false,
      isInEmbeddedEditor: true,
      useInlineViewWhenSpaceIsLimited: false,
      hideUnchangedRegions: {
        enabled: true,
        contextLineCount: 1
      },
      ...options
    }, {
      originalEditor: widgetOptions,
      modifiedEditor: widgetOptions
    }));
  }
  focus() {
    this.diffEditor.focus();
  }
  updatePaddingForLayout() {
    const horizontalScrollbarVisible = this.currentScrollWidth > this.diffEditor.getModifiedEditor().getLayoutInfo().contentWidth;
    const scrollbarHeight = this.diffEditor.getModifiedEditor().getLayoutInfo().horizontalScrollbarHeight;
    const bottomPadding = horizontalScrollbarVisible ? Math.max(defaultCodeblockPadding - scrollbarHeight, 2) : defaultCodeblockPadding;
    this.diffEditor.updateOptions({
      padding: {
        top: defaultCodeblockPadding,
        bottom: bottomPadding
      }
    });
  }
  _configureForScreenReader() {
    const toolbarElt = this.toolbar.getElement();
    if (this.accessibilityService.isScreenReaderOptimized()) {
      toolbarElt.style.display = 'block';
      toolbarElt.ariaLabel = this.configurationService.getValue("accessibility.verbosity.panelChat") ? localizeWithPath(_moduleId, 1, 'Toolbar for code block which can be reached via tab') : localizeWithPath(_moduleId, 2, 'Code block toolbar');
    } else {
      toolbarElt.style.display = '';
    }
  }
  getEditorOptionsFromConfig() {
    return {
      wordWrap: this.options.configuration.resultEditor.wordWrap,
      fontLigatures: this.options.configuration.resultEditor.fontLigatures,
      bracketPairColorization: this.options.configuration.resultEditor.bracketPairColorization,
      fontFamily: this.options.configuration.resultEditor.fontFamily === 'default' ? EDITOR_FONT_DEFAULTS.fontFamily : this.options.configuration.resultEditor.fontFamily,
      fontSize: this.options.configuration.resultEditor.fontSize,
      fontWeight: this.options.configuration.resultEditor.fontWeight,
      lineHeight: this.options.configuration.resultEditor.lineHeight
    };
  }
  layout(width) {
    const contentHeight = this.getContentHeight();
    const editorBorder = 2;
    const dimension = {
      width: width - editorBorder,
      height: contentHeight
    };
    this.element.style.height = `${dimension.height}px`;
    this.element.style.width = `${dimension.width}px`;
    this.diffEditor.layout(dimension);
    this.updatePaddingForLayout();
  }
  getContentHeight() {
    return this.diffEditor.getContentHeight();
  }
  async render(data, width, token) {
    if (data.parentContextKeyService) {
      this.contextKeyService.updateParent(data.parentContextKeyService);
    }
    if (this.options.configuration.resultEditor.wordWrap === 'on') {
      this.layout(width);
    }
    await this.updateEditor(data, token);
    this.layout(width);
    this.diffEditor.updateOptions({
      ariaLabel: localizeWithPath(_moduleId, 8, "Code Edits")
    });
    if (data.hideToolbar) {
      hide(this.toolbar.getElement());
    } else {
      show(this.toolbar.getElement());
    }
  }
  reset() {
    this.clearWidgets();
  }
  clearWidgets() {
    HoverController.get(this.diffEditor.getOriginalEditor())?.hideContentHover();
    HoverController.get(this.diffEditor.getModifiedEditor())?.hideContentHover();
  }
  async updateEditor(data, token) {
    if (!isResponseVM(data.element)) {
      return;
    }
    const isEditApplied = Boolean(data.edit.state?.applied ?? 0);
    CONTEXT_CHAT_EDIT_APPLIED.bindTo(this.contextKeyService).set(isEditApplied);
    this.element.classList.toggle('no-diff', isEditApplied);
    if (data.edit.state?.applied) {
      const uriLabel = this.labelService.getUriLabel(data.edit.uri, {
        relative: true,
        noPrefix: true
      });
      const template = data.edit.state.applied > 1 ? localizeWithPath(_moduleId, 9, "Made {0} changes in [[{1}]]", data.edit.state.applied, uriLabel) : localizeWithPath(_moduleId, 10, "Made 1 change in [[{0}]]", uriLabel);
      const message = renderFormattedText(template, {
        actionHandler: {
          callback: () => {
            this.openerService.open(data.edit.uri, {
              fromUserGesture: true,
              allowCommands: false
            });
          },
          disposables: this._store
        }
      });
      reset(this.messageElement, message);
    }
    const diffData = await data.diffData;
    if (!diffData) {
      return;
    }
    if (!isEditApplied) {
      const viewModel = this.diffEditor.createViewModel({
        original: diffData.original,
        modified: diffData.modified
      });
      await viewModel.waitForDiff();
      if (token.isCancellationRequested) {
        return;
      }
      this.diffEditor.setModel(viewModel);
      this._lastDiffEditorViewModel.value = viewModel;
    } else {
      this.diffEditor.setModel(null);
      this._lastDiffEditorViewModel.value = undefined;
    }
    this.toolbar.context = {
      edit: data.edit,
      element: data.element,
      diffEditor: this.diffEditor
    };
  }
};
CodeCompareBlockPart = __decorate([__param(4, IInstantiationService), __param(5, IContextKeyService), __param(6, IModelService), __param(7, IConfigurationService), __param(8, IAccessibilityService), __param(9, ILabelService), __param(10, IOpenerService)], CodeCompareBlockPart);
let DefaultChatTextEditor = class DefaultChatTextEditor {
  constructor(modelService, editorService, dialogService) {
    this.modelService = modelService;
    this.editorService = editorService;
    this.dialogService = dialogService;
    this._sha1 = new DefaultModelSHA1Computer();
  }
  async apply(response, item) {
    if (!response.response.value.includes(item)) {
      return;
    }
    if (item.state?.applied) {
      return;
    }
    let diffEditor;
    for (const candidate of this.editorService.listDiffEditors()) {
      if (!candidate.getContainerDomNode().isConnected) {
        continue;
      }
      const model = candidate.getModel();
      if (!model || !isEqual(model.original.uri, item.uri) || model.modified.uri.scheme !== Schemas.vscodeChatCodeCompreBlock) {
        diffEditor = candidate;
        break;
      }
    }
    const edits = diffEditor ? await this._applyWithDiffEditor(diffEditor, item) : await this._apply(item);
    response.setEditApplied(item, edits);
  }
  async _applyWithDiffEditor(diffEditor, item) {
    const model = diffEditor.getModel();
    if (!model) {
      return 0;
    }
    const diff = diffEditor.getDiffComputationResult();
    if (!diff || diff.identical) {
      return 0;
    }
    if (!(await this._checkSha1(model.original, item))) {
      return 0;
    }
    const modified = new TextModelText(model.modified);
    const edits = diff.changes2.map(i => i.toRangeMapping().toTextEdit(modified).toSingleEditOperation());
    model.original.pushStackElement();
    model.original.pushEditOperations(null, edits, () => null);
    model.original.pushStackElement();
    return edits.length;
  }
  async _apply(item) {
    const ref = await this.modelService.createModelReference(item.uri);
    try {
      if (!(await this._checkSha1(ref.object.textEditorModel, item))) {
        return 0;
      }
      ref.object.textEditorModel.pushStackElement();
      let total = 0;
      for (const group of item.edits) {
        const edits = group.map(TextEdit.asEditOperation);
        ref.object.textEditorModel.pushEditOperations(null, edits, () => null);
        total += edits.length;
      }
      ref.object.textEditorModel.pushStackElement();
      return total;
    } finally {
      ref.dispose();
    }
  }
  async _checkSha1(model, item) {
    if (item.state?.sha1 && this._sha1.computeSHA1(model) && this._sha1.computeSHA1(model) !== item.state.sha1) {
      const result = await this.dialogService.confirm({
        message: localizeWithPath(_moduleId, 11, "The original file has been modified."),
        detail: localizeWithPath(_moduleId, 12, "Do you want to apply the changes anyway?")
      });
      if (!result.confirmed) {
        return false;
      }
    }
    return true;
  }
};
DefaultChatTextEditor = __decorate([__param(0, ITextModelService), __param(1, ICodeEditorService), __param(2, IDialogService)], DefaultChatTextEditor);
exports.ChatCodeBlockContentProvider = ChatCodeBlockContentProvider;
exports.CodeBlockPart = CodeBlockPart;
exports.CodeCompareBlockPart = CodeCompareBlockPart;
exports.DefaultChatTextEditor = DefaultChatTextEditor;
exports.localFileLanguageId = localFileLanguageId;
exports.parseLocalFileData = parseLocalFileData;