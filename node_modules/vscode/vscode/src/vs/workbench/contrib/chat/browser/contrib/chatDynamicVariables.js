const {
  __decorate,
  __param
} = require('../../../../../../../../external/tslib/tslib.es6.js');
const {
  coalesce
} = require('../../../../../base/common/arrays.js');
const {
  MarkdownString
} = require('../../../../../base/common/htmlContent.js');
const {
  Disposable
} = require('../../../../../base/common/lifecycle.js');
const {
  basename
} = require('../../../../../base/common/resources.js');
const {
  URI
} = require('../../../../../base/common/uri.js');
const {
  Range
} = require('../../../../../editor/common/core/range.js');
const {
  ITextModelService
} = require('../../../../../editor/common/services/resolverService.js');
const {
  localizeWithPath
} = require('../../../../../nls.js');
const {
  Action2,
  registerAction2
} = require('../../../../../platform/actions/common/actions.js');
const {
  ICommandService
} = require('../../../../../platform/commands/common/commands.service.js');
const {
  ILabelService
} = require('../../../../../platform/label/common/label.service.js');
const {
  ILogService
} = require('../../../../../platform/log/common/log.service.js');
const {
  IQuickInputService
} = require('../../../../../platform/quickinput/common/quickInput.service.js');
const {
  ChatWidget
} = require('../chatWidget.js');
const {
  IChatVariablesService
} = require('../../common/chatVariables.service.js');
var ChatDynamicVariableModel_1;
const _moduleId = "vs/workbench/contrib/chat/browser/contrib/chatDynamicVariables";
const dynamicVariableDecorationType = 'chat-dynamic-variable';
let ChatDynamicVariableModel = class ChatDynamicVariableModel extends Disposable {
  static {
    ChatDynamicVariableModel_1 = this;
  }
  static {
    this.ID = 'chatDynamicVariableModel';
  }
  get variables() {
    return [...this._variables];
  }
  get id() {
    return ChatDynamicVariableModel_1.ID;
  }
  constructor(widget, labelService, logService) {
    super();
    this.widget = widget;
    this.labelService = labelService;
    this.logService = logService;
    this._variables = [];
    this._register(widget.inputEditor.onDidChangeModelContent(e => {
      e.changes.forEach(c => {
        this._variables = coalesce(this._variables.map(ref => {
          const intersection = Range.intersectRanges(ref.range, c.range);
          if (intersection && !intersection.isEmpty()) {
            const rangeToDelete = new Range(ref.range.startLineNumber, ref.range.startColumn, ref.range.endLineNumber, ref.range.endColumn - 1);
            this.widget.inputEditor.executeEdits(this.id, [{
              range: rangeToDelete,
              text: ''
            }]);
            return null;
          } else if (Range.compareRangesUsingStarts(ref.range, c.range) > 0) {
            const delta = c.text.length - c.rangeLength;
            return {
              ...ref,
              range: {
                startLineNumber: ref.range.startLineNumber,
                startColumn: ref.range.startColumn + delta,
                endLineNumber: ref.range.endLineNumber,
                endColumn: ref.range.endColumn + delta
              }
            };
          }
          return ref;
        }));
      });
      this.updateDecorations();
    }));
  }
  getInputState() {
    return this.variables;
  }
  setInputState(s) {
    if (!Array.isArray(s)) {
      this.logService.warn('ChatDynamicVariableModel.setInputState called with invalid state: ' + JSON.stringify(s));
      return;
    }
    this._variables = s;
    this.updateDecorations();
  }
  addReference(ref) {
    this._variables.push(ref);
    this.updateDecorations();
  }
  updateDecorations() {
    this.widget.inputEditor.setDecorationsByType('chat', dynamicVariableDecorationType, this._variables.map(r => ({
      range: r.range,
      hoverMessage: this.getHoverForReference(r)
    })));
  }
  getHoverForReference(ref) {
    const value = ref.data[0];
    if (URI.isUri(value.value)) {
      return new MarkdownString(this.labelService.getUriLabel(value.value, {
        relative: true
      }));
    } else {
      return value.value.toString();
    }
  }
};
ChatDynamicVariableModel = ChatDynamicVariableModel_1 = __decorate([__param(1, ILabelService), __param(2, ILogService)], ChatDynamicVariableModel);
ChatWidget.CONTRIBS.push(ChatDynamicVariableModel);
function isSelectAndInsertFileActionContext(context) {
  return 'widget' in context && 'range' in context;
}
class SelectAndInsertFileAction extends Action2 {
  static {
    this.ID = 'workbench.action.chat.selectAndInsertFile';
  }
  constructor() {
    super({
      id: SelectAndInsertFileAction.ID,
      title: ''
    });
  }
  async run(accessor, ...args) {
    const textModelService = accessor.get(ITextModelService);
    const logService = accessor.get(ILogService);
    const quickInputService = accessor.get(IQuickInputService);
    const chatVariablesService = accessor.get(IChatVariablesService);
    const context = args[0];
    if (!isSelectAndInsertFileActionContext(context)) {
      return;
    }
    const doCleanup = () => {
      context.widget.inputEditor.executeEdits('chatInsertFile', [{
        range: context.range,
        text: ``
      }]);
    };
    let options;
    const filesVariableName = 'files';
    const filesItem = {
      label: localizeWithPath(_moduleId, 0, 'All Files'),
      description: localizeWithPath(_moduleId, 1, 'Search for relevant files in the workspace and provide context from them')
    };
    if (chatVariablesService.hasVariable(filesVariableName)) {
      options = {
        providerOptions: {
          additionPicks: [filesItem, {
            type: 'separator'
          }]
        }
      };
    }
    const picks = await quickInputService.quickAccess.pick('', options);
    if (!picks?.length) {
      logService.trace('SelectAndInsertFileAction: no file selected');
      doCleanup();
      return;
    }
    const editor = context.widget.inputEditor;
    const range = context.range;
    if (picks[0] === filesItem) {
      const text = `#${filesVariableName}`;
      const success = editor.executeEdits('chatInsertFile', [{
        range,
        text: text + ' '
      }]);
      if (!success) {
        logService.trace(`SelectAndInsertFileAction: failed to insert "${text}"`);
        doCleanup();
      }
      return;
    }
    const resource = picks[0].resource;
    if (!textModelService.canHandleResource(resource)) {
      logService.trace('SelectAndInsertFileAction: non-text resource selected');
      doCleanup();
      return;
    }
    const fileName = basename(resource);
    const text = `#file:${fileName}`;
    const success = editor.executeEdits('chatInsertFile', [{
      range,
      text: text + ' '
    }]);
    if (!success) {
      logService.trace(`SelectAndInsertFileAction: failed to insert "${text}"`);
      doCleanup();
      return;
    }
    context.widget.getContrib(ChatDynamicVariableModel.ID)?.addReference({
      range: {
        startLineNumber: range.startLineNumber,
        startColumn: range.startColumn,
        endLineNumber: range.endLineNumber,
        endColumn: range.startColumn + text.length
      },
      data: [{
        level: 'full',
        value: resource
      }]
    });
  }
}
registerAction2(SelectAndInsertFileAction);
function isAddDynamicVariableContext(context) {
  return 'widget' in context && 'range' in context && 'variableData' in context;
}
class AddDynamicVariableAction extends Action2 {
  static {
    this.ID = 'workbench.action.chat.addDynamicVariable';
  }
  constructor() {
    super({
      id: AddDynamicVariableAction.ID,
      title: ''
    });
  }
  async run(accessor, ...args) {
    const context = args[0];
    if (!isAddDynamicVariableContext(context)) {
      return;
    }
    let range = context.range;
    const variableData = context.variableData;
    const doCleanup = () => {
      context.widget.inputEditor.executeEdits('chatInsertDynamicVariableWithArguments', [{
        range: context.range,
        text: ``
      }]);
    };
    if (context.command) {
      const commandService = accessor.get(ICommandService);
      const selection = await commandService.executeCommand(context.command.id, ...(context.command.arguments ?? []));
      if (!selection) {
        doCleanup();
        return;
      }
      const insertText = ':' + selection;
      const insertRange = new Range(range.startLineNumber, range.endColumn, range.endLineNumber, range.endColumn + insertText.length);
      range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + insertText.length);
      const editor = context.widget.inputEditor;
      const success = editor.executeEdits('chatInsertDynamicVariableWithArguments', [{
        range: insertRange,
        text: insertText + ' '
      }]);
      if (!success) {
        doCleanup();
        return;
      }
    }
    context.widget.getContrib(ChatDynamicVariableModel.ID)?.addReference({
      range: range,
      data: variableData
    });
  }
}
registerAction2(AddDynamicVariableAction);
exports.AddDynamicVariableAction = AddDynamicVariableAction;
exports.ChatDynamicVariableModel = ChatDynamicVariableModel;
exports.SelectAndInsertFileAction = SelectAndInsertFileAction;
exports.dynamicVariableDecorationType = dynamicVariableDecorationType;