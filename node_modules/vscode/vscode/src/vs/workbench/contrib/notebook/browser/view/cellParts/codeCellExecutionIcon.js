const {
  __decorate,
  __param
} = require('../../../../../../../../../external/tslib/tslib.es6.js');
const {
  reset
} = require('../../../../../../base/browser/dom.js');
const {
  renderLabelWithIcons
} = require('../../../../../../base/browser/ui/iconLabel/iconLabels.js');
const {
  Disposable
} = require('../../../../../../base/common/lifecycle.js');
const {
  localizeWithPath
} = require('../../../../../../nls.js');
const {
  ThemeIcon
} = require('../../../../../../base/common/themables.js');
const {
  successStateIcon,
  errorStateIcon,
  pendingStateIcon,
  executingStateIcon
} = require('../../notebookIcons.js');
const {
  NotebookCellExecutionState
} = require('../../../common/notebookCommon.js');
const {
  NotebookExecutionType
} = require('../../../common/notebookExecutionStateService.js');
const {
  INotebookExecutionStateService
} = require('../../../common/notebookExecutionStateService.service.js');
const _moduleId = "vs/workbench/contrib/notebook/browser/view/cellParts/codeCellExecutionIcon";
let CollapsedCodeCellExecutionIcon = class CollapsedCodeCellExecutionIcon extends Disposable {
  constructor(_notebookEditor, _cell, _element, _executionStateService) {
    super();
    this._cell = _cell;
    this._element = _element;
    this._executionStateService = _executionStateService;
    this._visible = false;
    this._update();
    this._register(this._executionStateService.onDidChangeExecution(e => {
      if (e.type === NotebookExecutionType.cell && e.affectsCell(this._cell.uri)) {
        this._update();
      }
    }));
    this._register(this._cell.model.onDidChangeInternalMetadata(() => this._update()));
  }
  setVisibility(visible) {
    this._visible = visible;
    this._update();
  }
  _update() {
    if (!this._visible) {
      return;
    }
    const runState = this._executionStateService.getCellExecution(this._cell.uri);
    const item = this._getItemForState(runState, this._cell.model.internalMetadata);
    if (item) {
      this._element.style.display = '';
      reset(this._element, ...renderLabelWithIcons(item.text));
      this._element.title = item.tooltip ?? '';
    } else {
      this._element.style.display = 'none';
      reset(this._element);
    }
  }
  _getItemForState(runState, internalMetadata) {
    const state = runState?.state;
    const {
      lastRunSuccess
    } = internalMetadata;
    if (!state && lastRunSuccess) {
      return {
        text: `$(${successStateIcon.id})`,
        tooltip: localizeWithPath(_moduleId, 0, "Success")
      };
    } else if (!state && lastRunSuccess === false) {
      return {
        text: `$(${errorStateIcon.id})`,
        tooltip: localizeWithPath(_moduleId, 1, "Failure")
      };
    } else if (state === NotebookCellExecutionState.Pending || state === NotebookCellExecutionState.Unconfirmed) {
      return {
        text: `$(${pendingStateIcon.id})`,
        tooltip: localizeWithPath(_moduleId, 2, "Pending")
      };
    } else if (state === NotebookCellExecutionState.Executing) {
      const icon = ThemeIcon.modify(executingStateIcon, 'spin');
      return {
        text: `$(${icon.id})`,
        tooltip: localizeWithPath(_moduleId, 3, "Executing")
      };
    }
    return;
  }
};
CollapsedCodeCellExecutionIcon = __decorate([__param(3, INotebookExecutionStateService)], CollapsedCodeCellExecutionIcon);
exports.CollapsedCodeCellExecutionIcon = CollapsedCodeCellExecutionIcon;