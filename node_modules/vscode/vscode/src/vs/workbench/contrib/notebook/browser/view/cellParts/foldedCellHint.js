const {
  __decorate,
  __param
} = require('../../../../../../../../../external/tslib/tslib.es6.js');
const {
  hide,
  reset,
  show,
  $,
  addDisposableListener,
  EventType
} = require('../../../../../../base/browser/dom.js');
const {
  Codicon
} = require('../../../../../../base/common/codicons.js');
const {
  ThemeIcon
} = require('../../../../../../base/common/themables.js');
const {
  localizeWithPath
} = require('../../../../../../nls.js');
const {
  FoldingController
} = require('../../controller/foldingController.js');
const {
  CellEditState
} = require('../../notebookBrowser.js');
const {
  CellContentPart
} = require('../cellPart.js');
const {
  executingStateIcon
} = require('../../notebookIcons.js');
const {
  INotebookExecutionStateService
} = require('../../../common/notebookExecutionStateService.service.js');
const {
  NotebookCellExecutionState
} = require('../../../common/notebookCommon.js');
const {
  MutableDisposable
} = require('../../../../../../base/common/lifecycle.js');
const _moduleId = "vs/workbench/contrib/notebook/browser/view/cellParts/foldedCellHint";
let FoldedCellHint = class FoldedCellHint extends CellContentPart {
  constructor(_notebookEditor, _container, _notebookExecutionStateService) {
    super();
    this._notebookEditor = _notebookEditor;
    this._container = _container;
    this._notebookExecutionStateService = _notebookExecutionStateService;
    this._runButtonListener = this._register(new MutableDisposable());
    this._cellExecutionListener = this._register(new MutableDisposable());
  }
  didRenderCell(element) {
    this.update(element);
  }
  update(element) {
    if (!this._notebookEditor.hasModel()) {
      this._cellExecutionListener.clear();
      this._runButtonListener.clear();
      return;
    }
    if (element.isInputCollapsed || element.getEditState() === CellEditState.Editing) {
      this._cellExecutionListener.clear();
      this._runButtonListener.clear();
      hide(this._container);
    } else if (element.foldingState === 2) {
      const idx = this._notebookEditor.getViewModel().getCellIndex(element);
      const length = this._notebookEditor.getViewModel().getFoldedLength(idx);
      reset(this._container, this.getRunFoldedSectionButton({
        start: idx,
        end: idx + length + 1
      }), this.getHiddenCellsLabel(length), this.getHiddenCellHintButton(element));
      show(this._container);
      const foldHintTop = element.layoutInfo.previewHeight;
      this._container.style.top = `${foldHintTop}px`;
    } else {
      this._cellExecutionListener.clear();
      this._runButtonListener.clear();
      hide(this._container);
    }
  }
  getHiddenCellsLabel(num) {
    const label = num === 1 ? localizeWithPath(_moduleId, 0, "1 cell hidden") : localizeWithPath(_moduleId, 1, "{0} cells hidden", num);
    return $('span.notebook-folded-hint-label', undefined, label);
  }
  getHiddenCellHintButton(element) {
    const expandIcon = $('span.cell-expand-part-button');
    expandIcon.classList.add(...ThemeIcon.asClassNameArray(Codicon.more));
    this._register(addDisposableListener(expandIcon, EventType.CLICK, () => {
      const controller = this._notebookEditor.getContribution(FoldingController.id);
      const idx = this._notebookEditor.getCellIndex(element);
      if (typeof idx === 'number') {
        controller.setFoldingStateDown(idx, 1, 1);
      }
    }));
    return expandIcon;
  }
  getRunFoldedSectionButton(range) {
    const runAllContainer = $('span.folded-cell-run-section-button');
    const cells = this._notebookEditor.getCellsInRange(range);
    const isRunning = cells.some(cell => {
      const cellExecution = this._notebookExecutionStateService.getCellExecution(cell.uri);
      return cellExecution && cellExecution.state === NotebookCellExecutionState.Executing;
    });
    const runAllIcon = isRunning ? ThemeIcon.modify(executingStateIcon, 'spin') : Codicon.play;
    runAllContainer.classList.add(...ThemeIcon.asClassNameArray(runAllIcon));
    this._runButtonListener.value = addDisposableListener(runAllContainer, EventType.CLICK, () => {
      this._notebookEditor.executeNotebookCells(cells);
    });
    this._cellExecutionListener.value = this._notebookExecutionStateService.onDidChangeExecution(() => {
      const isRunning = cells.some(cell => {
        const cellExecution = this._notebookExecutionStateService.getCellExecution(cell.uri);
        return cellExecution && cellExecution.state === NotebookCellExecutionState.Executing;
      });
      const runAllIcon = isRunning ? ThemeIcon.modify(executingStateIcon, 'spin') : Codicon.play;
      runAllContainer.className = '';
      runAllContainer.classList.add('folded-cell-run-section-button', ...ThemeIcon.asClassNameArray(runAllIcon));
    });
    return runAllContainer;
  }
  updateInternalLayoutNow(element) {
    this.update(element);
  }
};
FoldedCellHint = __decorate([__param(2, INotebookExecutionStateService)], FoldedCellHint);
exports.FoldedCellHint = FoldedCellHint;