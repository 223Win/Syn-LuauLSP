const {
  EditOperation
} = require('../../../../editor/common/core/editOperation.js');
const {
  AsyncIterableSource
} = require('../../../../base/common/async.js');
const {
  getNWords
} = require('../../chat/common/chatWordCounter.js');
async function performAsyncTextEdit(model, edit, progress, obs) {
  const [id] = model.deltaDecorations([], [{
    range: edit.range,
    options: {
      description: 'asyncTextEdit',
      stickiness: 0
    }
  }]);
  let first = true;
  for await (const part of edit.newText) {
    if (model.isDisposed()) {
      break;
    }
    const range = model.getDecorationRange(id);
    if (!range) {
      throw new Error('FAILED to perform async replace edit because the anchor decoration was removed');
    }
    const edit = first ? EditOperation.replace(range, part) : EditOperation.insert(range.getEndPosition(), part);
    obs?.start();
    model.pushEditOperations(null, [edit], undoEdits => {
      progress?.report(undoEdits);
      return null;
    });
    obs?.stop();
    first = false;
  }
}
function asProgressiveEdit(interval, edit, wordsPerSec, token) {
  wordsPerSec = Math.max(30, wordsPerSec);
  const stream = new AsyncIterableSource();
  let newText = edit.text ?? '';
  interval.cancelAndSet(() => {
    const r = getNWords(newText, 1);
    stream.emitOne(r.value);
    newText = newText.substring(r.value.length);
    if (r.isFullString) {
      interval.cancel();
      stream.resolve();
      d.dispose();
    }
  }, 1000 / wordsPerSec);
  const d = token.onCancellationRequested(() => {
    interval.cancel();
    stream.resolve();
    d.dispose();
  });
  return {
    range: edit.range,
    newText: stream.asyncIterable
  };
}
exports.asProgressiveEdit = asProgressiveEdit;
exports.performAsyncTextEdit = performAsyncTextEdit;