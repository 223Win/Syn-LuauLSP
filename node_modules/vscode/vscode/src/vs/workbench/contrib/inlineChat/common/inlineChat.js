const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  MenuId
} = require('../../../../platform/actions/common/actions.js');
const {
  Extensions$1
} = require('../../../../platform/configuration/common/configurationRegistry.js');
const {
  RawContextKey
} = require('../../../../platform/contextkey/common/contextkey.js');
const {
  Registry
} = require('../../../../platform/registry/common/platform.js');
const {
  registerColor,
  transparent
} = require('../../../../platform/theme/common/colorUtils.js');
const {
  focusBorder
} = require('../../../../platform/theme/common/colors/baseColors.js');
const {} = require('../../../../platform/theme/common/colors/chartsColors.js');
const {
  editorWidgetBackground,
  editorWidgetBorder,
  widgetShadow,
  editorHoverHighlight,
  diffInserted,
  diffRemoved
} = require('../../../../platform/theme/common/colors/editorColors.js');
const {
  inputPlaceholderForeground,
  inputBackground
} = require('../../../../platform/theme/common/colors/inputColors.js');
const {} = require('../../../../platform/theme/common/colors/listColors.js');
const {} = require('../../../../platform/theme/common/colors/menuColors.js');
const {} = require('../../../../platform/theme/common/colors/minimapColors.js');
const {} = require('../../../../platform/theme/common/colors/miscColors.js');
const {} = require('../../../../platform/theme/common/colors/quickpickColors.js');
const {} = require('../../../../platform/theme/common/colors/searchColors.js');
const {
  Extensions
} = require('../../../common/configuration.js');
const _moduleId = "vs/workbench/contrib/inlineChat/common/inlineChat";
const INLINE_CHAT_ID = 'interactiveEditor';
const INTERACTIVE_EDITOR_ACCESSIBILITY_HELP_ID = 'interactiveEditorAccessiblityHelp';
const CTX_INLINE_CHAT_HAS_PROVIDER = new RawContextKey('inlineChatHasProvider', false, localizeWithPath(_moduleId, 0, "Whether a provider for interactive editors exists"));
const CTX_INLINE_CHAT_VISIBLE = new RawContextKey('inlineChatVisible', false, localizeWithPath(_moduleId, 1, "Whether the interactive editor input is visible"));
const CTX_INLINE_CHAT_FOCUSED = new RawContextKey('inlineChatFocused', false, localizeWithPath(_moduleId, 2, "Whether the interactive editor input is focused"));
const CTX_INLINE_CHAT_RESPONSE_FOCUSED = new RawContextKey('inlineChatResponseFocused', false, localizeWithPath(_moduleId, 3, "Whether the interactive widget's response is focused"));
const CTX_INLINE_CHAT_EMPTY = new RawContextKey('inlineChatEmpty', false, localizeWithPath(_moduleId, 4, "Whether the interactive editor input is empty"));
const CTX_INLINE_CHAT_INNER_CURSOR_FIRST = new RawContextKey('inlineChatInnerCursorFirst', false, localizeWithPath(_moduleId, 5, "Whether the cursor of the iteractive editor input is on the first line"));
const CTX_INLINE_CHAT_INNER_CURSOR_LAST = new RawContextKey('inlineChatInnerCursorLast', false, localizeWithPath(_moduleId, 6, "Whether the cursor of the iteractive editor input is on the last line"));
const CTX_INLINE_CHAT_OUTER_CURSOR_POSITION = new RawContextKey('inlineChatOuterCursorPosition', '', localizeWithPath(_moduleId, 9, "Whether the cursor of the outer editor is above or below the interactive editor input"));
const CTX_INLINE_CHAT_HAS_STASHED_SESSION = new RawContextKey('inlineChatHasStashedSession', false, localizeWithPath(_moduleId, 11, "Whether interactive editor has kept a session for quick restore"));
const CTX_INLINE_CHAT_LAST_RESPONSE_TYPE = new RawContextKey('inlineChatLastResponseType', undefined, localizeWithPath(_moduleId, 12, "What type was the last response of the current interactive editor session"));
const CTX_INLINE_CHAT_RESPONSE_TYPES = new RawContextKey('inlineChatResponseTypes', "empty", localizeWithPath(_moduleId, 13, "What type was the responses have been receieved"));
const CTX_INLINE_CHAT_DID_EDIT = new RawContextKey('inlineChatDidEdit', undefined, localizeWithPath(_moduleId, 14, "Whether interactive editor did change any code"));
const CTX_INLINE_CHAT_USER_DID_EDIT = new RawContextKey('inlineChatUserDidEdit', undefined, localizeWithPath(_moduleId, 15, "Whether the user did changes ontop of the inline chat"));
const CTX_INLINE_CHAT_LAST_FEEDBACK = new RawContextKey('inlineChatLastFeedbackKind', '', localizeWithPath(_moduleId, 16, "The last kind of feedback that was provided"));
const CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING = new RawContextKey('inlineChatSupportIssueReporting', false, localizeWithPath(_moduleId, 17, "Whether the interactive editor supports issue reporting"));
const CTX_INLINE_CHAT_DOCUMENT_CHANGED = new RawContextKey('inlineChatDocumentChanged', false, localizeWithPath(_moduleId, 18, "Whether the document has changed concurrently"));
const CTX_INLINE_CHAT_CHANGE_HAS_DIFF = new RawContextKey('inlineChatChangeHasDiff', false, localizeWithPath(_moduleId, 19, "Whether the current change supports showing a diff"));
const CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF = new RawContextKey('inlineChatChangeShowsDiff', false, localizeWithPath(_moduleId, 20, "Whether the current change showing a diff"));
const CTX_INLINE_CHAT_EDIT_MODE = new RawContextKey('config.inlineChat.mode', "live");
const ACTION_ACCEPT_CHANGES = 'inlineChat.acceptChanges';
const ACTION_REGENERATE_RESPONSE = 'inlineChat.regenerate';
const ACTION_VIEW_IN_CHAT = 'inlineChat.viewInChat';
const ACTION_TOGGLE_DIFF = 'inlineChat.toggleDiff';
const MENU_INLINE_CHAT_WIDGET = MenuId.for('inlineChatWidget');
const MENU_INLINE_CHAT_WIDGET_STATUS = MenuId.for('inlineChatWidget.status');
const MENU_INLINE_CHAT_WIDGET_DISCARD = MenuId.for('inlineChatWidget.undo');
const inlineChatBackground = registerColor('inlineChat.background', {
  dark: editorWidgetBackground,
  light: editorWidgetBackground,
  hcDark: editorWidgetBackground,
  hcLight: editorWidgetBackground
}, localizeWithPath(_moduleId, 21, "Background color of the interactive editor widget"));
registerColor('inlineChat.border', {
  dark: editorWidgetBorder,
  light: editorWidgetBorder,
  hcDark: editorWidgetBorder,
  hcLight: editorWidgetBorder
}, localizeWithPath(_moduleId, 22, "Border color of the interactive editor widget"));
registerColor('inlineChat.shadow', {
  dark: widgetShadow,
  light: widgetShadow,
  hcDark: widgetShadow,
  hcLight: widgetShadow
}, localizeWithPath(_moduleId, 23, "Shadow color of the interactive editor widget"));
registerColor('inlineChat.regionHighlight', {
  dark: editorHoverHighlight,
  light: editorHoverHighlight,
  hcDark: editorHoverHighlight,
  hcLight: editorHoverHighlight
}, localizeWithPath(_moduleId, 24, "Background highlighting of the current interactive region. Must be transparent."), true);
registerColor('inlineChatInput.border', {
  dark: editorWidgetBorder,
  light: editorWidgetBorder,
  hcDark: editorWidgetBorder,
  hcLight: editorWidgetBorder
}, localizeWithPath(_moduleId, 25, "Border color of the interactive editor input"));
registerColor('inlineChatInput.focusBorder', {
  dark: focusBorder,
  light: focusBorder,
  hcDark: focusBorder,
  hcLight: focusBorder
}, localizeWithPath(_moduleId, 26, "Border color of the interactive editor input when focused"));
registerColor('inlineChatInput.placeholderForeground', {
  dark: inputPlaceholderForeground,
  light: inputPlaceholderForeground,
  hcDark: inputPlaceholderForeground,
  hcLight: inputPlaceholderForeground
}, localizeWithPath(_moduleId, 27, "Foreground color of the interactive editor input placeholder"));
registerColor('inlineChatInput.background', {
  dark: inputBackground,
  light: inputBackground,
  hcDark: inputBackground,
  hcLight: inputBackground
}, localizeWithPath(_moduleId, 28, "Background color of the interactive editor input"));
registerColor('inlineChatDiff.inserted', {
  dark: transparent(diffInserted, .5),
  light: transparent(diffInserted, .5),
  hcDark: transparent(diffInserted, .5),
  hcLight: transparent(diffInserted, .5)
}, localizeWithPath(_moduleId, 29, "Background color of inserted text in the interactive editor input"));
const overviewRulerInlineChatDiffInserted = registerColor('editorOverviewRuler.inlineChatInserted', {
  dark: transparent(diffInserted, 0.6),
  light: transparent(diffInserted, 0.8),
  hcDark: transparent(diffInserted, 0.6),
  hcLight: transparent(diffInserted, 0.8)
}, localizeWithPath(_moduleId, 30, 'Overview ruler marker color for inline chat inserted content.'));
const minimapInlineChatDiffInserted = registerColor('editorOverviewRuler.inlineChatInserted', {
  dark: transparent(diffInserted, 0.6),
  light: transparent(diffInserted, 0.8),
  hcDark: transparent(diffInserted, 0.6),
  hcLight: transparent(diffInserted, 0.8)
}, localizeWithPath(_moduleId, 30, 'Overview ruler marker color for inline chat inserted content.'));
registerColor('inlineChatDiff.removed', {
  dark: transparent(diffRemoved, .5),
  light: transparent(diffRemoved, .5),
  hcDark: transparent(diffRemoved, .5),
  hcLight: transparent(diffRemoved, .5)
}, localizeWithPath(_moduleId, 31, "Background color of removed text in the interactive editor input"));
registerColor('editorOverviewRuler.inlineChatRemoved', {
  dark: transparent(diffRemoved, 0.6),
  light: transparent(diffRemoved, 0.8),
  hcDark: transparent(diffRemoved, 0.6),
  hcLight: transparent(diffRemoved, 0.8)
}, localizeWithPath(_moduleId, 32, 'Overview ruler marker color for inline chat removed content.'));
Registry.as(Extensions.ConfigurationMigration).registerConfigurationMigrations([{
  key: 'interactiveEditor.editMode',
  migrateFn: value => {
    return [['inlineChat.mode', {
      value: value
    }]];
  }
}]);
Registry.as(Extensions$1.Configuration).registerConfiguration({
  id: 'editor',
  properties: {
    ["inlineChat.mode"]: {
      description: localizeWithPath(_moduleId, 33, "Configure if changes crafted with inline chat are applied directly to the document or are previewed first."),
      default: "live",
      type: 'string',
      enum: ["live", "preview"],
      markdownEnumDescriptions: [localizeWithPath(_moduleId, 34, "Changes are applied directly to the document, can be highlighted via inline diffs, and accepted/discarded by hunks. Ending a session will keep the changes."), localizeWithPath(_moduleId, 35, "Changes are previewed only and need to be accepted via the apply button. Ending a session will discard the changes.")],
      tags: ['experimental']
    },
    ["inlineChat.finishOnType"]: {
      description: localizeWithPath(_moduleId, 36, "Whether to finish an inline chat session when typing outside of changed regions."),
      default: false,
      type: 'boolean'
    },
    ["inlineChat.acceptedOrDiscardBeforeSave"]: {
      description: localizeWithPath(_moduleId, 37, "Whether pending inline chat sessions prevent saving."),
      default: true,
      type: 'boolean'
    },
    ["inlineChat.holdToSpeech"]: {
      description: localizeWithPath(_moduleId, 38, "Whether holding the inline chat keybinding will automatically enable speech recognition."),
      default: true,
      type: 'boolean'
    },
    ["inlineChat.accessibleDiffView"]: {
      description: localizeWithPath(_moduleId, 39, "Whether the inline chat also renders an accessible diff viewer for its changes."),
      default: 'auto',
      type: 'string',
      enum: ['auto', 'on', 'off'],
      markdownEnumDescriptions: [localizeWithPath(_moduleId, 40, "The accessible diff viewer is based screen reader mode being enabled."), localizeWithPath(_moduleId, 41, "The accessible diff viewer is always enabled."), localizeWithPath(_moduleId, 42, "The accessible diff viewer is never enabled.")]
    }
  }
});
exports.ACTION_ACCEPT_CHANGES = ACTION_ACCEPT_CHANGES;
exports.ACTION_REGENERATE_RESPONSE = ACTION_REGENERATE_RESPONSE;
exports.ACTION_TOGGLE_DIFF = ACTION_TOGGLE_DIFF;
exports.ACTION_VIEW_IN_CHAT = ACTION_VIEW_IN_CHAT;
exports.CTX_INLINE_CHAT_CHANGE_HAS_DIFF = CTX_INLINE_CHAT_CHANGE_HAS_DIFF;
exports.CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF = CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF;
exports.CTX_INLINE_CHAT_DID_EDIT = CTX_INLINE_CHAT_DID_EDIT;
exports.CTX_INLINE_CHAT_DOCUMENT_CHANGED = CTX_INLINE_CHAT_DOCUMENT_CHANGED;
exports.CTX_INLINE_CHAT_EDIT_MODE = CTX_INLINE_CHAT_EDIT_MODE;
exports.CTX_INLINE_CHAT_EMPTY = CTX_INLINE_CHAT_EMPTY;
exports.CTX_INLINE_CHAT_FOCUSED = CTX_INLINE_CHAT_FOCUSED;
exports.CTX_INLINE_CHAT_HAS_PROVIDER = CTX_INLINE_CHAT_HAS_PROVIDER;
exports.CTX_INLINE_CHAT_HAS_STASHED_SESSION = CTX_INLINE_CHAT_HAS_STASHED_SESSION;
exports.CTX_INLINE_CHAT_INNER_CURSOR_FIRST = CTX_INLINE_CHAT_INNER_CURSOR_FIRST;
exports.CTX_INLINE_CHAT_INNER_CURSOR_LAST = CTX_INLINE_CHAT_INNER_CURSOR_LAST;
exports.CTX_INLINE_CHAT_LAST_FEEDBACK = CTX_INLINE_CHAT_LAST_FEEDBACK;
exports.CTX_INLINE_CHAT_LAST_RESPONSE_TYPE = CTX_INLINE_CHAT_LAST_RESPONSE_TYPE;
exports.CTX_INLINE_CHAT_OUTER_CURSOR_POSITION = CTX_INLINE_CHAT_OUTER_CURSOR_POSITION;
exports.CTX_INLINE_CHAT_RESPONSE_FOCUSED = CTX_INLINE_CHAT_RESPONSE_FOCUSED;
exports.CTX_INLINE_CHAT_RESPONSE_TYPES = CTX_INLINE_CHAT_RESPONSE_TYPES;
exports.CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING = CTX_INLINE_CHAT_SUPPORT_ISSUE_REPORTING;
exports.CTX_INLINE_CHAT_USER_DID_EDIT = CTX_INLINE_CHAT_USER_DID_EDIT;
exports.CTX_INLINE_CHAT_VISIBLE = CTX_INLINE_CHAT_VISIBLE;
exports.INLINE_CHAT_ID = INLINE_CHAT_ID;
exports.INTERACTIVE_EDITOR_ACCESSIBILITY_HELP_ID = INTERACTIVE_EDITOR_ACCESSIBILITY_HELP_ID;
exports.MENU_INLINE_CHAT_WIDGET = MENU_INLINE_CHAT_WIDGET;
exports.MENU_INLINE_CHAT_WIDGET_DISCARD = MENU_INLINE_CHAT_WIDGET_DISCARD;
exports.MENU_INLINE_CHAT_WIDGET_STATUS = MENU_INLINE_CHAT_WIDGET_STATUS;
exports.inlineChatBackground = inlineChatBackground;
exports.minimapInlineChatDiffInserted = minimapInlineChatDiffInserted;
exports.overviewRulerInlineChatDiffInserted = overviewRulerInlineChatDiffInserted;