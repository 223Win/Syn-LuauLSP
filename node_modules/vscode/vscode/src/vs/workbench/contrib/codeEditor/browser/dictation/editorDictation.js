const {
  __decorate,
  __param
} = require('../../../../../../../../external/tslib/tslib.es6.js');
const {} = require('./editorDictation.css.js');
const {
  localize2WithPath,
  localizeWithPath
} = require('../../../../../nls.js');
const {
  CancellationTokenSource
} = require('../../../../../base/common/cancellation.js');
const {
  Disposable,
  MutableDisposable,
  toDisposable,
  DisposableStore
} = require('../../../../../base/common/lifecycle.js');
const {
  RawContextKey,
  ContextKeyExpr
} = require('../../../../../platform/contextkey/common/contextkey.js');
const {
  IContextKeyService
} = require('../../../../../platform/contextkey/common/contextkey.service.js');
const {
  SpeechToTextStatus,
  HasSpeechProvider
} = require('../../../speech/common/speechService.js');
const {
  ISpeechService
} = require('../../../speech/common/speechService.service.js');
const {
  Codicon
} = require('../../../../../base/common/codicons.js');
const {
  registerEditorContribution,
  EditorAction2
} = require('../../../../../editor/browser/editorExtensions.js');
const {
  EditorContextKeys
} = require('../../../../../editor/common/editorContextKeys.js');
const {
  IKeybindingService
} = require('../../../../../platform/keybinding/common/keybinding.service.js');
const {
  EditOperation
} = require('../../../../../editor/common/core/editOperation.js');
const {
  Selection
} = require('../../../../../editor/common/core/selection.js');
const {
  Position
} = require('../../../../../editor/common/core/position.js');
const {
  Range
} = require('../../../../../editor/common/core/range.js');
const {
  registerAction2
} = require('../../../../../platform/actions/common/actions.js');
const {
  assertIsDefined
} = require('../../../../../base/common/types.js');
const {
  ActionBar
} = require('../../../../../base/browser/ui/actionbar/actionbar.js');
const {
  toAction
} = require('../../../../../base/common/actions.js');
const {
  ThemeIcon
} = require('../../../../../base/common/themables.js');
var EditorDictation_1;
const _moduleId = "vs/workbench/contrib/codeEditor/browser/dictation/editorDictation";
const EDITOR_DICTATION_IN_PROGRESS = new RawContextKey('editorDictation.inProgress', false);
const VOICE_CATEGORY = localize2WithPath(_moduleId, 0, "Voice");
class EditorDictationStartAction extends EditorAction2 {
  constructor() {
    super({
      id: 'workbench.action.editorDictation.start',
      title: localize2WithPath(_moduleId, 1, "Start Dictation in Editor"),
      category: VOICE_CATEGORY,
      precondition: ContextKeyExpr.and(HasSpeechProvider, EDITOR_DICTATION_IN_PROGRESS.toNegated(), EditorContextKeys.readOnly.toNegated()),
      f1: true,
      keybinding: {
        primary: 2048 | 512 | 52,
        weight: 200
      }
    });
  }
  runEditorCommand(accessor, editor) {
    const keybindingService = accessor.get(IKeybindingService);
    const holdMode = keybindingService.enableKeybindingHoldMode(this.desc.id);
    if (holdMode) {
      let shouldCallStop = false;
      const handle = setTimeout(() => {
        shouldCallStop = true;
      }, 500);
      holdMode.finally(() => {
        clearTimeout(handle);
        if (shouldCallStop) {
          EditorDictation.get(editor)?.stop();
        }
      });
    }
    EditorDictation.get(editor)?.start();
  }
}
class EditorDictationStopAction extends EditorAction2 {
  static {
    this.ID = 'workbench.action.editorDictation.stop';
  }
  constructor() {
    super({
      id: EditorDictationStopAction.ID,
      title: localize2WithPath(_moduleId, 2, "Stop Dictation in Editor"),
      category: VOICE_CATEGORY,
      precondition: EDITOR_DICTATION_IN_PROGRESS,
      f1: true,
      keybinding: {
        primary: 9,
        weight: 200 + 100
      }
    });
  }
  runEditorCommand(_accessor, editor) {
    EditorDictation.get(editor)?.stop();
  }
}
class DictationWidget extends Disposable {
  constructor(editor, keybindingService) {
    super();
    this.editor = editor;
    this.suppressMouseDown = true;
    this.allowEditorOverflow = true;
    this.domNode = document.createElement('div');
    const actionBar = this._register(new ActionBar(this.domNode));
    const stopActionKeybinding = keybindingService.lookupKeybinding(EditorDictationStopAction.ID)?.getLabel();
    actionBar.push(toAction({
      id: EditorDictationStopAction.ID,
      label: stopActionKeybinding ? localizeWithPath(_moduleId, 3, "Stop Dictation ({0})", stopActionKeybinding) : localizeWithPath(_moduleId, 4, "Stop Dictation"),
      class: ThemeIcon.asClassName(Codicon.micFilled),
      run: () => EditorDictation.get(editor)?.stop()
    }), {
      icon: true,
      label: false,
      keybinding: stopActionKeybinding
    });
    this.domNode.classList.add('editor-dictation-widget');
    this.domNode.appendChild(actionBar.domNode);
  }
  getId() {
    return 'editorDictation';
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    if (!this.editor.hasModel()) {
      return null;
    }
    const selection = this.editor.getSelection();
    return {
      position: selection.getPosition(),
      preference: [selection.getPosition().equals(selection.getStartPosition()) ? 1 : 2, 0]
    };
  }
  beforeRender() {
    const lineHeight = this.editor.getOption(67);
    const width = this.editor.getLayoutInfo().contentWidth * 0.7;
    this.domNode.style.setProperty('--vscode-editor-dictation-widget-height', `${lineHeight}px`);
    this.domNode.style.setProperty('--vscode-editor-dictation-widget-width', `${width}px`);
    return null;
  }
  show() {
    this.editor.addContentWidget(this);
  }
  layout() {
    this.editor.layoutContentWidget(this);
  }
  active() {
    this.domNode.classList.add('recording');
  }
  hide() {
    this.domNode.classList.remove('recording');
    this.editor.removeContentWidget(this);
  }
}
let EditorDictation = class EditorDictation extends Disposable {
  static {
    EditorDictation_1 = this;
  }
  static {
    this.ID = 'editorDictation';
  }
  static get(editor) {
    return editor.getContribution(EditorDictation_1.ID);
  }
  constructor(editor, speechService, contextKeyService, keybindingService) {
    super();
    this.editor = editor;
    this.speechService = speechService;
    this.contextKeyService = contextKeyService;
    this.keybindingService = keybindingService;
    this.widget = this._register(new DictationWidget(this.editor, this.keybindingService));
    this.editorDictationInProgress = EDITOR_DICTATION_IN_PROGRESS.bindTo(this.contextKeyService);
    this.sessionDisposables = this._register(new MutableDisposable());
  }
  async start() {
    const disposables = new DisposableStore();
    this.sessionDisposables.value = disposables;
    this.widget.show();
    disposables.add(toDisposable(() => this.widget.hide()));
    this.editorDictationInProgress.set(true);
    disposables.add(toDisposable(() => this.editorDictationInProgress.reset()));
    const collection = this.editor.createDecorationsCollection();
    disposables.add(toDisposable(() => collection.clear()));
    disposables.add(this.editor.onDidChangeCursorPosition(() => this.widget.layout()));
    let previewStart = undefined;
    let lastReplaceTextLength = 0;
    const replaceText = (text, isPreview) => {
      if (!previewStart) {
        previewStart = assertIsDefined(this.editor.getPosition());
      }
      const endPosition = new Position(previewStart.lineNumber, previewStart.column + text.length);
      this.editor.executeEdits(EditorDictation_1.ID, [EditOperation.replace(Range.fromPositions(previewStart, previewStart.with(undefined, previewStart.column + lastReplaceTextLength)), text)], [Selection.fromPositions(endPosition)]);
      if (isPreview) {
        collection.set([{
          range: Range.fromPositions(previewStart, previewStart.with(undefined, previewStart.column + text.length)),
          options: {
            description: 'editor-dictation-preview',
            inlineClassName: 'ghost-text-decoration-preview'
          }
        }]);
      } else {
        collection.clear();
      }
      lastReplaceTextLength = text.length;
      if (!isPreview) {
        previewStart = undefined;
        lastReplaceTextLength = 0;
      }
      this.editor.revealPositionInCenterIfOutsideViewport(endPosition);
    };
    const cts = new CancellationTokenSource();
    disposables.add(toDisposable(() => cts.dispose(true)));
    const session = await this.speechService.createSpeechToTextSession(cts.token, 'editor');
    disposables.add(session.onDidChange(e => {
      if (cts.token.isCancellationRequested) {
        return;
      }
      switch (e.status) {
        case SpeechToTextStatus.Started:
          this.widget.active();
          break;
        case SpeechToTextStatus.Stopped:
          disposables.dispose();
          break;
        case SpeechToTextStatus.Recognizing:
          {
            if (!e.text) {
              return;
            }
            replaceText(e.text, true);
            break;
          }
        case SpeechToTextStatus.Recognized:
          {
            if (!e.text) {
              return;
            }
            replaceText(`${e.text} `, false);
            break;
          }
      }
    }));
  }
  stop() {
    this.sessionDisposables.clear();
  }
};
EditorDictation = EditorDictation_1 = __decorate([__param(1, ISpeechService), __param(2, IContextKeyService), __param(3, IKeybindingService)], EditorDictation);
registerEditorContribution(EditorDictation.ID, EditorDictation, 4);
registerAction2(EditorDictationStartAction);
registerAction2(EditorDictationStopAction);
exports.DictationWidget = DictationWidget;
exports.EditorDictation = EditorDictation;
exports.EditorDictationStartAction = EditorDictationStartAction;
exports.EditorDictationStopAction = EditorDictationStopAction;