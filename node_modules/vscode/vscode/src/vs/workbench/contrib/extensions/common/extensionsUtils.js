const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  Event
} = require('../../../../base/common/event.js');
const {
  onUnexpectedError
} = require('../../../../base/common/errors.js');
const {
  Disposable
} = require('../../../../base/common/lifecycle.js');
const {
  IExtensionManagementService
} = require('../../../../platform/extensionManagement/common/extensionManagement.service.js');
const {
  IWorkbenchExtensionEnablementService
} = require('../../../services/extensionManagement/common/extensionManagement.service.js');
const {
  IExtensionRecommendationsService
} = require('../../../services/extensionRecommendations/common/extensionRecommendations.service.js');
const {
  ILifecycleService
} = require('../../../services/lifecycle/common/lifecycle.service.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {
  areSameExtensions
} = require('../../../../platform/extensionManagement/common/extensionManagementUtil.js');
const {} = require('../../../../platform/notification/common/notification.js');
const {
  INotificationService
} = require('../../../../platform/notification/common/notification.service.js');
const Severity$1 = require('../../../../base/common/severity.js');
const _moduleId = "vs/workbench/contrib/extensions/common/extensionsUtils";
let KeymapExtensions = class KeymapExtensions extends Disposable {
  constructor(instantiationService, extensionEnablementService, tipsService, lifecycleService, notificationService) {
    super();
    this.instantiationService = instantiationService;
    this.extensionEnablementService = extensionEnablementService;
    this.tipsService = tipsService;
    this.notificationService = notificationService;
    this._register(lifecycleService.onDidShutdown(() => this.dispose()));
    this._register(instantiationService.invokeFunction(onExtensionChanged)(identifiers => {
      Promise.all(identifiers.map(identifier => this.checkForOtherKeymaps(identifier))).then(undefined, onUnexpectedError);
    }));
  }
  checkForOtherKeymaps(extensionIdentifier) {
    return this.instantiationService.invokeFunction(getInstalledExtensions).then(extensions => {
      const keymaps = extensions.filter(extension => isKeymapExtension(this.tipsService, extension));
      const extension = keymaps.find(extension => areSameExtensions(extension.identifier, extensionIdentifier));
      if (extension && extension.globallyEnabled) {
        const otherKeymaps = keymaps.filter(extension => !areSameExtensions(extension.identifier, extensionIdentifier) && extension.globallyEnabled);
        if (otherKeymaps.length) {
          return this.promptForDisablingOtherKeymaps(extension, otherKeymaps);
        }
      }
      return undefined;
    });
  }
  promptForDisablingOtherKeymaps(newKeymap, oldKeymaps) {
    const onPrompt = confirmed => {
      if (confirmed) {
        this.extensionEnablementService.setEnablement(oldKeymaps.map(keymap => keymap.local), 6);
      }
    };
    this.notificationService.prompt(Severity$1.Info, localizeWithPath(_moduleId, 0, "Disable other keymaps ({0}) to avoid conflicts between keybindings?", oldKeymaps.map(k => `'${k.local.manifest.displayName}'`).join(', ')), [{
      label: localizeWithPath(_moduleId, 1, "Yes"),
      run: () => onPrompt(true)
    }, {
      label: localizeWithPath(_moduleId, 2, "No"),
      run: () => onPrompt(false)
    }]);
  }
};
KeymapExtensions = __decorate([__param(0, IInstantiationService), __param(1, IWorkbenchExtensionEnablementService), __param(2, IExtensionRecommendationsService), __param(3, ILifecycleService), __param(4, INotificationService)], KeymapExtensions);
function onExtensionChanged(accessor) {
  const extensionService = accessor.get(IExtensionManagementService);
  const extensionEnablementService = accessor.get(IWorkbenchExtensionEnablementService);
  const onDidInstallExtensions = Event.chain(extensionService.onDidInstallExtensions, $ => $.filter(e => e.some(({
    operation
  }) => operation === 2)).map(e => e.map(({
    identifier
  }) => identifier)));
  return Event.debounce(Event.any(Event.any(onDidInstallExtensions, Event.map(extensionService.onDidUninstallExtension, e => [e.identifier])), Event.map(extensionEnablementService.onEnablementChanged, extensions => extensions.map(e => e.identifier))), (result, identifiers) => {
    result = result || [];
    for (const identifier of identifiers) {
      if (result.some(l => !areSameExtensions(l, identifier))) {
        result.push(identifier);
      }
    }
    return result;
  });
}
async function getInstalledExtensions(accessor) {
  const extensionService = accessor.get(IExtensionManagementService);
  const extensionEnablementService = accessor.get(IWorkbenchExtensionEnablementService);
  const extensions = await extensionService.getInstalled();
  return extensions.map(extension => {
    return {
      identifier: extension.identifier,
      local: extension,
      globallyEnabled: extensionEnablementService.isEnabled(extension)
    };
  });
}
function isKeymapExtension(tipsService, extension) {
  const cats = extension.local.manifest.categories;
  return cats && cats.indexOf('Keymaps') !== -1 || tipsService.getKeymapRecommendations().some(extensionId => areSameExtensions({
    id: extensionId
  }, extension.local.identifier));
}
exports.KeymapExtensions = KeymapExtensions;
exports.getInstalledExtensions = getInstalledExtensions;