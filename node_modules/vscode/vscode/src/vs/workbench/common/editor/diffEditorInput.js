const {
  __decorate,
  __param
} = require('../../../../../../external/tslib/tslib.es6.js');
const {
  localizeWithPath
} = require('../../../nls.js');
const {
  SideBySideEditorInput,
  AbstractSideBySideEditorInputSerializer
} = require('./sideBySideEditorInput.js');
const {
  BINARY_DIFF_EDITOR_ID,
  TEXT_DIFF_EDITOR_ID,
  isResourceDiffEditorInput
} = require('../editor.js');
const {
  BaseTextEditorModel
} = require('./textEditorModel.js');
const {
  DiffEditorModel
} = require('./diffEditorModel.js');
const {
  TextDiffEditorModel
} = require('./textDiffEditorModel.js');
const {
  IEditorService
} = require('../../services/editor/common/editorService.service.js');
const {
  shorten
} = require('../../../base/common/labels.js');
const {
  isResolvedEditorModel
} = require('../../../platform/editor/common/editor.js');
var DiffEditorInput_1;
const _moduleId = "vs/workbench/common/editor/diffEditorInput";
let DiffEditorInput = class DiffEditorInput extends SideBySideEditorInput {
  static {
    DiffEditorInput_1 = this;
  }
  static {
    this.ID = 'workbench.editors.diffEditorInput';
  }
  get typeId() {
    return DiffEditorInput_1.ID;
  }
  get editorId() {
    return this.modified.editorId === this.original.editorId ? this.modified.editorId : undefined;
  }
  get capabilities() {
    let capabilities = super.capabilities;
    if (this.labels.forceDescription) {
      capabilities |= 64;
    }
    return capabilities;
  }
  constructor(preferredName, preferredDescription, original, modified, forceOpenAsBinary, editorService) {
    super(preferredName, preferredDescription, original, modified, editorService);
    this.original = original;
    this.modified = modified;
    this.forceOpenAsBinary = forceOpenAsBinary;
    this.cachedModel = undefined;
    this.labels = this.computeLabels();
  }
  computeLabels() {
    let name;
    let forceDescription = false;
    if (this.preferredName) {
      name = this.preferredName;
    } else {
      const originalName = this.original.getName();
      const modifiedName = this.modified.getName();
      name = localizeWithPath(_moduleId, 0, "{0} ↔ {1}", originalName, modifiedName);
      forceDescription = originalName === modifiedName;
    }
    let shortDescription;
    let mediumDescription;
    let longDescription;
    if (this.preferredDescription) {
      shortDescription = this.preferredDescription;
      mediumDescription = this.preferredDescription;
      longDescription = this.preferredDescription;
    } else {
      shortDescription = this.computeLabel(this.original.getDescription(0), this.modified.getDescription(0));
      longDescription = this.computeLabel(this.original.getDescription(2), this.modified.getDescription(2));
      const originalMediumDescription = this.original.getDescription(1);
      const modifiedMediumDescription = this.modified.getDescription(1);
      if (typeof originalMediumDescription === 'string' && typeof modifiedMediumDescription === 'string' && (originalMediumDescription || modifiedMediumDescription)) {
        const [shortenedOriginalMediumDescription, shortenedModifiedMediumDescription] = shorten([originalMediumDescription, modifiedMediumDescription]);
        mediumDescription = this.computeLabel(shortenedOriginalMediumDescription, shortenedModifiedMediumDescription);
      }
    }
    let shortTitle = this.computeLabel(this.original.getTitle(0) ?? this.original.getName(), this.modified.getTitle(0) ?? this.modified.getName(), ' ↔ ');
    let mediumTitle = this.computeLabel(this.original.getTitle(1) ?? this.original.getName(), this.modified.getTitle(1) ?? this.modified.getName(), ' ↔ ');
    let longTitle = this.computeLabel(this.original.getTitle(2) ?? this.original.getName(), this.modified.getTitle(2) ?? this.modified.getName(), ' ↔ ');
    const preferredTitle = this.getPreferredTitle();
    if (preferredTitle) {
      shortTitle = `${preferredTitle} (${shortTitle})`;
      mediumTitle = `${preferredTitle} (${mediumTitle})`;
      longTitle = `${preferredTitle} (${longTitle})`;
    }
    return {
      name,
      shortDescription,
      mediumDescription,
      longDescription,
      forceDescription,
      shortTitle,
      mediumTitle,
      longTitle
    };
  }
  computeLabel(originalLabel, modifiedLabel, separator = ' - ') {
    if (!originalLabel || !modifiedLabel) {
      return undefined;
    }
    if (originalLabel === modifiedLabel) {
      return modifiedLabel;
    }
    return `${originalLabel}${separator}${modifiedLabel}`;
  }
  getName() {
    return this.labels.name;
  }
  getDescription(verbosity = 1) {
    switch (verbosity) {
      case 0:
        return this.labels.shortDescription;
      case 2:
        return this.labels.longDescription;
      case 1:
      default:
        return this.labels.mediumDescription;
    }
  }
  getTitle(verbosity) {
    switch (verbosity) {
      case 0:
        return this.labels.shortTitle;
      case 2:
        return this.labels.longTitle;
      default:
      case 1:
        return this.labels.mediumTitle;
    }
  }
  async resolve() {
    const resolvedModel = await this.createModel();
    this.cachedModel?.dispose();
    this.cachedModel = resolvedModel;
    return this.cachedModel;
  }
  prefersEditorPane(editorPanes) {
    if (this.forceOpenAsBinary) {
      return editorPanes.find(editorPane => editorPane.typeId === BINARY_DIFF_EDITOR_ID);
    }
    return editorPanes.find(editorPane => editorPane.typeId === TEXT_DIFF_EDITOR_ID);
  }
  async createModel() {
    const [originalEditorModel, modifiedEditorModel] = await Promise.all([this.original.resolve(), this.modified.resolve()]);
    if (modifiedEditorModel instanceof BaseTextEditorModel && originalEditorModel instanceof BaseTextEditorModel) {
      return new TextDiffEditorModel(originalEditorModel, modifiedEditorModel);
    }
    return new DiffEditorModel(isResolvedEditorModel(originalEditorModel) ? originalEditorModel : undefined, isResolvedEditorModel(modifiedEditorModel) ? modifiedEditorModel : undefined);
  }
  toUntyped(options) {
    const untyped = super.toUntyped(options);
    if (untyped) {
      return {
        ...untyped,
        modified: untyped.primary,
        original: untyped.secondary
      };
    }
    return undefined;
  }
  matches(otherInput) {
    if (this === otherInput) {
      return true;
    }
    if (otherInput instanceof DiffEditorInput_1) {
      return this.modified.matches(otherInput.modified) && this.original.matches(otherInput.original) && otherInput.forceOpenAsBinary === this.forceOpenAsBinary;
    }
    if (isResourceDiffEditorInput(otherInput)) {
      return this.modified.matches(otherInput.modified) && this.original.matches(otherInput.original);
    }
    return false;
  }
  dispose() {
    if (this.cachedModel) {
      this.cachedModel.dispose();
      this.cachedModel = undefined;
    }
    super.dispose();
  }
};
DiffEditorInput = DiffEditorInput_1 = __decorate([__param(5, IEditorService)], DiffEditorInput);
class DiffEditorInputSerializer extends AbstractSideBySideEditorInputSerializer {
  createEditorInput(instantiationService, name, description, secondaryInput, primaryInput) {
    return instantiationService.createInstance(DiffEditorInput, name, description, secondaryInput, primaryInput, undefined);
  }
}
exports.DiffEditorInput = DiffEditorInput;
exports.DiffEditorInputSerializer = DiffEditorInputSerializer;