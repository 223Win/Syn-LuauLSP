const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  Event
} = require('../../../../base/common/event.js');
const {
  Registry
} = require('../../../../platform/registry/common/platform.js');
const {
  ResourceMap
} = require('../../../../base/common/map.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {
  EditorExtensions,
  DEFAULT_EDITOR_ASSOCIATION,
  isResourceMergeEditorInput,
  isResourceDiffEditorInput,
  isResourceSideBySideEditorInput
} = require('../../../common/editor.js');
const {
  IUntitledTextEditorService
} = require('../../untitled/common/untitledTextEditorService.service.js');
const {
  Schemas
} = require('../../../../base/common/network.js');
const {
  DiffEditorInput
} = require('../../../common/editor/diffEditorInput.js');
const {
  SideBySideEditorInput
} = require('../../../common/editor/sideBySideEditorInput.js');
const {
  TextResourceEditorInput
} = require('../../../common/editor/textResourceEditorInput.js');
const {
  UntitledTextEditorInput
} = require('../../untitled/common/untitledTextEditorInput.js');
const {
  basename
} = require('../../../../base/common/resources.js');
const {
  URI
} = require('../../../../base/common/uri.js');
const {
  IUriIdentityService
} = require('../../../../platform/uriIdentity/common/uriIdentity.service.js');
const {
  IFileService
} = require('../../../../platform/files/common/files.service.js');
const {
  RegisteredEditorPriority
} = require('../../editor/common/editorResolverService.js');
const {
  IEditorResolverService
} = require('../../editor/common/editorResolverService.service.js');
const {
  Disposable
} = require('../../../../base/common/lifecycle.js');
let TextEditorService = class TextEditorService extends Disposable {
  constructor(untitledTextEditorService, instantiationService, uriIdentityService, fileService, editorResolverService) {
    super();
    this.untitledTextEditorService = untitledTextEditorService;
    this.instantiationService = instantiationService;
    this.uriIdentityService = uriIdentityService;
    this.fileService = fileService;
    this.editorResolverService = editorResolverService;
    this.editorInputCache = new ResourceMap();
    this.fileEditorFactory = Registry.as(EditorExtensions.EditorFactory).getFileEditorFactory();
    this.registerDefaultEditor();
  }
  registerDefaultEditor() {
    this._register(this.editorResolverService.registerEditor('*', {
      id: DEFAULT_EDITOR_ASSOCIATION.id,
      label: DEFAULT_EDITOR_ASSOCIATION.displayName,
      detail: DEFAULT_EDITOR_ASSOCIATION.providerDisplayName,
      priority: RegisteredEditorPriority.builtin
    }, {}, {
      createEditorInput: editor => ({
        editor: this.createTextEditor(editor)
      }),
      createUntitledEditorInput: untitledEditor => ({
        editor: this.createTextEditor(untitledEditor)
      }),
      createDiffEditorInput: diffEditor => ({
        editor: this.createTextEditor(diffEditor)
      })
    }));
  }
  async resolveTextEditor(input) {
    return this.createTextEditor(input);
  }
  createTextEditor(input) {
    if (isResourceMergeEditorInput(input)) {
      return this.createTextEditor(input.result);
    }
    if (isResourceDiffEditorInput(input)) {
      const original = this.createTextEditor(input.original);
      const modified = this.createTextEditor(input.modified);
      return this.instantiationService.createInstance(DiffEditorInput, input.label, input.description, original, modified, undefined);
    }
    if (isResourceSideBySideEditorInput(input)) {
      const primary = this.createTextEditor(input.primary);
      const secondary = this.createTextEditor(input.secondary);
      return this.instantiationService.createInstance(SideBySideEditorInput, input.label, input.description, secondary, primary);
    }
    const untitledInput = input;
    if (untitledInput.forceUntitled || !untitledInput.resource || untitledInput.resource.scheme === Schemas.untitled) {
      const untitledOptions = {
        languageId: untitledInput.languageId,
        initialValue: untitledInput.contents,
        encoding: untitledInput.encoding
      };
      let untitledModel;
      if (untitledInput.resource?.scheme === Schemas.untitled) {
        untitledModel = this.untitledTextEditorService.create({
          untitledResource: untitledInput.resource,
          ...untitledOptions
        });
      } else {
        untitledModel = this.untitledTextEditorService.create({
          associatedResource: untitledInput.resource,
          ...untitledOptions
        });
      }
      return this.createOrGetCached(untitledModel.resource, () => this.instantiationService.createInstance(UntitledTextEditorInput, untitledModel));
    }
    const textResourceEditorInput = input;
    if (textResourceEditorInput.resource instanceof URI) {
      const label = textResourceEditorInput.label || basename(textResourceEditorInput.resource);
      const preferredResource = textResourceEditorInput.resource;
      const canonicalResource = this.uriIdentityService.asCanonicalUri(preferredResource);
      return this.createOrGetCached(canonicalResource, () => {
        if (textResourceEditorInput.forceFile || this.fileService.hasProvider(canonicalResource)) {
          return this.fileEditorFactory.createFileEditor(canonicalResource, preferredResource, textResourceEditorInput.label, textResourceEditorInput.description, textResourceEditorInput.encoding, textResourceEditorInput.languageId, textResourceEditorInput.contents, this.instantiationService);
        }
        return this.instantiationService.createInstance(TextResourceEditorInput, canonicalResource, textResourceEditorInput.label, textResourceEditorInput.description, textResourceEditorInput.languageId, textResourceEditorInput.contents);
      }, cachedInput => {
        if (cachedInput instanceof UntitledTextEditorInput) {
          return;
        } else if (!(cachedInput instanceof TextResourceEditorInput)) {
          cachedInput.setPreferredResource(preferredResource);
          if (textResourceEditorInput.label) {
            cachedInput.setPreferredName(textResourceEditorInput.label);
          }
          if (textResourceEditorInput.description) {
            cachedInput.setPreferredDescription(textResourceEditorInput.description);
          }
          if (textResourceEditorInput.encoding) {
            cachedInput.setPreferredEncoding(textResourceEditorInput.encoding);
          }
          if (textResourceEditorInput.languageId) {
            cachedInput.setPreferredLanguageId(textResourceEditorInput.languageId);
          }
          if (typeof textResourceEditorInput.contents === 'string') {
            cachedInput.setPreferredContents(textResourceEditorInput.contents);
          }
        } else {
          if (label) {
            cachedInput.setName(label);
          }
          if (textResourceEditorInput.description) {
            cachedInput.setDescription(textResourceEditorInput.description);
          }
          if (textResourceEditorInput.languageId) {
            cachedInput.setPreferredLanguageId(textResourceEditorInput.languageId);
          }
          if (typeof textResourceEditorInput.contents === 'string') {
            cachedInput.setPreferredContents(textResourceEditorInput.contents);
          }
        }
      });
    }
    throw new Error(`ITextEditorService: Unable to create texteditor from ${JSON.stringify(input)}`);
  }
  createOrGetCached(resource, factoryFn, cachedFn) {
    let input = this.editorInputCache.get(resource);
    if (input) {
      cachedFn?.(input);
      return input;
    }
    input = factoryFn();
    this.editorInputCache.set(resource, input);
    Event.once(input.onWillDispose)(() => this.editorInputCache.delete(resource));
    return input;
  }
};
TextEditorService = __decorate([__param(0, IUntitledTextEditorService), __param(1, IInstantiationService), __param(2, IUriIdentityService), __param(3, IFileService), __param(4, IEditorResolverService)], TextEditorService);
exports.TextEditorService = TextEditorService;