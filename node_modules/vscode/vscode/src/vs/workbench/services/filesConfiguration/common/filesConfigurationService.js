const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  Emitter
} = require('../../../../base/common/event.js');
const {
  Disposable,
  toDisposable
} = require('../../../../base/common/lifecycle.js');
const {
  RawContextKey
} = require('../../../../platform/contextkey/common/contextkey.js');
const {
  IContextKeyService
} = require('../../../../platform/contextkey/common/contextkey.service.js');
const {
  IConfigurationService
} = require('../../../../platform/configuration/common/configuration.service.js');
const {
  AutoSaveConfiguration,
  FILES_READONLY_INCLUDE_CONFIG,
  FILES_READONLY_EXCLUDE_CONFIG,
  HotExitConfiguration,
  hasReadonlyCapability
} = require('../../../../platform/files/common/files.js');
const {
  IFileService
} = require('../../../../platform/files/common/files.service.js');
const {
  equals
} = require('../../../../base/common/objects.js');
const {
  isWeb
} = require('../../../../base/common/platform.js');
const {
  IWorkspaceContextService
} = require('../../../../platform/workspace/common/workspace.service.js');
const {
  ResourceGlobMatcher
} = require('../../../common/resources.js');
const {
  GlobalIdleValue
} = require('../../../../base/common/async.js');
const {
  IUriIdentityService
} = require('../../../../platform/uriIdentity/common/uriIdentity.service.js');
const {
  IEnvironmentService
} = require('../../../../platform/environment/common/environment.service.js');
const {
  LRUCache,
  ResourceMap
} = require('../../../../base/common/map.js');
const {
  EditorInput
} = require('../../../common/editor/editorInput.js');
const {
  EditorResourceAccessor,
  SideBySideEditor
} = require('../../../common/editor.js');
const {
  MarkerSeverity
} = require('../../../../platform/markers/common/markers.js');
const {
  IMarkerService
} = require('../../../../platform/markers/common/markers.service.js');
const {
  ITextResourceConfigurationService
} = require('../../../../editor/common/services/textResourceConfiguration.js');
const {} = require('../../../../platform/instantiation/common/instantiation.js');
var FilesConfigurationService_1;
const _moduleId = "vs/workbench/services/filesConfiguration/common/filesConfigurationService";
const AutoSaveAfterShortDelayContext = new RawContextKey('autoSaveAfterShortDelayContext', false, true);
let FilesConfigurationService = class FilesConfigurationService extends Disposable {
  static {
    FilesConfigurationService_1 = this;
  }
  static {
    this.DEFAULT_AUTO_SAVE_MODE = isWeb ? AutoSaveConfiguration.AFTER_DELAY : AutoSaveConfiguration.OFF;
  }
  static {
    this.DEFAULT_AUTO_SAVE_DELAY = 1000;
  }
  static {
    this.READONLY_MESSAGES = {
      providerReadonly: {
        value: localizeWithPath(_moduleId, 0, "Editor is read-only because the file system of the file is read-only."),
        isTrusted: true
      },
      sessionReadonly: {
        value: localizeWithPath(_moduleId, 1, "Editor is read-only because the file was set read-only in this session. [Click here](command:{0}) to set writeable.", 'workbench.action.files.setActiveEditorWriteableInSession'),
        isTrusted: true
      },
      configuredReadonly: {
        value: localizeWithPath(_moduleId, 2, "Editor is read-only because the file was set read-only via settings. [Click here](command:{0}) to configure.", `workbench.action.openSettings?${encodeURIComponent('["files.readonly"]')}`),
        isTrusted: true
      },
      fileLocked: {
        value: localizeWithPath(_moduleId, 3, "Editor is read-only because of file permissions. [Click here](command:{0}) to set writeable anyway.", 'workbench.action.files.setActiveEditorWriteableInSession'),
        isTrusted: true
      },
      fileReadonly: {
        value: localizeWithPath(_moduleId, 4, "Editor is read-only because the file is read-only."),
        isTrusted: true
      }
    };
  }
  constructor(contextKeyService, configurationService, contextService, environmentService, uriIdentityService, fileService, markerService, textResourceConfigurationService) {
    super();
    this.contextKeyService = contextKeyService;
    this.configurationService = configurationService;
    this.contextService = contextService;
    this.environmentService = environmentService;
    this.uriIdentityService = uriIdentityService;
    this.fileService = fileService;
    this.markerService = markerService;
    this.textResourceConfigurationService = textResourceConfigurationService;
    this._onDidChangeAutoSaveConfiguration = this._register(new Emitter());
    this.onDidChangeAutoSaveConfiguration = this._onDidChangeAutoSaveConfiguration.event;
    this._onDidChangeAutoSaveDisabled = this._register(new Emitter());
    this.onDidChangeAutoSaveDisabled = this._onDidChangeAutoSaveDisabled.event;
    this._onDidChangeFilesAssociation = this._register(new Emitter());
    this.onDidChangeFilesAssociation = this._onDidChangeFilesAssociation.event;
    this._onDidChangeReadonly = this._register(new Emitter());
    this.onDidChangeReadonly = this._onDidChangeReadonly.event;
    this.autoSaveConfigurationCache = new LRUCache(1000);
    this.autoSaveDisabledOverrides = new ResourceMap();
    this.autoSaveAfterShortDelayContext = AutoSaveAfterShortDelayContext.bindTo(this.contextKeyService);
    this.readonlyIncludeMatcher = this._register(new GlobalIdleValue(() => this.createReadonlyMatcher(FILES_READONLY_INCLUDE_CONFIG)));
    this.readonlyExcludeMatcher = this._register(new GlobalIdleValue(() => this.createReadonlyMatcher(FILES_READONLY_EXCLUDE_CONFIG)));
    this.sessionReadonlyOverrides = new ResourceMap(resource => this.uriIdentityService.extUri.getComparisonKey(resource));
    const configuration = configurationService.getValue();
    this.currentGlobalAutoSaveConfiguration = this.computeAutoSaveConfiguration(undefined, configuration.files);
    this.currentFilesAssociationConfiguration = configuration?.files?.associations;
    this.currentHotExitConfiguration = configuration?.files?.hotExit || HotExitConfiguration.ON_EXIT;
    this.onFilesConfigurationChange(configuration, false);
    this.registerListeners();
  }
  createReadonlyMatcher(config) {
    const matcher = this._register(new ResourceGlobMatcher(resource => this.configurationService.getValue(config, {
      resource
    }), event => event.affectsConfiguration(config), this.contextService, this.configurationService));
    this._register(matcher.onExpressionChange(() => this._onDidChangeReadonly.fire()));
    return matcher;
  }
  isReadonly(resource, stat) {
    const provider = this.fileService.getProvider(resource.scheme);
    if (provider && hasReadonlyCapability(provider)) {
      return provider.readOnlyMessage ?? FilesConfigurationService_1.READONLY_MESSAGES.providerReadonly;
    }
    const sessionReadonlyOverride = this.sessionReadonlyOverrides.get(resource);
    if (typeof sessionReadonlyOverride === 'boolean') {
      return sessionReadonlyOverride === true ? FilesConfigurationService_1.READONLY_MESSAGES.sessionReadonly : false;
    }
    if (this.uriIdentityService.extUri.isEqualOrParent(resource, this.environmentService.userRoamingDataHome) || this.uriIdentityService.extUri.isEqual(resource, this.contextService.getWorkspace().configuration ?? undefined)) {
      return false;
    }
    if (this.readonlyIncludeMatcher.value.matches(resource)) {
      return !this.readonlyExcludeMatcher.value.matches(resource) ? FilesConfigurationService_1.READONLY_MESSAGES.configuredReadonly : false;
    }
    if (this.configuredReadonlyFromPermissions && stat?.locked) {
      return FilesConfigurationService_1.READONLY_MESSAGES.fileLocked;
    }
    if (stat?.readonly) {
      return FilesConfigurationService_1.READONLY_MESSAGES.fileReadonly;
    }
    return false;
  }
  async updateReadonly(resource, readonly) {
    if (readonly === 'toggle') {
      let stat = undefined;
      try {
        stat = await this.fileService.resolve(resource, {
          resolveMetadata: true
        });
      } catch (error) {}
      readonly = !this.isReadonly(resource, stat);
    }
    if (readonly === 'reset') {
      this.sessionReadonlyOverrides.delete(resource);
    } else {
      this.sessionReadonlyOverrides.set(resource, readonly);
    }
    this._onDidChangeReadonly.fire();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration(e => {
      if (e.affectsConfiguration('files')) {
        this.onFilesConfigurationChange(this.configurationService.getValue(), true);
      }
    }));
  }
  onFilesConfigurationChange(configuration, fromEvent) {
    this.currentGlobalAutoSaveConfiguration = this.computeAutoSaveConfiguration(undefined, configuration.files);
    this.autoSaveConfigurationCache.clear();
    this.autoSaveAfterShortDelayContext.set(this.getAutoSaveMode(undefined).mode === 1);
    if (fromEvent) {
      this._onDidChangeAutoSaveConfiguration.fire();
    }
    const filesAssociation = configuration?.files?.associations;
    if (!equals(this.currentFilesAssociationConfiguration, filesAssociation)) {
      this.currentFilesAssociationConfiguration = filesAssociation;
      if (fromEvent) {
        this._onDidChangeFilesAssociation.fire();
      }
    }
    const hotExitMode = configuration?.files?.hotExit;
    if (hotExitMode === HotExitConfiguration.OFF || hotExitMode === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {
      this.currentHotExitConfiguration = hotExitMode;
    } else {
      this.currentHotExitConfiguration = HotExitConfiguration.ON_EXIT;
    }
    const readonlyFromPermissions = Boolean(configuration?.files?.readonlyFromPermissions);
    if (readonlyFromPermissions !== Boolean(this.configuredReadonlyFromPermissions)) {
      this.configuredReadonlyFromPermissions = readonlyFromPermissions;
      if (fromEvent) {
        this._onDidChangeReadonly.fire();
      }
    }
  }
  getAutoSaveConfiguration(resourceOrEditor) {
    const resource = this.toResource(resourceOrEditor);
    if (resource) {
      let resourceAutoSaveConfiguration = this.autoSaveConfigurationCache.get(resource);
      if (!resourceAutoSaveConfiguration) {
        resourceAutoSaveConfiguration = this.computeAutoSaveConfiguration(resource, this.textResourceConfigurationService.getValue(resource, 'files'));
        this.autoSaveConfigurationCache.set(resource, resourceAutoSaveConfiguration);
      }
      return resourceAutoSaveConfiguration;
    }
    return this.currentGlobalAutoSaveConfiguration;
  }
  computeAutoSaveConfiguration(resource, filesConfiguration) {
    let autoSave;
    let autoSaveDelay;
    let autoSaveWorkspaceFilesOnly;
    let autoSaveWhenNoErrors;
    let isOutOfWorkspace;
    let isShortAutoSaveDelay;
    switch (filesConfiguration.autoSave ?? FilesConfigurationService_1.DEFAULT_AUTO_SAVE_MODE) {
      case AutoSaveConfiguration.AFTER_DELAY:
        {
          autoSave = 'afterDelay';
          autoSaveDelay = typeof filesConfiguration.autoSaveDelay === 'number' && filesConfiguration.autoSaveDelay >= 0 ? filesConfiguration.autoSaveDelay : FilesConfigurationService_1.DEFAULT_AUTO_SAVE_DELAY;
          isShortAutoSaveDelay = autoSaveDelay <= FilesConfigurationService_1.DEFAULT_AUTO_SAVE_DELAY;
          break;
        }
      case AutoSaveConfiguration.ON_FOCUS_CHANGE:
        autoSave = 'onFocusChange';
        break;
      case AutoSaveConfiguration.ON_WINDOW_CHANGE:
        autoSave = 'onWindowChange';
        break;
    }
    if (filesConfiguration.autoSaveWorkspaceFilesOnly === true) {
      autoSaveWorkspaceFilesOnly = true;
      if (resource && !this.contextService.isInsideWorkspace(resource)) {
        isOutOfWorkspace = true;
        isShortAutoSaveDelay = undefined;
      }
    }
    if (filesConfiguration.autoSaveWhenNoErrors === true) {
      autoSaveWhenNoErrors = true;
      isShortAutoSaveDelay = undefined;
    }
    return {
      autoSave,
      autoSaveDelay,
      autoSaveWorkspaceFilesOnly,
      autoSaveWhenNoErrors,
      isOutOfWorkspace,
      isShortAutoSaveDelay
    };
  }
  toResource(resourceOrEditor) {
    if (resourceOrEditor instanceof EditorInput) {
      return EditorResourceAccessor.getOriginalUri(resourceOrEditor, {
        supportSideBySide: SideBySideEditor.PRIMARY
      });
    }
    return resourceOrEditor;
  }
  hasShortAutoSaveDelay(resourceOrEditor) {
    const resource = this.toResource(resourceOrEditor);
    if (this.getAutoSaveConfiguration(resource).isShortAutoSaveDelay) {
      return !resource || !this.autoSaveDisabledOverrides.has(resource);
    }
    return false;
  }
  getAutoSaveMode(resourceOrEditor, saveReason) {
    const resource = this.toResource(resourceOrEditor);
    if (resource && this.autoSaveDisabledOverrides.has(resource)) {
      return {
        mode: 0,
        reason: 4
      };
    }
    const autoSaveConfiguration = this.getAutoSaveConfiguration(resource);
    if (typeof autoSaveConfiguration.autoSave === 'undefined') {
      return {
        mode: 0,
        reason: 1
      };
    }
    if (typeof saveReason === 'number') {
      if (autoSaveConfiguration.autoSave === 'afterDelay' && saveReason !== 2 || autoSaveConfiguration.autoSave === 'onFocusChange' && saveReason !== 3 && saveReason !== 4 || autoSaveConfiguration.autoSave === 'onWindowChange' && saveReason !== 4) {
        return {
          mode: 0,
          reason: 1
        };
      }
    }
    if (resource) {
      if (autoSaveConfiguration.autoSaveWorkspaceFilesOnly && autoSaveConfiguration.isOutOfWorkspace) {
        return {
          mode: 0,
          reason: 2
        };
      }
      if (autoSaveConfiguration.autoSaveWhenNoErrors && this.markerService.read({
        resource,
        take: 1,
        severities: MarkerSeverity.Error
      }).length > 0) {
        return {
          mode: 0,
          reason: 3
        };
      }
    }
    switch (autoSaveConfiguration.autoSave) {
      case 'afterDelay':
        if (typeof autoSaveConfiguration.autoSaveDelay === 'number' && autoSaveConfiguration.autoSaveDelay <= FilesConfigurationService_1.DEFAULT_AUTO_SAVE_DELAY) {
          return {
            mode: autoSaveConfiguration.autoSaveWhenNoErrors ? 2 : 1
          };
        }
        return {
          mode: 2
        };
      case 'onFocusChange':
        return {
          mode: 3
        };
      case 'onWindowChange':
        return {
          mode: 4
        };
    }
  }
  async toggleAutoSave() {
    const currentSetting = this.configurationService.getValue('files.autoSave');
    let newAutoSaveValue;
    if ([AutoSaveConfiguration.AFTER_DELAY, AutoSaveConfiguration.ON_FOCUS_CHANGE, AutoSaveConfiguration.ON_WINDOW_CHANGE].some(setting => setting === currentSetting)) {
      newAutoSaveValue = AutoSaveConfiguration.OFF;
    } else {
      newAutoSaveValue = AutoSaveConfiguration.AFTER_DELAY;
    }
    return this.configurationService.updateValue('files.autoSave', newAutoSaveValue);
  }
  disableAutoSave(resourceOrEditor) {
    const resource = this.toResource(resourceOrEditor);
    if (!resource) {
      return Disposable.None;
    }
    const counter = this.autoSaveDisabledOverrides.get(resource) ?? 0;
    this.autoSaveDisabledOverrides.set(resource, counter + 1);
    if (counter === 0) {
      this._onDidChangeAutoSaveDisabled.fire(resource);
    }
    return toDisposable(() => {
      const counter = this.autoSaveDisabledOverrides.get(resource) ?? 0;
      if (counter <= 1) {
        this.autoSaveDisabledOverrides.delete(resource);
        this._onDidChangeAutoSaveDisabled.fire(resource);
      } else {
        this.autoSaveDisabledOverrides.set(resource, counter - 1);
      }
    });
  }
  get isHotExitEnabled() {
    if (this.contextService.getWorkspace().transient) {
      return false;
    }
    return this.currentHotExitConfiguration !== HotExitConfiguration.OFF;
  }
  get hotExitConfiguration() {
    return this.currentHotExitConfiguration;
  }
  preventSaveConflicts(resource, language) {
    return this.configurationService.getValue('files.saveConflictResolution', {
      resource,
      overrideIdentifier: language
    }) !== 'overwriteFileOnDisk';
  }
};
FilesConfigurationService = FilesConfigurationService_1 = __decorate([__param(0, IContextKeyService), __param(1, IConfigurationService), __param(2, IWorkspaceContextService), __param(3, IEnvironmentService), __param(4, IUriIdentityService), __param(5, IFileService), __param(6, IMarkerService), __param(7, ITextResourceConfigurationService)], FilesConfigurationService);
exports.AutoSaveAfterShortDelayContext = AutoSaveAfterShortDelayContext;
exports.FilesConfigurationService = FilesConfigurationService;