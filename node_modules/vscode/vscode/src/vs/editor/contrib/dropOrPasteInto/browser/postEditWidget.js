const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  $,
  addDisposableListener,
  getDomNodePagePosition,
  EventType
} = require('../../../../base/browser/dom.js');
const {
  Button
} = require('../../../../base/browser/ui/button/button.js');
const {
  toAction
} = require('../../../../base/common/actions.js');
const {
  Event
} = require('../../../../base/common/event.js');
const {
  Disposable,
  toDisposable,
  MutableDisposable
} = require('../../../../base/common/lifecycle.js');
const {} = require('./postEditWidget.css.js');
const {
  IBulkEditService
} = require('../../../browser/services/bulkEditService.js');
const {
  createCombinedWorkspaceEdit
} = require('./edit.js');
const {
  IContextKeyService
} = require('../../../../platform/contextkey/common/contextkey.service.js');
const {
  IContextMenuService
} = require('../../../../platform/contextview/browser/contextView.service.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {
  IKeybindingService
} = require('../../../../platform/keybinding/common/keybinding.service.js');
var PostEditWidget_1;
let PostEditWidget = class PostEditWidget extends Disposable {
  static {
    PostEditWidget_1 = this;
  }
  static {
    this.baseId = 'editor.widget.postEditWidget';
  }
  constructor(typeId, editor, visibleContext, showCommand, range, edits, onSelectNewEdit, _contextMenuService, contextKeyService, _keybindingService) {
    super();
    this.typeId = typeId;
    this.editor = editor;
    this.showCommand = showCommand;
    this.range = range;
    this.edits = edits;
    this.onSelectNewEdit = onSelectNewEdit;
    this._contextMenuService = _contextMenuService;
    this._keybindingService = _keybindingService;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = true;
    this.create();
    this.visibleContext = visibleContext.bindTo(contextKeyService);
    this.visibleContext.set(true);
    this._register(toDisposable(() => this.visibleContext.reset()));
    this.editor.addContentWidget(this);
    this.editor.layoutContentWidget(this);
    this._register(toDisposable(() => this.editor.removeContentWidget(this)));
    this._register(this.editor.onDidChangeCursorPosition(e => {
      if (!range.containsPosition(e.position)) {
        this.dispose();
      }
    }));
    this._register(Event.runAndSubscribe(_keybindingService.onDidUpdateKeybindings, () => {
      this._updateButtonTitle();
    }));
  }
  _updateButtonTitle() {
    const binding = this._keybindingService.lookupKeybinding(this.showCommand.id)?.getLabel();
    this.button.element.title = this.showCommand.label + (binding ? ` (${binding})` : '');
  }
  create() {
    this.domNode = $('.post-edit-widget');
    this.button = this._register(new Button(this.domNode, {
      supportIcons: true
    }));
    this.button.label = '$(insert)';
    this._register(addDisposableListener(this.domNode, EventType.CLICK, () => this.showSelector()));
  }
  getId() {
    return PostEditWidget_1.baseId + '.' + this.typeId;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: this.range.getEndPosition(),
      preference: [2]
    };
  }
  showSelector() {
    this._contextMenuService.showContextMenu({
      getAnchor: () => {
        const pos = getDomNodePagePosition(this.button.element);
        return {
          x: pos.left + pos.width,
          y: pos.top + pos.height
        };
      },
      getActions: () => {
        return this.edits.allEdits.map((edit, i) => toAction({
          id: '',
          label: edit.title,
          checked: i === this.edits.activeEditIndex,
          run: () => {
            if (i !== this.edits.activeEditIndex) {
              return this.onSelectNewEdit(i);
            }
          }
        }));
      }
    });
  }
};
PostEditWidget = PostEditWidget_1 = __decorate([__param(7, IContextMenuService), __param(8, IContextKeyService), __param(9, IKeybindingService)], PostEditWidget);
let PostEditWidgetManager = class PostEditWidgetManager extends Disposable {
  constructor(_id, _editor, _visibleContext, _showCommand, _instantiationService, _bulkEditService) {
    super();
    this._id = _id;
    this._editor = _editor;
    this._visibleContext = _visibleContext;
    this._showCommand = _showCommand;
    this._instantiationService = _instantiationService;
    this._bulkEditService = _bulkEditService;
    this._currentWidget = this._register(new MutableDisposable());
    this._register(Event.any(_editor.onDidChangeModel, _editor.onDidChangeModelContent)(() => this.clear()));
  }
  async applyEditAndShowIfNeeded(ranges, edits, canShowWidget, resolve, token) {
    const model = this._editor.getModel();
    if (!model || !ranges.length) {
      return;
    }
    const edit = edits.allEdits.at(edits.activeEditIndex);
    if (!edit) {
      return;
    }
    const resolvedEdit = await resolve(edit, token);
    if (token.isCancellationRequested) {
      return;
    }
    const combinedWorkspaceEdit = createCombinedWorkspaceEdit(model.uri, ranges, resolvedEdit);
    const primaryRange = ranges[0];
    const editTrackingDecoration = model.deltaDecorations([], [{
      range: primaryRange,
      options: {
        description: 'paste-line-suffix',
        stickiness: 0
      }
    }]);
    this._editor.focus();
    let editResult;
    let editRange;
    try {
      editResult = await this._bulkEditService.apply(combinedWorkspaceEdit, {
        editor: this._editor,
        token
      });
      editRange = model.getDecorationRange(editTrackingDecoration[0]);
    } finally {
      model.deltaDecorations(editTrackingDecoration, []);
    }
    if (token.isCancellationRequested) {
      return;
    }
    if (canShowWidget && editResult.isApplied && edits.allEdits.length > 1) {
      this.show(editRange ?? primaryRange, edits, async newEditIndex => {
        const model = this._editor.getModel();
        if (!model) {
          return;
        }
        await model.undo();
        this.applyEditAndShowIfNeeded(ranges, {
          activeEditIndex: newEditIndex,
          allEdits: edits.allEdits
        }, canShowWidget, resolve, token);
      });
    }
  }
  show(range, edits, onDidSelectEdit) {
    this.clear();
    if (this._editor.hasModel()) {
      this._currentWidget.value = this._instantiationService.createInstance(PostEditWidget, this._id, this._editor, this._visibleContext, this._showCommand, range, edits, onDidSelectEdit);
    }
  }
  clear() {
    this._currentWidget.clear();
  }
  tryShowSelector() {
    this._currentWidget.value?.showSelector();
  }
};
PostEditWidgetManager = __decorate([__param(4, IInstantiationService), __param(5, IBulkEditService)], PostEditWidgetManager);
exports.PostEditWidgetManager = PostEditWidgetManager;