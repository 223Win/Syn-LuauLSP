const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  AsyncIterableObject
} = require('../../../../base/common/async.js');
const {
  MarkdownString,
  isEmptyMarkdownString
} = require('../../../../base/common/htmlContent.js');
const {
  Position
} = require('../../../common/core/position.js');
const {
  ModelDecorationInjectedTextOptions
} = require('../../../common/model/textModel.js');
const {
  HoverForeignElementAnchor
} = require('../../hover/browser/hoverTypes.js');
const {
  ILanguageService
} = require('../../../common/languages/language.js');
const {
  ITextModelService
} = require('../../../common/services/resolverService.js');
const {
  getHoverProviderResultsAsAsyncIterable
} = require('../../hover/browser/getHover.js');
const {
  MarkdownHoverParticipant,
  MarkdownHover
} = require('../../hover/browser/markdownHoverParticipant.js');
const {
  InlayHintsController,
  RenderedInlayHintLabelPart
} = require('./inlayHintsController.js');
const {
  IConfigurationService
} = require('../../../../platform/configuration/common/configuration.service.js');
const {
  IOpenerService
} = require('../../../../platform/opener/common/opener.service.js');
const {
  ILanguageFeaturesService
} = require('../../../common/services/languageFeatures.js');
const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  isMacintosh
} = require('../../../../base/common/platform.js');
const {
  asCommandLink
} = require('./inlayHints.js');
const {
  isNonEmptyArray
} = require('../../../../base/common/arrays.js');
const {
  IKeybindingService
} = require('../../../../platform/keybinding/common/keybinding.service.js');
const {
  IHoverService
} = require('../../../../platform/hover/browser/hover.service.js');
const _moduleId = "vs/editor/contrib/inlayHints/browser/inlayHintsHover";
class InlayHintsHoverAnchor extends HoverForeignElementAnchor {
  constructor(part, owner, initialMousePosX, initialMousePosY) {
    super(10, owner, part.item.anchor.range, initialMousePosX, initialMousePosY, true);
    this.part = part;
  }
}
let InlayHintsHover = class InlayHintsHover extends MarkdownHoverParticipant {
  constructor(editor, languageService, openerService, keybindingService, hoverService, configurationService, _resolverService, languageFeaturesService) {
    super(editor, languageService, openerService, configurationService, languageFeaturesService, keybindingService, hoverService);
    this._resolverService = _resolverService;
    this.hoverOrdinal = 6;
  }
  suggestHoverAnchor(mouseEvent) {
    const controller = InlayHintsController.get(this._editor);
    if (!controller) {
      return null;
    }
    if (mouseEvent.target.type !== 6) {
      return null;
    }
    const options = mouseEvent.target.detail.injectedText?.options;
    if (!(options instanceof ModelDecorationInjectedTextOptions && options.attachedData instanceof RenderedInlayHintLabelPart)) {
      return null;
    }
    return new InlayHintsHoverAnchor(options.attachedData, this, mouseEvent.event.posx, mouseEvent.event.posy);
  }
  computeSync() {
    return [];
  }
  computeAsync(anchor, _lineDecorations, token) {
    if (!(anchor instanceof InlayHintsHoverAnchor)) {
      return AsyncIterableObject.EMPTY;
    }
    return new AsyncIterableObject(async executor => {
      const {
        part
      } = anchor;
      await part.item.resolve(token);
      if (token.isCancellationRequested) {
        return;
      }
      let itemTooltip;
      if (typeof part.item.hint.tooltip === 'string') {
        itemTooltip = new MarkdownString().appendText(part.item.hint.tooltip);
      } else if (part.item.hint.tooltip) {
        itemTooltip = part.item.hint.tooltip;
      }
      if (itemTooltip) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [itemTooltip], false, 0));
      }
      if (isNonEmptyArray(part.item.hint.textEdits)) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localizeWithPath(_moduleId, 0, "Double-click to insert"))], false, 10001));
      }
      let partTooltip;
      if (typeof part.part.tooltip === 'string') {
        partTooltip = new MarkdownString().appendText(part.part.tooltip);
      } else if (part.part.tooltip) {
        partTooltip = part.part.tooltip;
      }
      if (partTooltip) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [partTooltip], false, 1));
      }
      if (part.part.location || part.part.command) {
        let linkHint;
        const useMetaKey = this._editor.getOption(78) === 'altKey';
        const kb = useMetaKey ? isMacintosh ? localizeWithPath(_moduleId, 1, "cmd + click") : localizeWithPath(_moduleId, 2, "ctrl + click") : isMacintosh ? localizeWithPath(_moduleId, 3, "option + click") : localizeWithPath(_moduleId, 4, "alt + click");
        if (part.part.location && part.part.command) {
          linkHint = new MarkdownString().appendText(localizeWithPath(_moduleId, 5, 'Go to Definition ({0}), right click for more', kb));
        } else if (part.part.location) {
          linkHint = new MarkdownString().appendText(localizeWithPath(_moduleId, 6, 'Go to Definition ({0})', kb));
        } else if (part.part.command) {
          linkHint = new MarkdownString(`[${localizeWithPath(_moduleId, 7, "Execute Command")}](${asCommandLink(part.part.command)} "${part.part.command.title}") (${kb})`, {
            isTrusted: true
          });
        }
        if (linkHint) {
          executor.emitOne(new MarkdownHover(this, anchor.range, [linkHint], false, 10000));
        }
      }
      const iterable = await this._resolveInlayHintLabelPartHover(part, token);
      for await (const item of iterable) {
        executor.emitOne(item);
      }
    });
  }
  async _resolveInlayHintLabelPartHover(part, token) {
    if (!part.part.location) {
      return AsyncIterableObject.EMPTY;
    }
    const {
      uri,
      range
    } = part.part.location;
    const ref = await this._resolverService.createModelReference(uri);
    try {
      const model = ref.object.textEditorModel;
      if (!this._languageFeaturesService.hoverProvider.has(model)) {
        return AsyncIterableObject.EMPTY;
      }
      return getHoverProviderResultsAsAsyncIterable(this._languageFeaturesService.hoverProvider, model, new Position(range.startLineNumber, range.startColumn), token).filter(item => !isEmptyMarkdownString(item.hover.contents)).map(item => new MarkdownHover(this, part.item.anchor.range, item.hover.contents, false, 2 + item.ordinal));
    } finally {
      ref.dispose();
    }
  }
};
InlayHintsHover = __decorate([__param(1, ILanguageService), __param(2, IOpenerService), __param(3, IKeybindingService), __param(4, IHoverService), __param(5, IConfigurationService), __param(6, ITextModelService), __param(7, ILanguageFeaturesService)], InlayHintsHover);
exports.InlayHintsHover = InlayHintsHover;