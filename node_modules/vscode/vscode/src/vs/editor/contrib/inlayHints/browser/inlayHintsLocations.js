const {
  getDomNodePagePosition
} = require('../../../../base/browser/dom.js');
const {
  Action,
  Separator
} = require('../../../../base/common/actions.js');
const {
  CancellationToken
} = require('../../../../base/common/cancellation.js');
const {
  generateUuid
} = require('../../../../base/common/uuid.js');
const {
  Range
} = require('../../../common/core/range.js');
const {
  ITextModelService
} = require('../../../common/services/resolverService.js');
const {
  SymbolNavigationAction,
  SymbolNavigationAnchor,
  DefinitionAction
} = require('../../gotoSymbol/browser/goToCommands.js');
const {
  PeekContext
} = require('../../peekView/browser/peekView.js');
const {
  MenuItemAction,
  MenuRegistry,
  MenuId,
  isIMenuItem
} = require('../../../../platform/actions/common/actions.js');
const {
  ICommandService
} = require('../../../../platform/commands/common/commands.service.js');
const {
  IContextKeyService
} = require('../../../../platform/contextkey/common/contextkey.service.js');
const {
  IContextMenuService
} = require('../../../../platform/contextview/browser/contextView.service.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {} = require('../../../../platform/notification/common/notification.js');
const {
  INotificationService
} = require('../../../../platform/notification/common/notification.service.js');
const Severity$1 = require('../../../../base/common/severity.js');
async function showGoToContextMenu(accessor, editor, anchor, part) {
  const resolverService = accessor.get(ITextModelService);
  const contextMenuService = accessor.get(IContextMenuService);
  const commandService = accessor.get(ICommandService);
  const instaService = accessor.get(IInstantiationService);
  const notificationService = accessor.get(INotificationService);
  await part.item.resolve(CancellationToken.None);
  if (!part.part.location) {
    return;
  }
  const location = part.part.location;
  const menuActions = [];
  const filter = new Set(MenuRegistry.getMenuItems(MenuId.EditorContext).map(item => isIMenuItem(item) ? item.command.id : generateUuid()));
  for (const delegate of SymbolNavigationAction.all()) {
    if (filter.has(delegate.desc.id)) {
      menuActions.push(new Action(delegate.desc.id, MenuItemAction.label(delegate.desc, {
        renderShortTitle: true
      }), undefined, true, async () => {
        const ref = await resolverService.createModelReference(location.uri);
        try {
          const symbolAnchor = new SymbolNavigationAnchor(ref.object.textEditorModel, Range.getStartPosition(location.range));
          const range = part.item.anchor.range;
          await instaService.invokeFunction(delegate.runEditorCommand.bind(delegate), editor, symbolAnchor, range);
        } finally {
          ref.dispose();
        }
      }));
    }
  }
  if (part.part.command) {
    const {
      command
    } = part.part;
    menuActions.push(new Separator());
    menuActions.push(new Action(command.id, command.title, undefined, true, async () => {
      try {
        await commandService.executeCommand(command.id, ...(command.arguments ?? []));
      } catch (err) {
        notificationService.notify({
          severity: Severity$1.Error,
          source: part.item.provider.displayName,
          message: err
        });
      }
    }));
  }
  const useShadowDOM = editor.getOption(127);
  contextMenuService.showContextMenu({
    domForShadowRoot: useShadowDOM ? editor.getDomNode() ?? undefined : undefined,
    getAnchor: () => {
      const box = getDomNodePagePosition(anchor);
      return {
        x: box.left,
        y: box.top + box.height + 8
      };
    },
    getActions: () => menuActions,
    onHide: () => {
      editor.focus();
    },
    autoSelectFirstItem: true
  });
}
async function goToDefinitionWithLocation(accessor, event, editor, location) {
  const resolverService = accessor.get(ITextModelService);
  const ref = await resolverService.createModelReference(location.uri);
  await editor.invokeWithinContext(async accessor => {
    const openToSide = event.hasSideBySideModifier;
    const contextKeyService = accessor.get(IContextKeyService);
    const isInPeek = PeekContext.inPeekEditor.getValue(contextKeyService);
    const canPeek = !openToSide && editor.getOption(88) && !isInPeek;
    const action = new DefinitionAction({
      openToSide,
      openInPeek: canPeek,
      muteMessage: true
    }, {
      title: {
        value: '',
        original: ''
      },
      id: '',
      precondition: undefined
    });
    return action.run(accessor, new SymbolNavigationAnchor(ref.object.textEditorModel, Range.getStartPosition(location.range)), Range.lift(location.range));
  });
  ref.dispose();
}
exports.goToDefinitionWithLocation = goToDefinitionWithLocation;
exports.showGoToContextMenu = showGoToContextMenu;