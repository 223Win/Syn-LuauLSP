const {
  CancellationToken
} = require('../../../../base/common/cancellation.js');
const {
  illegalArgument,
  onUnexpectedExternalError
} = require('../../../../base/common/errors.js');
const {
  URI
} = require('../../../../base/common/uri.js');
const {
  Range
} = require('../../../common/core/range.js');
const {
  IModelService
} = require('../../../common/services/model.js');
const {
  CommandsRegistry
} = require('../../../../platform/commands/common/commands.js');
const {
  ILanguageFeaturesService
} = require('../../../common/services/languageFeatures.js');
const {
  DefaultDocumentColorProvider
} = require('./defaultDocumentColorProvider.js');
const {
  IConfigurationService
} = require('../../../../platform/configuration/common/configuration.service.js');
async function getColors(colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled = true) {
  return _findColorData(new ColorDataCollector(), colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled);
}
function getColorPresentations(model, colorInfo, provider, token) {
  return Promise.resolve(provider.provideColorPresentations(model, colorInfo, token));
}
class ColorDataCollector {
  constructor() {}
  async compute(provider, model, token, colors) {
    const documentColors = await provider.provideDocumentColors(model, token);
    if (Array.isArray(documentColors)) {
      for (const colorInfo of documentColors) {
        colors.push({
          colorInfo,
          provider
        });
      }
    }
    return Array.isArray(documentColors);
  }
}
class ExtColorDataCollector {
  constructor() {}
  async compute(provider, model, token, colors) {
    const documentColors = await provider.provideDocumentColors(model, token);
    if (Array.isArray(documentColors)) {
      for (const colorInfo of documentColors) {
        colors.push({
          range: colorInfo.range,
          color: [colorInfo.color.red, colorInfo.color.green, colorInfo.color.blue, colorInfo.color.alpha]
        });
      }
    }
    return Array.isArray(documentColors);
  }
}
class ColorPresentationsCollector {
  constructor(colorInfo) {
    this.colorInfo = colorInfo;
  }
  async compute(provider, model, _token, colors) {
    const documentColors = await provider.provideColorPresentations(model, this.colorInfo, CancellationToken.None);
    if (Array.isArray(documentColors)) {
      colors.push(...documentColors);
    }
    return Array.isArray(documentColors);
  }
}
async function _findColorData(collector, colorProviderRegistry, model, token, isDefaultColorDecoratorsEnabled) {
  let validDocumentColorProviderFound = false;
  let defaultProvider;
  const colorData = [];
  const documentColorProviders = colorProviderRegistry.ordered(model);
  for (let i = documentColorProviders.length - 1; i >= 0; i--) {
    const provider = documentColorProviders[i];
    if (provider instanceof DefaultDocumentColorProvider) {
      defaultProvider = provider;
    } else {
      try {
        if (await collector.compute(provider, model, token, colorData)) {
          validDocumentColorProviderFound = true;
        }
      } catch (e) {
        onUnexpectedExternalError(e);
      }
    }
  }
  if (validDocumentColorProviderFound) {
    return colorData;
  }
  if (defaultProvider && isDefaultColorDecoratorsEnabled) {
    await collector.compute(defaultProvider, model, token, colorData);
    return colorData;
  }
  return [];
}
function _setupColorCommand(accessor, resource) {
  const {
    colorProvider: colorProviderRegistry
  } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument();
  }
  const isDefaultColorDecoratorsEnabled = accessor.get(IConfigurationService).getValue('editor.defaultColorDecorators', {
    resource
  });
  return {
    model,
    colorProviderRegistry,
    isDefaultColorDecoratorsEnabled
  };
}
CommandsRegistry.registerCommand('_executeDocumentColorProvider', function (accessor, ...args) {
  const [resource] = args;
  if (!(resource instanceof URI)) {
    throw illegalArgument();
  }
  const {
    model,
    colorProviderRegistry,
    isDefaultColorDecoratorsEnabled
  } = _setupColorCommand(accessor, resource);
  return _findColorData(new ExtColorDataCollector(), colorProviderRegistry, model, CancellationToken.None, isDefaultColorDecoratorsEnabled);
});
CommandsRegistry.registerCommand('_executeColorPresentationProvider', function (accessor, ...args) {
  const [color, context] = args;
  const {
    uri,
    range
  } = context;
  if (!(uri instanceof URI) || !Array.isArray(color) || color.length !== 4 || !Range.isIRange(range)) {
    throw illegalArgument();
  }
  const {
    model,
    colorProviderRegistry,
    isDefaultColorDecoratorsEnabled
  } = _setupColorCommand(accessor, uri);
  const [red, green, blue, alpha] = color;
  return _findColorData(new ColorPresentationsCollector({
    range: range,
    color: {
      red,
      green,
      blue,
      alpha
    }
  }), colorProviderRegistry, model, CancellationToken.None, isDefaultColorDecoratorsEnabled);
});
exports.getColorPresentations = getColorPresentations;
exports.getColors = getColors;