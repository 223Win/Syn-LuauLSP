const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  DisposableStore
} = require('../../../../base/common/lifecycle.js');
const {} = require('../../../../base/common/arrays.js');
const {} = require('../../../../base/common/observableInternal/derived.js');
const {} = require('../../../../base/common/observableInternal/autorun.js');
const {
  constObservable
} = require('../../../../base/common/observableInternal/utils.js');
const {} = require('../../../../base/common/cancellation.js');
const {
  HoverForeignElementAnchor
} = require('../../hover/browser/hoverTypes.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {
  ITelemetryService
} = require('../../../../platform/telemetry/common/telemetry.service.js');
const {
  InlineEditController
} = require('./inlineEditController.js');
const {
  InlineEditHintsContentWidget
} = require('./inlineEditHintsWidget.js');
class InlineEditHover {
  constructor(owner, range, controller) {
    this.owner = owner;
    this.range = range;
    this.controller = controller;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
}
let InlineEditHoverParticipant = class InlineEditHoverParticipant {
  constructor(_editor, _instantiationService, _telemetryService) {
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._telemetryService = _telemetryService;
    this.hoverOrdinal = 5;
  }
  suggestHoverAnchor(mouseEvent) {
    const controller = InlineEditController.get(this._editor);
    if (!controller) {
      return null;
    }
    const target = mouseEvent.target;
    if (target.type === 8) {
      const viewZoneData = target.detail;
      if (controller.shouldShowHoverAtViewZone(viewZoneData.viewZoneId)) {
        const range = target.range;
        return new HoverForeignElementAnchor(1000, this, range, mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    if (target.type === 7) {
      if (controller.shouldShowHoverAt(target.range)) {
        return new HoverForeignElementAnchor(1000, this, target.range, mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    if (target.type === 6) {
      const mightBeForeignElement = target.detail.mightBeForeignElement;
      if (mightBeForeignElement && controller.shouldShowHoverAt(target.range)) {
        return new HoverForeignElementAnchor(1000, this, target.range, mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    return null;
  }
  computeSync(anchor, lineDecorations) {
    if (this._editor.getOption(63).showToolbar !== 'onHover') {
      return [];
    }
    const controller = InlineEditController.get(this._editor);
    if (controller && controller.shouldShowHoverAt(anchor.range)) {
      return [new InlineEditHover(this, anchor.range, controller)];
    }
    return [];
  }
  renderHoverParts(context, hoverParts) {
    const disposableStore = new DisposableStore();
    this._telemetryService.publicLog2('inlineEditHover.shown');
    const w = this._instantiationService.createInstance(InlineEditHintsContentWidget, this._editor, false, constObservable(null));
    context.fragment.appendChild(w.getDomNode());
    disposableStore.add(w);
    return disposableStore;
  }
};
InlineEditHoverParticipant = __decorate([__param(1, IInstantiationService), __param(2, ITelemetryService)], InlineEditHoverParticipant);
exports.InlineEditHover = InlineEditHover;
exports.InlineEditHoverParticipant = InlineEditHoverParticipant;