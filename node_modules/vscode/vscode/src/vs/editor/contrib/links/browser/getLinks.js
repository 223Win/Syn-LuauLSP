const {
  coalesce
} = require('../../../../base/common/arrays.js');
const {
  CancellationToken
} = require('../../../../base/common/cancellation.js');
const {
  onUnexpectedExternalError
} = require('../../../../base/common/errors.js');
const {
  DisposableStore,
  isDisposable
} = require('../../../../base/common/lifecycle.js');
const {
  assertType
} = require('../../../../base/common/types.js');
const {
  URI
} = require('../../../../base/common/uri.js');
const {
  Range
} = require('../../../common/core/range.js');
const {
  IModelService
} = require('../../../common/services/model.js');
const {
  CommandsRegistry
} = require('../../../../platform/commands/common/commands.js');
const {
  ILanguageFeaturesService
} = require('../../../common/services/languageFeatures.js');
class Link {
  constructor(link, provider) {
    this._link = link;
    this._provider = provider;
  }
  toJSON() {
    return {
      range: this.range,
      url: this.url,
      tooltip: this.tooltip
    };
  }
  get range() {
    return this._link.range;
  }
  get url() {
    return this._link.url;
  }
  get tooltip() {
    return this._link.tooltip;
  }
  async resolve(token) {
    if (this._link.url) {
      return this._link.url;
    }
    if (typeof this._provider.resolveLink === 'function') {
      return Promise.resolve(this._provider.resolveLink(this._link, token)).then(value => {
        this._link = value || this._link;
        if (this._link.url) {
          return this.resolve(token);
        }
        return Promise.reject(new Error('missing'));
      });
    }
    return Promise.reject(new Error('missing'));
  }
}
class LinksList {
  constructor(tuples) {
    this._disposables = new DisposableStore();
    let links = [];
    for (const [list, provider] of tuples) {
      const newLinks = list.links.map(link => new Link(link, provider));
      links = LinksList._union(links, newLinks);
      if (isDisposable(list)) {
        this._disposables.add(list);
      }
    }
    this.links = links;
  }
  dispose() {
    this._disposables.dispose();
    this.links.length = 0;
  }
  static _union(oldLinks, newLinks) {
    const result = [];
    let oldIndex;
    let oldLen;
    let newIndex;
    let newLen;
    for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen;) {
      const oldLink = oldLinks[oldIndex];
      const newLink = newLinks[newIndex];
      if (Range.areIntersectingOrTouching(oldLink.range, newLink.range)) {
        oldIndex++;
        continue;
      }
      const comparisonResult = Range.compareRangesUsingStarts(oldLink.range, newLink.range);
      if (comparisonResult < 0) {
        result.push(oldLink);
        oldIndex++;
      } else {
        result.push(newLink);
        newIndex++;
      }
    }
    for (; oldIndex < oldLen; oldIndex++) {
      result.push(oldLinks[oldIndex]);
    }
    for (; newIndex < newLen; newIndex++) {
      result.push(newLinks[newIndex]);
    }
    return result;
  }
}
function getLinks(providers, model, token) {
  const lists = [];
  const promises = providers.ordered(model).reverse().map((provider, i) => {
    return Promise.resolve(provider.provideLinks(model, token)).then(result => {
      if (result) {
        lists[i] = [result, provider];
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then(() => {
    const result = new LinksList(coalesce(lists));
    if (!token.isCancellationRequested) {
      return result;
    }
    result.dispose();
    return new LinksList([]);
  });
}
CommandsRegistry.registerCommand('_executeLinkProvider', async (accessor, ...args) => {
  let [uri, resolveCount] = args;
  assertType(uri instanceof URI);
  if (typeof resolveCount !== 'number') {
    resolveCount = 0;
  }
  const {
    linkProvider
  } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return [];
  }
  const list = await getLinks(linkProvider, model, CancellationToken.None);
  if (!list) {
    return [];
  }
  for (let i = 0; i < Math.min(resolveCount, list.links.length); i++) {
    await list.links[i].resolve(CancellationToken.None);
  }
  const result = list.links.slice(0);
  list.dispose();
  return result;
});
exports.Link = Link;
exports.LinksList = LinksList;
exports.getLinks = getLinks;