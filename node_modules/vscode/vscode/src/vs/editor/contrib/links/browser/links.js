const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  RunOnceScheduler,
  createCancelablePromise
} = require('../../../../base/common/async.js');
const {
  CancellationToken
} = require('../../../../base/common/cancellation.js');
const {
  onUnexpectedError
} = require('../../../../base/common/errors.js');
const {
  MarkdownString
} = require('../../../../base/common/htmlContent.js');
const {
  Disposable
} = require('../../../../base/common/lifecycle.js');
const {
  Schemas
} = require('../../../../base/common/network.js');
const {
  isMacintosh
} = require('../../../../base/common/platform.js');
const {
  originalFSPath,
  joinPath
} = require('../../../../base/common/resources.js');
const {
  StopWatch
} = require('../../../../base/common/stopwatch.js');
const {
  URI
} = require('../../../../base/common/uri.js');
const {} = require('./links.css.js');
const {
  registerEditorContribution,
  registerEditorAction,
  EditorAction
} = require('../../../browser/editorExtensions.js');
const {
  ModelDecorationOptions
} = require('../../../common/model/textModel.js');
const {
  ILanguageFeatureDebounceService
} = require('../../../common/services/languageFeatureDebounce.js');
const {
  ILanguageFeaturesService
} = require('../../../common/services/languageFeatures.js');
const {
  ClickLinkGesture
} = require('../../gotoSymbol/browser/link/clickLinkGesture.js');
const {
  getLinks
} = require('./getLinks.js');
const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  INotificationService
} = require('../../../../platform/notification/common/notification.service.js');
const {
  IOpenerService
} = require('../../../../platform/opener/common/opener.service.js');
var LinkDetector_1;
const _moduleId = "vs/editor/contrib/links/browser/links";
let LinkDetector = class LinkDetector extends Disposable {
  static {
    LinkDetector_1 = this;
  }
  static {
    this.ID = 'editor.linkDetector';
  }
  static get(editor) {
    return editor.getContribution(LinkDetector_1.ID);
  }
  constructor(editor, openerService, notificationService, languageFeaturesService, languageFeatureDebounceService) {
    super();
    this.editor = editor;
    this.openerService = openerService;
    this.notificationService = notificationService;
    this.languageFeaturesService = languageFeaturesService;
    this.providers = this.languageFeaturesService.linkProvider;
    this.debounceInformation = languageFeatureDebounceService.for(this.providers, 'Links', {
      min: 1000,
      max: 4000
    });
    this.computeLinks = this._register(new RunOnceScheduler(() => this.computeLinksNow(), 1000));
    this.computePromise = null;
    this.activeLinksList = null;
    this.currentOccurrences = {};
    this.activeLinkDecorationId = null;
    const clickLinkGesture = this._register(new ClickLinkGesture(editor));
    this._register(clickLinkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this._onEditorMouseMove(mouseEvent, keyboardEvent);
    }));
    this._register(clickLinkGesture.onExecute(e => {
      this.onEditorMouseUp(e);
    }));
    this._register(clickLinkGesture.onCancel(e => {
      this.cleanUpActiveLinkDecoration();
    }));
    this._register(editor.onDidChangeConfiguration(e => {
      if (!e.hasChanged(71)) {
        return;
      }
      this.updateDecorations([]);
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(editor.onDidChangeModelContent(e => {
      if (!this.editor.hasModel()) {
        return;
      }
      this.computeLinks.schedule(this.debounceInformation.get(this.editor.getModel()));
    }));
    this._register(editor.onDidChangeModel(e => {
      this.currentOccurrences = {};
      this.activeLinkDecorationId = null;
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(editor.onDidChangeModelLanguage(e => {
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(this.providers.onDidChange(e => {
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this.computeLinks.schedule(0);
  }
  async computeLinksNow() {
    if (!this.editor.hasModel() || !this.editor.getOption(71)) {
      return;
    }
    const model = this.editor.getModel();
    if (model.isTooLargeForSyncing()) {
      return;
    }
    if (!this.providers.has(model)) {
      return;
    }
    if (this.activeLinksList) {
      this.activeLinksList.dispose();
      this.activeLinksList = null;
    }
    this.computePromise = createCancelablePromise(token => getLinks(this.providers, model, token));
    try {
      const sw = new StopWatch(false);
      this.activeLinksList = await this.computePromise;
      this.debounceInformation.update(model, sw.elapsed());
      if (model.isDisposed()) {
        return;
      }
      this.updateDecorations(this.activeLinksList.links);
    } catch (err) {
      onUnexpectedError(err);
    } finally {
      this.computePromise = null;
    }
  }
  updateDecorations(links) {
    const useMetaKey = this.editor.getOption(78) === 'altKey';
    const oldDecorations = [];
    const keys = Object.keys(this.currentOccurrences);
    for (const decorationId of keys) {
      const occurence = this.currentOccurrences[decorationId];
      oldDecorations.push(occurence.decorationId);
    }
    const newDecorations = [];
    if (links) {
      for (const link of links) {
        newDecorations.push(LinkOccurrence.decoration(link, useMetaKey));
      }
    }
    this.editor.changeDecorations(changeAccessor => {
      const decorations = changeAccessor.deltaDecorations(oldDecorations, newDecorations);
      this.currentOccurrences = {};
      this.activeLinkDecorationId = null;
      for (let i = 0, len = decorations.length; i < len; i++) {
        const occurence = new LinkOccurrence(links[i], decorations[i]);
        this.currentOccurrences[occurence.decorationId] = occurence;
      }
    });
  }
  _onEditorMouseMove(mouseEvent, withKey) {
    const useMetaKey = this.editor.getOption(78) === 'altKey';
    if (this.isEnabled(mouseEvent, withKey)) {
      this.cleanUpActiveLinkDecoration();
      const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
      if (occurrence) {
        this.editor.changeDecorations(changeAccessor => {
          occurrence.activate(changeAccessor, useMetaKey);
          this.activeLinkDecorationId = occurrence.decorationId;
        });
      }
    } else {
      this.cleanUpActiveLinkDecoration();
    }
  }
  cleanUpActiveLinkDecoration() {
    const useMetaKey = this.editor.getOption(78) === 'altKey';
    if (this.activeLinkDecorationId) {
      const occurrence = this.currentOccurrences[this.activeLinkDecorationId];
      if (occurrence) {
        this.editor.changeDecorations(changeAccessor => {
          occurrence.deactivate(changeAccessor, useMetaKey);
        });
      }
      this.activeLinkDecorationId = null;
    }
  }
  onEditorMouseUp(mouseEvent) {
    if (!this.isEnabled(mouseEvent)) {
      return;
    }
    const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
    if (!occurrence) {
      return;
    }
    this.openLinkOccurrence(occurrence, mouseEvent.hasSideBySideModifier, true);
  }
  openLinkOccurrence(occurrence, openToSide, fromUserGesture = false) {
    if (!this.openerService) {
      return;
    }
    const {
      link
    } = occurrence;
    link.resolve(CancellationToken.None).then(uri => {
      if (typeof uri === 'string' && this.editor.hasModel()) {
        const modelUri = this.editor.getModel().uri;
        if (modelUri.scheme === Schemas.file && uri.startsWith(`${Schemas.file}:`)) {
          const parsedUri = URI.parse(uri);
          if (parsedUri.scheme === Schemas.file) {
            const fsPath = originalFSPath(parsedUri);
            let relativePath = null;
            if (fsPath.startsWith('/./') || fsPath.startsWith('\\.\\')) {
              relativePath = `.${fsPath.substr(1)}`;
            } else if (fsPath.startsWith('//./') || fsPath.startsWith('\\\\.\\')) {
              relativePath = `.${fsPath.substr(2)}`;
            }
            if (relativePath) {
              uri = joinPath(modelUri, relativePath);
            }
          }
        }
      }
      return this.openerService.open(uri, {
        openToSide,
        fromUserGesture,
        allowContributedOpeners: true,
        allowCommands: true,
        fromWorkspace: true
      });
    }, err => {
      const messageOrError = err instanceof Error ? err.message : err;
      if (messageOrError === 'invalid') {
        this.notificationService.warn(localizeWithPath(_moduleId, 0, 'Failed to open this link because it is not well-formed: {0}', link.url.toString()));
      } else if (messageOrError === 'missing') {
        this.notificationService.warn(localizeWithPath(_moduleId, 1, 'Failed to open this link because its target is missing.'));
      } else {
        onUnexpectedError(err);
      }
    });
  }
  getLinkOccurrence(position) {
    if (!this.editor.hasModel() || !position) {
      return null;
    }
    const decorations = this.editor.getModel().getDecorationsInRange({
      startLineNumber: position.lineNumber,
      startColumn: position.column,
      endLineNumber: position.lineNumber,
      endColumn: position.column
    }, 0, true);
    for (const decoration of decorations) {
      const currentOccurrence = this.currentOccurrences[decoration.id];
      if (currentOccurrence) {
        return currentOccurrence;
      }
    }
    return null;
  }
  isEnabled(mouseEvent, withKey) {
    return Boolean(mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || withKey && withKey.keyCodeIsTriggerKey));
  }
  stop() {
    this.computeLinks.cancel();
    if (this.activeLinksList) {
      this.activeLinksList?.dispose();
      this.activeLinksList = null;
    }
    if (this.computePromise) {
      this.computePromise.cancel();
      this.computePromise = null;
    }
  }
  dispose() {
    super.dispose();
    this.stop();
  }
};
LinkDetector = LinkDetector_1 = __decorate([__param(1, IOpenerService), __param(2, INotificationService), __param(3, ILanguageFeaturesService), __param(4, ILanguageFeatureDebounceService)], LinkDetector);
const decoration = {
  general: ModelDecorationOptions.register({
    description: 'detected-link',
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: 'detected-link'
  }),
  active: ModelDecorationOptions.register({
    description: 'detected-link-active',
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: 'detected-link-active'
  })
};
class LinkOccurrence {
  static decoration(link, useMetaKey) {
    return {
      range: link.range,
      options: LinkOccurrence._getOptions(link, useMetaKey, false)
    };
  }
  static _getOptions(link, useMetaKey, isActive) {
    const options = {
      ...(isActive ? decoration.active : decoration.general)
    };
    options.hoverMessage = getHoverMessage(link, useMetaKey);
    return options;
  }
  constructor(link, decorationId) {
    this.link = link;
    this.decorationId = decorationId;
  }
  activate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, true));
  }
  deactivate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, false));
  }
}
function getHoverMessage(link, useMetaKey) {
  const executeCmd = link.url && /^command:/i.test(link.url.toString());
  const label = link.tooltip ? link.tooltip : executeCmd ? localizeWithPath(_moduleId, 2, 'Execute command') : localizeWithPath(_moduleId, 3, 'Follow link');
  const kb = useMetaKey ? isMacintosh ? localizeWithPath(_moduleId, 4, "cmd + click") : localizeWithPath(_moduleId, 5, "ctrl + click") : isMacintosh ? localizeWithPath(_moduleId, 6, "option + click") : localizeWithPath(_moduleId, 7, "alt + click");
  if (link.url) {
    let nativeLabel = '';
    if (/^command:/i.test(link.url.toString())) {
      const match = link.url.toString().match(/^command:([^?#]+)/);
      if (match) {
        const commandId = match[1];
        nativeLabel = localizeWithPath(_moduleId, 8, "Execute command {0}", commandId);
      }
    }
    const hoverMessage = new MarkdownString('', true).appendLink(link.url.toString(true).replace(/ /g, '%20'), label, nativeLabel).appendMarkdown(` (${kb})`);
    return hoverMessage;
  } else {
    return new MarkdownString().appendText(`${label} (${kb})`);
  }
}
class OpenLinkAction extends EditorAction {
  constructor() {
    super({
      id: 'editor.action.openLink',
      label: localizeWithPath(_moduleId, 9, "Open Link"),
      alias: 'Open Link',
      precondition: undefined
    });
  }
  run(accessor, editor) {
    const linkDetector = LinkDetector.get(editor);
    if (!linkDetector) {
      return;
    }
    if (!editor.hasModel()) {
      return;
    }
    const selections = editor.getSelections();
    for (const sel of selections) {
      const link = linkDetector.getLinkOccurrence(sel.getEndPosition());
      if (link) {
        linkDetector.openLinkOccurrence(link, false);
      }
    }
  }
}
registerEditorContribution(LinkDetector.ID, LinkDetector, 1);
registerEditorAction(OpenLinkAction);
exports.LinkDetector = LinkDetector;