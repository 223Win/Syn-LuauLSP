const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  isNonEmptyArray
} = require('../../../../base/common/arrays.js');
const {
  CancellationToken,
  CancellationTokenSource
} = require('../../../../base/common/cancellation.js');
const {
  onUnexpectedError
} = require('../../../../base/common/errors.js');
const {
  KeyChord
} = require('../../../../base/common/keyCodes.js');
const {
  DisposableStore
} = require('../../../../base/common/lifecycle.js');
const {
  registerEditorContribution,
  registerEditorAction,
  EditorAction
} = require('../../../browser/editorExtensions.js');
const {
  ICodeEditorService
} = require('../../../browser/services/codeEditorService.js');
const {
  CharacterSet
} = require('../../../common/core/characterClassifier.js');
const {
  Range
} = require('../../../common/core/range.js');
const {
  EditorContextKeys
} = require('../../../common/editorContextKeys.js');
const {
  IEditorWorkerService
} = require('../../../common/services/editorWorker.js');
const {
  ILanguageFeaturesService
} = require('../../../common/services/languageFeatures.js');
const {
  getOnTypeFormattingEdits,
  formatDocumentRangesWithSelectedProvider,
  formatDocumentWithSelectedProvider
} = require('./format.js');
const {
  FormattingEdit
} = require('./formattingEdit.js');
const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  AccessibilitySignal
} = require('../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js');
const {
  IAccessibilitySignalService
} = require('../../../../platform/accessibilitySignal/browser/accessibilitySignalService.service.js');
const {
  CommandsRegistry
} = require('../../../../platform/commands/common/commands.js');
const {
  ICommandService
} = require('../../../../platform/commands/common/commands.service.js');
const {
  ContextKeyExpr
} = require('../../../../platform/contextkey/common/contextkey.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {
  Progress
} = require('../../../../platform/progress/common/progress.js');
const {
  IEditorProgressService
} = require('../../../../platform/progress/common/progress.service.js');
const _moduleId = "vs/editor/contrib/format/browser/formatActions";
let FormatOnType = class FormatOnType {
  static {
    this.ID = 'editor.contrib.autoFormat';
  }
  constructor(_editor, _languageFeaturesService, _workerService, _accessibilitySignalService) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._workerService = _workerService;
    this._accessibilitySignalService = _accessibilitySignalService;
    this._disposables = new DisposableStore();
    this._sessionDisposables = new DisposableStore();
    this._disposables.add(_languageFeaturesService.onTypeFormattingEditProvider.onDidChange(this._update, this));
    this._disposables.add(_editor.onDidChangeModel(() => this._update()));
    this._disposables.add(_editor.onDidChangeModelLanguage(() => this._update()));
    this._disposables.add(_editor.onDidChangeConfiguration(e => {
      if (e.hasChanged(56)) {
        this._update();
      }
    }));
    this._update();
  }
  dispose() {
    this._disposables.dispose();
    this._sessionDisposables.dispose();
  }
  _update() {
    this._sessionDisposables.clear();
    if (!this._editor.getOption(56)) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const [support] = this._languageFeaturesService.onTypeFormattingEditProvider.ordered(model);
    if (!support || !support.autoFormatTriggerCharacters) {
      return;
    }
    const triggerChars = new CharacterSet();
    for (const ch of support.autoFormatTriggerCharacters) {
      triggerChars.add(ch.charCodeAt(0));
    }
    this._sessionDisposables.add(this._editor.onDidType(text => {
      const lastCharCode = text.charCodeAt(text.length - 1);
      if (triggerChars.has(lastCharCode)) {
        this._trigger(String.fromCharCode(lastCharCode));
      }
    }));
  }
  _trigger(ch) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (this._editor.getSelections().length > 1 || !this._editor.getSelection().isEmpty()) {
      return;
    }
    const model = this._editor.getModel();
    const position = this._editor.getPosition();
    const cts = new CancellationTokenSource();
    const unbind = this._editor.onDidChangeModelContent(e => {
      if (e.isFlush) {
        cts.cancel();
        unbind.dispose();
        return;
      }
      for (let i = 0, len = e.changes.length; i < len; i++) {
        const change = e.changes[i];
        if (change.range.endLineNumber <= position.lineNumber) {
          cts.cancel();
          unbind.dispose();
          return;
        }
      }
    });
    getOnTypeFormattingEdits(this._workerService, this._languageFeaturesService, model, position, ch, model.getFormattingOptions(), cts.token).then(edits => {
      if (cts.token.isCancellationRequested) {
        return;
      }
      if (isNonEmptyArray(edits)) {
        this._accessibilitySignalService.playSignal(AccessibilitySignal.format, {
          userGesture: false
        });
        FormattingEdit.execute(this._editor, edits, true);
      }
    }).finally(() => {
      unbind.dispose();
    });
  }
};
FormatOnType = __decorate([__param(1, ILanguageFeaturesService), __param(2, IEditorWorkerService), __param(3, IAccessibilitySignalService)], FormatOnType);
let FormatOnPaste = class FormatOnPaste {
  static {
    this.ID = 'editor.contrib.formatOnPaste';
  }
  constructor(editor, _languageFeaturesService, _instantiationService) {
    this.editor = editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._instantiationService = _instantiationService;
    this._callOnDispose = new DisposableStore();
    this._callOnModel = new DisposableStore();
    this._callOnDispose.add(editor.onDidChangeConfiguration(() => this._update()));
    this._callOnDispose.add(editor.onDidChangeModel(() => this._update()));
    this._callOnDispose.add(editor.onDidChangeModelLanguage(() => this._update()));
    this._callOnDispose.add(_languageFeaturesService.documentRangeFormattingEditProvider.onDidChange(this._update, this));
  }
  dispose() {
    this._callOnDispose.dispose();
    this._callOnModel.dispose();
  }
  _update() {
    this._callOnModel.clear();
    if (!this.editor.getOption(55)) {
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    if (!this._languageFeaturesService.documentRangeFormattingEditProvider.has(this.editor.getModel())) {
      return;
    }
    this._callOnModel.add(this.editor.onDidPaste(({
      range
    }) => this._trigger(range)));
  }
  _trigger(range) {
    if (!this.editor.hasModel()) {
      return;
    }
    if (this.editor.getSelections().length > 1) {
      return;
    }
    this._instantiationService.invokeFunction(formatDocumentRangesWithSelectedProvider, this.editor, range, 2, Progress.None, CancellationToken.None, false).catch(onUnexpectedError);
  }
};
FormatOnPaste = __decorate([__param(1, ILanguageFeaturesService), __param(2, IInstantiationService)], FormatOnPaste);
class FormatDocumentAction extends EditorAction {
  constructor() {
    super({
      id: 'editor.action.formatDocument',
      label: localizeWithPath(_moduleId, 0, "Format Document"),
      alias: 'Format Document',
      precondition: ContextKeyExpr.and(EditorContextKeys.notInCompositeEditor, EditorContextKeys.writable, EditorContextKeys.hasDocumentFormattingProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 36,
        linux: {
          primary: 2048 | 1024 | 39
        },
        weight: 100
      },
      contextMenuOpts: {
        group: '1_modification',
        order: 1.3
      }
    });
  }
  async run(accessor, editor) {
    if (editor.hasModel()) {
      const instaService = accessor.get(IInstantiationService);
      const progressService = accessor.get(IEditorProgressService);
      await progressService.showWhile(instaService.invokeFunction(formatDocumentWithSelectedProvider, editor, 1, Progress.None, CancellationToken.None, true), 250);
    }
  }
}
class FormatSelectionAction extends EditorAction {
  constructor() {
    super({
      id: 'editor.action.formatSelection',
      label: localizeWithPath(_moduleId, 1, "Format Selection"),
      alias: 'Format Selection',
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasDocumentSelectionFormattingProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 36),
        weight: 100
      },
      contextMenuOpts: {
        when: EditorContextKeys.hasNonEmptySelection,
        group: '1_modification',
        order: 1.31
      }
    });
  }
  async run(accessor, editor) {
    if (!editor.hasModel()) {
      return;
    }
    const instaService = accessor.get(IInstantiationService);
    const model = editor.getModel();
    const ranges = editor.getSelections().map(range => {
      return range.isEmpty() ? new Range(range.startLineNumber, 1, range.startLineNumber, model.getLineMaxColumn(range.startLineNumber)) : range;
    });
    const progressService = accessor.get(IEditorProgressService);
    await progressService.showWhile(instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor, ranges, 1, Progress.None, CancellationToken.None, true), 250);
  }
}
registerEditorContribution(FormatOnType.ID, FormatOnType, 2);
registerEditorContribution(FormatOnPaste.ID, FormatOnPaste, 2);
registerEditorAction(FormatDocumentAction);
registerEditorAction(FormatSelectionAction);
CommandsRegistry.registerCommand('editor.action.format', async accessor => {
  const editor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
  if (!editor || !editor.hasModel()) {
    return;
  }
  const commandService = accessor.get(ICommandService);
  if (editor.getSelection().isEmpty()) {
    await commandService.executeCommand('editor.action.formatDocument');
  } else {
    await commandService.executeCommand('editor.action.formatSelection');
  }
});
exports.FormatOnType = FormatOnType;