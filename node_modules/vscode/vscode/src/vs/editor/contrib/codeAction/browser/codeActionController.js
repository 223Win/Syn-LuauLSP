const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  getDomNodePagePosition
} = require('../../../../base/browser/dom.js');
const {
  status
} = require('../../../../base/browser/ui/aria/aria.js');
const {
  onUnexpectedError
} = require('../../../../base/common/errors.js');
const {
  Lazy
} = require('../../../../base/common/lazy.js');
const {
  Disposable,
  MutableDisposable
} = require('../../../../base/common/lifecycle.js');
const {
  Position
} = require('../../../common/core/position.js');
const {
  ModelDecorationOptions
} = require('../../../common/model/textModel.js');
const {
  ILanguageFeaturesService
} = require('../../../common/services/languageFeatures.js');
const {
  ApplyCodeActionReason,
  applyCodeAction
} = require('./codeAction.js');
const {
  CodeActionKeybindingResolver
} = require('./codeActionKeybindingResolver.js');
const {
  toMenuItems
} = require('./codeActionMenu.js');
const {
  LightBulbWidget
} = require('./lightBulbWidget.js');
const {
  MessageController
} = require('../../message/browser/messageController.js');
const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  IActionWidgetService
} = require('../../../../platform/actionWidget/browser/actionWidget.js');
const {
  ICommandService
} = require('../../../../platform/commands/common/commands.service.js');
const {
  IConfigurationService
} = require('../../../../platform/configuration/common/configuration.service.js');
const {
  IContextKeyService
} = require('../../../../platform/contextkey/common/contextkey.service.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {
  IMarkerService
} = require('../../../../platform/markers/common/markers.service.js');
const {
  IEditorProgressService
} = require('../../../../platform/progress/common/progress.service.js');
const {} = require('../../../../platform/theme/common/colorUtils.js');
const {} = require('../../../../platform/theme/common/colors/baseColors.js');
const {} = require('../../../../platform/theme/common/colors/chartsColors.js');
const {
  editorFindMatchHighlight,
  editorFindMatchHighlightBorder
} = require('../../../../platform/theme/common/colors/editorColors.js');
const {} = require('../../../../platform/theme/common/colors/inputColors.js');
const {} = require('../../../../platform/theme/common/colors/listColors.js');
const {} = require('../../../../platform/theme/common/colors/menuColors.js');
const {} = require('../../../../platform/theme/common/colors/minimapColors.js');
const {} = require('../../../../platform/theme/common/colors/miscColors.js');
const {} = require('../../../../platform/theme/common/colors/quickpickColors.js');
const {} = require('../../../../platform/theme/common/colors/searchColors.js');
const {
  isHighContrast
} = require('../../../../platform/theme/common/theme.js');
const {
  registerThemingParticipant
} = require('../../../../platform/theme/common/themeService.js');
const {
  CodeActionTriggerSource,
  CodeActionKind
} = require('../common/types.js');
const {
  CodeActionModel
} = require('./codeActionModel.js');
const {
  HierarchicalKind
} = require('../../../../base/common/hierarchicalKind.js');
const {
  ITelemetryService
} = require('../../../../platform/telemetry/common/telemetry.service.js');
var CodeActionController_1;
const _moduleId = "vs/editor/contrib/codeAction/browser/codeActionController";
const DECORATION_CLASS_NAME = 'quickfix-edit-highlight';
let CodeActionController = class CodeActionController extends Disposable {
  static {
    CodeActionController_1 = this;
  }
  static {
    this.ID = 'editor.contrib.codeActionController';
  }
  static get(editor) {
    return editor.getContribution(CodeActionController_1.ID);
  }
  constructor(editor, markerService, contextKeyService, instantiationService, languageFeaturesService, progressService, _commandService, _configurationService, _actionWidgetService, _instantiationService, _telemetryService) {
    super();
    this._commandService = _commandService;
    this._configurationService = _configurationService;
    this._actionWidgetService = _actionWidgetService;
    this._instantiationService = _instantiationService;
    this._telemetryService = _telemetryService;
    this._activeCodeActions = this._register(new MutableDisposable());
    this._showDisabled = false;
    this._disposed = false;
    this._editor = editor;
    this._model = this._register(new CodeActionModel(this._editor, languageFeaturesService.codeActionProvider, markerService, contextKeyService, progressService, _configurationService));
    this._register(this._model.onDidChangeState(newState => this.update(newState)));
    this._lightBulbWidget = new Lazy(() => {
      const widget = this._editor.getContribution(LightBulbWidget.ID);
      if (widget) {
        this._register(widget.onClick(e => this.showCodeActionsFromLightbulb(e.actions, e)));
      }
      return widget;
    });
    this._resolver = instantiationService.createInstance(CodeActionKeybindingResolver);
    this._register(this._editor.onDidLayoutChange(() => this._actionWidgetService.hide()));
  }
  dispose() {
    this._disposed = true;
    super.dispose();
  }
  async showCodeActionsFromLightbulb(actions, at) {
    this._telemetryService.publicLog2('codeAction.showCodeActionsFromLightbulb', {
      codeActionListLength: actions.validActions.length,
      codeActions: actions.validActions.map(action => action.action.title),
      codeActionProviders: actions.validActions.map(action => action.provider?.displayName ?? '')
    });
    if (actions.allAIFixes && actions.validActions.length === 1) {
      const actionItem = actions.validActions[0];
      const command = actionItem.action.command;
      if (command && command.id === 'inlineChat.start') {
        if (command.arguments && command.arguments.length >= 1) {
          command.arguments[0] = {
            ...command.arguments[0],
            autoSend: false
          };
        }
      }
      await this._applyCodeAction(actionItem, false, false, ApplyCodeActionReason.FromAILightbulb);
      return;
    }
    await this.showCodeActionList(actions, at, {
      includeDisabledActions: false,
      fromLightbulb: true
    });
  }
  showCodeActions(_trigger, actions, at) {
    return this.showCodeActionList(actions, at, {
      includeDisabledActions: false,
      fromLightbulb: false
    });
  }
  hideCodeActions() {
    this._actionWidgetService.hide();
  }
  manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply) {
    if (!this._editor.hasModel()) {
      return;
    }
    MessageController.get(this._editor)?.closeMessage();
    const triggerPosition = this._editor.getPosition();
    this._trigger({
      type: 1,
      triggerAction,
      filter,
      autoApply,
      context: {
        notAvailableMessage,
        position: triggerPosition
      }
    });
  }
  _trigger(trigger) {
    return this._model.trigger(trigger);
  }
  async _applyCodeAction(action, retrigger, preview, actionReason) {
    try {
      await this._instantiationService.invokeFunction(applyCodeAction, action, actionReason, {
        preview,
        editor: this._editor
      });
    } finally {
      if (retrigger) {
        this._trigger({
          type: 2,
          triggerAction: CodeActionTriggerSource.QuickFix,
          filter: {}
        });
      }
    }
  }
  hideLightBulbWidget() {
    this._lightBulbWidget.rawValue?.hide();
  }
  async update(newState) {
    if (newState.type !== 1) {
      this._lightBulbWidget.rawValue?.hide();
      return;
    }
    let actions;
    try {
      actions = await newState.actions;
    } catch (e) {
      onUnexpectedError(e);
      return;
    }
    if (this._disposed) {
      return;
    }
    this._lightBulbWidget.value?.update(actions, newState.trigger, newState.position);
    if (newState.trigger.type === 1) {
      if (newState.trigger.filter?.include) {
        const validActionToApply = this.tryGetValidActionToApply(newState.trigger, actions);
        if (validActionToApply) {
          try {
            this._lightBulbWidget.value?.hide();
            await this._applyCodeAction(validActionToApply, false, false, ApplyCodeActionReason.FromCodeActions);
          } finally {
            actions.dispose();
          }
          return;
        }
        if (newState.trigger.context) {
          const invalidAction = this.getInvalidActionThatWouldHaveBeenApplied(newState.trigger, actions);
          if (invalidAction && invalidAction.action.disabled) {
            MessageController.get(this._editor)?.showMessage(invalidAction.action.disabled, newState.trigger.context.position);
            actions.dispose();
            return;
          }
        }
      }
      const includeDisabledActions = !!newState.trigger.filter?.include;
      if (newState.trigger.context) {
        if (!actions.allActions.length || !includeDisabledActions && !actions.validActions.length) {
          MessageController.get(this._editor)?.showMessage(newState.trigger.context.notAvailableMessage, newState.trigger.context.position);
          this._activeCodeActions.value = actions;
          actions.dispose();
          return;
        }
      }
      this._activeCodeActions.value = actions;
      this.showCodeActionList(actions, this.toCoords(newState.position), {
        includeDisabledActions,
        fromLightbulb: false
      });
    } else {
      if (this._actionWidgetService.isVisible) {
        actions.dispose();
      } else {
        this._activeCodeActions.value = actions;
      }
    }
  }
  getInvalidActionThatWouldHaveBeenApplied(trigger, actions) {
    if (!actions.allActions.length) {
      return undefined;
    }
    if (trigger.autoApply === "first" && actions.validActions.length === 0 || trigger.autoApply === "ifSingle" && actions.allActions.length === 1) {
      return actions.allActions.find(({
        action
      }) => action.disabled);
    }
    return undefined;
  }
  tryGetValidActionToApply(trigger, actions) {
    if (!actions.validActions.length) {
      return undefined;
    }
    if (trigger.autoApply === "first" && actions.validActions.length > 0 || trigger.autoApply === "ifSingle" && actions.validActions.length === 1) {
      return actions.validActions[0];
    }
    return undefined;
  }
  static {
    this.DECORATION = ModelDecorationOptions.register({
      description: 'quickfix-highlight',
      className: DECORATION_CLASS_NAME
    });
  }
  async showCodeActionList(actions, at, options) {
    const currentDecorations = this._editor.createDecorationsCollection();
    const editorDom = this._editor.getDomNode();
    if (!editorDom) {
      return;
    }
    const actionsToShow = options.includeDisabledActions && (this._showDisabled || actions.validActions.length === 0) ? actions.allActions : actions.validActions;
    if (!actionsToShow.length) {
      return;
    }
    const anchor = Position.isIPosition(at) ? this.toCoords(at) : at;
    const delegate = {
      onSelect: async (action, preview) => {
        this._applyCodeAction(action, true, !!preview, options.fromLightbulb ? ApplyCodeActionReason.FromAILightbulb : ApplyCodeActionReason.FromCodeActions);
        this._actionWidgetService.hide(false);
        currentDecorations.clear();
      },
      onHide: didCancel => {
        this._editor?.focus();
        currentDecorations.clear();
        if (options.fromLightbulb && didCancel !== undefined) {
          this._telemetryService.publicLog2('codeAction.showCodeActionList.onHide', {
            codeActionListLength: actions.validActions.length,
            didCancel: didCancel
          });
        }
      },
      onHover: async (action, token) => {
        if (token.isCancellationRequested) {
          return;
        }
        let canPreview = false;
        const actionKind = action.action.kind;
        if (actionKind) {
          const hierarchicalKind = new HierarchicalKind(actionKind);
          const refactorKinds = [CodeActionKind.RefactorExtract, CodeActionKind.RefactorInline, CodeActionKind.RefactorRewrite, CodeActionKind.RefactorMove, CodeActionKind.Source];
          canPreview = refactorKinds.some(refactorKind => refactorKind.contains(hierarchicalKind));
        }
        return {
          canPreview: canPreview || !!action.action.edit?.edits.length
        };
      },
      onFocus: action => {
        if (action && action.action) {
          const ranges = action.action.ranges;
          const diagnostics = action.action.diagnostics;
          currentDecorations.clear();
          if (ranges && ranges.length > 0) {
            const decorations = diagnostics && diagnostics?.length > 1 ? diagnostics.map(diagnostic => ({
              range: diagnostic,
              options: CodeActionController_1.DECORATION
            })) : ranges.map(range => ({
              range,
              options: CodeActionController_1.DECORATION
            }));
            currentDecorations.set(decorations);
          } else if (diagnostics && diagnostics.length > 0) {
            const decorations = diagnostics.map(diagnostic => ({
              range: diagnostic,
              options: CodeActionController_1.DECORATION
            }));
            currentDecorations.set(decorations);
            const diagnostic = diagnostics[0];
            if (diagnostic.startLineNumber && diagnostic.startColumn) {
              const selectionText = this._editor.getModel()?.getWordAtPosition({
                lineNumber: diagnostic.startLineNumber,
                column: diagnostic.startColumn
              })?.word;
              status(localizeWithPath(_moduleId, 0, "Context: {0} at line {1} and column {2}.", selectionText, diagnostic.startLineNumber, diagnostic.startColumn));
            }
          }
        } else {
          currentDecorations.clear();
        }
      }
    };
    this._actionWidgetService.show('codeActionWidget', true, toMenuItems(actionsToShow, this._shouldShowHeaders(), this._resolver.getResolver()), delegate, anchor, editorDom, this._getActionBarActions(actions, at, options));
  }
  toCoords(position) {
    if (!this._editor.hasModel()) {
      return {
        x: 0,
        y: 0
      };
    }
    this._editor.revealPosition(position, 1);
    this._editor.render();
    const cursorCoords = this._editor.getScrolledVisiblePosition(position);
    const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
    const x = editorCoords.left + cursorCoords.left;
    const y = editorCoords.top + cursorCoords.top + cursorCoords.height;
    return {
      x,
      y
    };
  }
  _shouldShowHeaders() {
    const model = this._editor?.getModel();
    return this._configurationService.getValue('editor.codeActionWidget.showHeaders', {
      resource: model?.uri
    });
  }
  _getActionBarActions(actions, at, options) {
    if (options.fromLightbulb) {
      return [];
    }
    const resultActions = actions.documentation.map(command => ({
      id: command.id,
      label: command.title,
      tooltip: command.tooltip ?? '',
      class: undefined,
      enabled: true,
      run: () => this._commandService.executeCommand(command.id, ...(command.arguments ?? []))
    }));
    if (options.includeDisabledActions && actions.validActions.length > 0 && actions.allActions.length !== actions.validActions.length) {
      resultActions.push(this._showDisabled ? {
        id: 'hideMoreActions',
        label: localizeWithPath(_moduleId, 1, 'Hide Disabled'),
        enabled: true,
        tooltip: '',
        class: undefined,
        run: () => {
          this._showDisabled = false;
          return this.showCodeActionList(actions, at, options);
        }
      } : {
        id: 'showMoreActions',
        label: localizeWithPath(_moduleId, 2, 'Show Disabled'),
        enabled: true,
        tooltip: '',
        class: undefined,
        run: () => {
          this._showDisabled = true;
          return this.showCodeActionList(actions, at, options);
        }
      });
    }
    return resultActions;
  }
};
CodeActionController = CodeActionController_1 = __decorate([__param(1, IMarkerService), __param(2, IContextKeyService), __param(3, IInstantiationService), __param(4, ILanguageFeaturesService), __param(5, IEditorProgressService), __param(6, ICommandService), __param(7, IConfigurationService), __param(8, IActionWidgetService), __param(9, IInstantiationService), __param(10, ITelemetryService)], CodeActionController);
registerThemingParticipant((theme, collector) => {
  const addBackgroundColorRule = (selector, color) => {
    if (color) {
      collector.addRule(`.monaco-editor ${selector} { background-color: ${color}; }`);
    }
  };
  addBackgroundColorRule('.quickfix-edit-highlight', theme.getColor(editorFindMatchHighlight));
  const findMatchHighlightBorder = theme.getColor(editorFindMatchHighlightBorder);
  if (findMatchHighlightBorder) {
    collector.addRule(`.monaco-editor .quickfix-edit-highlight { border: 1px ${isHighContrast(theme.type) ? 'dotted' : 'solid'} ${findMatchHighlightBorder}; box-sizing: border-box; }`);
  }
});
exports.CodeActionController = CodeActionController;