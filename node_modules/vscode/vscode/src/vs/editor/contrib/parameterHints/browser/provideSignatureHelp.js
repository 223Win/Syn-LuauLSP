const {
  CancellationToken
} = require('../../../../base/common/cancellation.js');
const {
  onUnexpectedExternalError
} = require('../../../../base/common/errors.js');
const {
  assertType
} = require('../../../../base/common/types.js');
const {
  URI
} = require('../../../../base/common/uri.js');
const {
  Position
} = require('../../../common/core/position.js');
const {
  SignatureHelpTriggerKind
} = require('../../../common/languages.js');
const {
  ILanguageFeaturesService
} = require('../../../common/services/languageFeatures.js');
const {
  ITextModelService
} = require('../../../common/services/resolverService.js');
const {
  CommandsRegistry
} = require('../../../../platform/commands/common/commands.js');
const {
  RawContextKey
} = require('../../../../platform/contextkey/common/contextkey.js');
const Context = {
  Visible: new RawContextKey('parameterHintsVisible', false),
  MultipleSignatures: new RawContextKey('parameterHintsMultipleSignatures', false)
};
async function provideSignatureHelp(registry, model, position, context, token) {
  const supports = registry.ordered(model);
  for (const support of supports) {
    try {
      const result = await support.provideSignatureHelp(model, position, token, context);
      if (result) {
        return result;
      }
    } catch (err) {
      onUnexpectedExternalError(err);
    }
  }
  return undefined;
}
CommandsRegistry.registerCommand('_executeSignatureHelpProvider', async (accessor, ...args) => {
  const [uri, position, triggerCharacter] = args;
  assertType(URI.isUri(uri));
  assertType(Position.isIPosition(position));
  assertType(typeof triggerCharacter === 'string' || !triggerCharacter);
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const ref = await accessor.get(ITextModelService).createModelReference(uri);
  try {
    const result = await provideSignatureHelp(languageFeaturesService.signatureHelpProvider, ref.object.textEditorModel, Position.lift(position), {
      triggerKind: SignatureHelpTriggerKind.Invoke,
      isRetrigger: false,
      triggerCharacter
    }, CancellationToken.None);
    if (!result) {
      return undefined;
    }
    setTimeout(() => result.dispose(), 0);
    return result.value;
  } finally {
    ref.dispose();
  }
});
exports.Context = Context;
exports.provideSignatureHelp = provideSignatureHelp;