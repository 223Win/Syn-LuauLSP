const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  append,
  addDisposableListener,
  $$1,
  EventHelper
} = require('../../../../base/browser/dom.js');
const {
  alert
} = require('../../../../base/browser/ui/aria/aria.js');
const {
  DomScrollableElement
} = require('../../../../base/browser/ui/scrollbar/scrollableElement.js');
const {
  Codicon
} = require('../../../../base/common/codicons.js');
const {
  Event
} = require('../../../../base/common/event.js');
const {
  Disposable,
  DisposableStore
} = require('../../../../base/common/lifecycle.js');
const {
  escapeRegExpCharacters
} = require('../../../../base/common/strings.js');
const {
  assertIsDefined
} = require('../../../../base/common/types.js');
const {} = require('./parameterHints.css.js');
const {
  ILanguageService
} = require('../../../common/languages/language.js');
const {
  MarkdownRenderer
} = require('../../../browser/widget/markdownRenderer/browser/markdownRenderer.js');
const {
  Context
} = require('./provideSignatureHelp.js');
const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  IContextKeyService
} = require('../../../../platform/contextkey/common/contextkey.service.js');
const {
  IOpenerService
} = require('../../../../platform/opener/common/opener.service.js');
const {
  registerColor
} = require('../../../../platform/theme/common/colorUtils.js');
const {} = require('../../../../platform/theme/common/colors/baseColors.js');
const {} = require('../../../../platform/theme/common/colors/chartsColors.js');
const {} = require('../../../../platform/theme/common/colors/editorColors.js');
const {} = require('../../../../platform/theme/common/colors/inputColors.js');
const {
  listHighlightForeground
} = require('../../../../platform/theme/common/colors/listColors.js');
const {} = require('../../../../platform/theme/common/colors/menuColors.js');
const {} = require('../../../../platform/theme/common/colors/minimapColors.js');
const {} = require('../../../../platform/theme/common/colors/miscColors.js');
const {} = require('../../../../platform/theme/common/colors/quickpickColors.js');
const {} = require('../../../../platform/theme/common/colors/searchColors.js');
const {
  registerIcon
} = require('../../../../platform/theme/common/iconRegistry.js');
const {
  ThemeIcon
} = require('../../../../base/common/themables.js');
var ParameterHintsWidget_1;
const _moduleId = "vs/editor/contrib/parameterHints/browser/parameterHintsWidget";
const $ = $$1;
const parameterHintsNextIcon = registerIcon('parameter-hints-next', Codicon.chevronDown, localizeWithPath(_moduleId, 0, 'Icon for show next parameter hint.'));
const parameterHintsPreviousIcon = registerIcon('parameter-hints-previous', Codicon.chevronUp, localizeWithPath(_moduleId, 1, 'Icon for show previous parameter hint.'));
let ParameterHintsWidget = class ParameterHintsWidget extends Disposable {
  static {
    ParameterHintsWidget_1 = this;
  }
  static {
    this.ID = 'editor.widget.parameterHintsWidget';
  }
  constructor(editor, model, contextKeyService, openerService, languageService) {
    super();
    this.editor = editor;
    this.model = model;
    this.renderDisposeables = this._register(new DisposableStore());
    this.visible = false;
    this.announcedLabel = null;
    this.allowEditorOverflow = true;
    this.markdownRenderer = this._register(new MarkdownRenderer({
      editor
    }, languageService, openerService));
    this.keyVisible = Context.Visible.bindTo(contextKeyService);
    this.keyMultipleSignatures = Context.MultipleSignatures.bindTo(contextKeyService);
  }
  createParameterHintDOMNodes() {
    const element = $('.editor-widget.parameter-hints-widget');
    const wrapper = append(element, $('.phwrapper'));
    wrapper.tabIndex = -1;
    const controls = append(wrapper, $('.controls'));
    const previous = append(controls, $('.button' + ThemeIcon.asCSSSelector(parameterHintsPreviousIcon)));
    const overloads = append(controls, $('.overloads'));
    const next = append(controls, $('.button' + ThemeIcon.asCSSSelector(parameterHintsNextIcon)));
    this._register(addDisposableListener(previous, 'click', e => {
      EventHelper.stop(e);
      this.previous();
    }));
    this._register(addDisposableListener(next, 'click', e => {
      EventHelper.stop(e);
      this.next();
    }));
    const body = $('.body');
    const scrollbar = new DomScrollableElement(body, {
      alwaysConsumeMouseWheel: true
    });
    this._register(scrollbar);
    wrapper.appendChild(scrollbar.getDomNode());
    const signature = append(body, $('.signature'));
    const docs = append(body, $('.docs'));
    element.style.userSelect = 'text';
    this.domNodes = {
      element,
      signature,
      overloads,
      docs,
      scrollbar
    };
    this.editor.addContentWidget(this);
    this.hide();
    this._register(this.editor.onDidChangeCursorSelection(e => {
      if (this.visible) {
        this.editor.layoutContentWidget(this);
      }
    }));
    const updateFont = () => {
      if (!this.domNodes) {
        return;
      }
      const fontInfo = this.editor.getOption(50);
      this.domNodes.element.style.fontSize = `${fontInfo.fontSize}px`;
      this.domNodes.element.style.lineHeight = `${fontInfo.lineHeight / fontInfo.fontSize}`;
    };
    updateFont();
    this._register(Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor), $ => $.filter(e => e.hasChanged(50)))(updateFont));
    this._register(this.editor.onDidLayoutChange(e => this.updateMaxHeight()));
    this.updateMaxHeight();
  }
  show() {
    if (this.visible) {
      return;
    }
    if (!this.domNodes) {
      this.createParameterHintDOMNodes();
    }
    this.keyVisible.set(true);
    this.visible = true;
    setTimeout(() => {
      this.domNodes?.element.classList.add('visible');
    }, 100);
    this.editor.layoutContentWidget(this);
  }
  hide() {
    this.renderDisposeables.clear();
    if (!this.visible) {
      return;
    }
    this.keyVisible.reset();
    this.visible = false;
    this.announcedLabel = null;
    this.domNodes?.element.classList.remove('visible');
    this.editor.layoutContentWidget(this);
  }
  getPosition() {
    if (this.visible) {
      return {
        position: this.editor.getPosition(),
        preference: [1, 2]
      };
    }
    return null;
  }
  render(hints) {
    this.renderDisposeables.clear();
    if (!this.domNodes) {
      return;
    }
    const multiple = hints.signatures.length > 1;
    this.domNodes.element.classList.toggle('multiple', multiple);
    this.keyMultipleSignatures.set(multiple);
    this.domNodes.signature.innerText = '';
    this.domNodes.docs.innerText = '';
    const signature = hints.signatures[hints.activeSignature];
    if (!signature) {
      return;
    }
    const code = append(this.domNodes.signature, $('.code'));
    const fontInfo = this.editor.getOption(50);
    code.style.fontSize = `${fontInfo.fontSize}px`;
    code.style.fontFamily = fontInfo.fontFamily;
    const hasParameters = signature.parameters.length > 0;
    const activeParameterIndex = signature.activeParameter ?? hints.activeParameter;
    if (!hasParameters) {
      const label = append(code, $('span'));
      label.textContent = signature.label;
    } else {
      this.renderParameters(code, signature, activeParameterIndex);
    }
    const activeParameter = signature.parameters[activeParameterIndex];
    if (activeParameter?.documentation) {
      const documentation = $('span.documentation');
      if (typeof activeParameter.documentation === 'string') {
        documentation.textContent = activeParameter.documentation;
      } else {
        const renderedContents = this.renderMarkdownDocs(activeParameter.documentation);
        documentation.appendChild(renderedContents.element);
      }
      append(this.domNodes.docs, $('p', {}, documentation));
    }
    if (signature.documentation === undefined) ;else if (typeof signature.documentation === 'string') {
      append(this.domNodes.docs, $('p', {}, signature.documentation));
    } else {
      const renderedContents = this.renderMarkdownDocs(signature.documentation);
      append(this.domNodes.docs, renderedContents.element);
    }
    const hasDocs = this.hasDocs(signature, activeParameter);
    this.domNodes.signature.classList.toggle('has-docs', hasDocs);
    this.domNodes.docs.classList.toggle('empty', !hasDocs);
    this.domNodes.overloads.textContent = String(hints.activeSignature + 1).padStart(hints.signatures.length.toString().length, '0') + '/' + hints.signatures.length;
    if (activeParameter) {
      let labelToAnnounce = '';
      const param = signature.parameters[activeParameterIndex];
      if (Array.isArray(param.label)) {
        labelToAnnounce = signature.label.substring(param.label[0], param.label[1]);
      } else {
        labelToAnnounce = param.label;
      }
      if (param.documentation) {
        labelToAnnounce += typeof param.documentation === 'string' ? `, ${param.documentation}` : `, ${param.documentation.value}`;
      }
      if (signature.documentation) {
        labelToAnnounce += typeof signature.documentation === 'string' ? `, ${signature.documentation}` : `, ${signature.documentation.value}`;
      }
      if (this.announcedLabel !== labelToAnnounce) {
        alert(localizeWithPath(_moduleId, 2, "{0}, hint", labelToAnnounce));
        this.announcedLabel = labelToAnnounce;
      }
    }
    this.editor.layoutContentWidget(this);
    this.domNodes.scrollbar.scanDomNode();
  }
  renderMarkdownDocs(markdown) {
    const renderedContents = this.renderDisposeables.add(this.markdownRenderer.render(markdown, {
      asyncRenderCallback: () => {
        this.domNodes?.scrollbar.scanDomNode();
      }
    }));
    renderedContents.element.classList.add('markdown-docs');
    return renderedContents;
  }
  hasDocs(signature, activeParameter) {
    if (activeParameter && typeof activeParameter.documentation === 'string' && assertIsDefined(activeParameter.documentation).length > 0) {
      return true;
    }
    if (activeParameter && typeof activeParameter.documentation === 'object' && assertIsDefined(activeParameter.documentation).value.length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === 'string' && assertIsDefined(signature.documentation).length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === 'object' && assertIsDefined(signature.documentation.value).length > 0) {
      return true;
    }
    return false;
  }
  renderParameters(parent, signature, activeParameterIndex) {
    const [start, end] = this.getParameterLabelOffsets(signature, activeParameterIndex);
    const beforeSpan = document.createElement('span');
    beforeSpan.textContent = signature.label.substring(0, start);
    const paramSpan = document.createElement('span');
    paramSpan.textContent = signature.label.substring(start, end);
    paramSpan.className = 'parameter active';
    const afterSpan = document.createElement('span');
    afterSpan.textContent = signature.label.substring(end);
    append(parent, beforeSpan, paramSpan, afterSpan);
  }
  getParameterLabelOffsets(signature, paramIdx) {
    const param = signature.parameters[paramIdx];
    if (!param) {
      return [0, 0];
    } else if (Array.isArray(param.label)) {
      return param.label;
    } else if (!param.label.length) {
      return [0, 0];
    } else {
      const regex = new RegExp(`(\\W|^)${escapeRegExpCharacters(param.label)}(?=\\W|$)`, 'g');
      regex.test(signature.label);
      const idx = regex.lastIndex - param.label.length;
      return idx >= 0 ? [idx, regex.lastIndex] : [0, 0];
    }
  }
  next() {
    this.editor.focus();
    this.model.next();
  }
  previous() {
    this.editor.focus();
    this.model.previous();
  }
  getDomNode() {
    if (!this.domNodes) {
      this.createParameterHintDOMNodes();
    }
    return this.domNodes.element;
  }
  getId() {
    return ParameterHintsWidget_1.ID;
  }
  updateMaxHeight() {
    if (!this.domNodes) {
      return;
    }
    const height = Math.max(this.editor.getLayoutInfo().height / 4, 250);
    const maxHeight = `${height}px`;
    this.domNodes.element.style.maxHeight = maxHeight;
    const wrapper = this.domNodes.element.getElementsByClassName('phwrapper');
    if (wrapper.length) {
      wrapper[0].style.maxHeight = maxHeight;
    }
  }
};
ParameterHintsWidget = ParameterHintsWidget_1 = __decorate([__param(2, IContextKeyService), __param(3, IOpenerService), __param(4, ILanguageService)], ParameterHintsWidget);
registerColor('editorHoverWidget.highlightForeground', {
  dark: listHighlightForeground,
  light: listHighlightForeground,
  hcDark: listHighlightForeground,
  hcLight: listHighlightForeground
}, localizeWithPath(_moduleId, 3, 'Foreground color of the active item in the parameter hint.'));
exports.ParameterHintsWidget = ParameterHintsWidget;