const {
  Event
} = require('../../../../base/common/event.js');
const {
  Disposable
} = require('../../../../base/common/lifecycle.js');
const {
  Position
} = require('../../../common/core/position.js');
const {
  Range
} = require('../../../common/core/range.js');
const {
  SelectedSuggestionInfo
} = require('../../../common/languages.js');
const {
  SnippetParser
} = require('../../snippet/browser/snippetParser.js');
const {
  SnippetSession
} = require('../../snippet/browser/snippetSession.js');
const {
  SuggestController
} = require('../../suggest/browser/suggestController.js');
const {
  observableValue,
  transaction
} = require('../../../../base/common/observableInternal/base.js');
const {} = require('../../../../base/common/observableInternal/derived.js');
const {} = require('../../../../base/common/observableInternal/autorun.js');
const {} = require('../../../../base/common/observableInternal/utils.js');
const {} = require('../../../../base/common/cancellation.js');
const {
  compareBy,
  numberComparator
} = require('../../../../base/common/arrays.js');
const {
  SingleTextEdit
} = require('../../../common/core/textEdit.js');
const {
  findFirstMax
} = require('../../../../base/common/arraysFind.js');
const {
  singleTextRemoveCommonPrefix,
  singleTextEditAugments
} = require('./singleTextEdit.js');
class SuggestWidgetAdaptor extends Disposable {
  get selectedItem() {
    return this._selectedItem;
  }
  constructor(editor, suggestControllerPreselector, checkModelVersion, onWillAccept) {
    super();
    this.editor = editor;
    this.suggestControllerPreselector = suggestControllerPreselector;
    this.checkModelVersion = checkModelVersion;
    this.onWillAccept = onWillAccept;
    this.isSuggestWidgetVisible = false;
    this.isShiftKeyPressed = false;
    this._isActive = false;
    this._currentSuggestItemInfo = undefined;
    this._selectedItem = observableValue(this, undefined);
    this._register(editor.onKeyDown(e => {
      if (e.shiftKey && !this.isShiftKeyPressed) {
        this.isShiftKeyPressed = true;
        this.update(this._isActive);
      }
    }));
    this._register(editor.onKeyUp(e => {
      if (e.shiftKey && this.isShiftKeyPressed) {
        this.isShiftKeyPressed = false;
        this.update(this._isActive);
      }
    }));
    const suggestController = SuggestController.get(this.editor);
    if (suggestController) {
      this._register(suggestController.registerSelector({
        priority: 100,
        select: (model, pos, suggestItems) => {
          transaction(tx => this.checkModelVersion(tx));
          const textModel = this.editor.getModel();
          if (!textModel) {
            return -1;
          }
          const i = this.suggestControllerPreselector();
          const itemToPreselect = i ? singleTextRemoveCommonPrefix(i, textModel) : undefined;
          if (!itemToPreselect) {
            return -1;
          }
          const position = Position.lift(pos);
          const candidates = suggestItems.map((suggestItem, index) => {
            const suggestItemInfo = SuggestItemInfo.fromSuggestion(suggestController, textModel, position, suggestItem, this.isShiftKeyPressed);
            const suggestItemTextEdit = singleTextRemoveCommonPrefix(suggestItemInfo.toSingleTextEdit(), textModel);
            const valid = singleTextEditAugments(itemToPreselect, suggestItemTextEdit);
            return {
              index,
              valid,
              prefixLength: suggestItemTextEdit.text.length,
              suggestItem
            };
          }).filter(item => item && item.valid && item.prefixLength > 0);
          const result = findFirstMax(candidates, compareBy(s => s.prefixLength, numberComparator));
          return result ? result.index : -1;
        }
      }));
      let isBoundToSuggestWidget = false;
      const bindToSuggestWidget = () => {
        if (isBoundToSuggestWidget) {
          return;
        }
        isBoundToSuggestWidget = true;
        this._register(suggestController.widget.value.onDidShow(() => {
          this.isSuggestWidgetVisible = true;
          this.update(true);
        }));
        this._register(suggestController.widget.value.onDidHide(() => {
          this.isSuggestWidgetVisible = false;
          this.update(false);
        }));
        this._register(suggestController.widget.value.onDidFocus(() => {
          this.isSuggestWidgetVisible = true;
          this.update(true);
        }));
      };
      this._register(Event.once(suggestController.model.onDidTrigger)(e => {
        bindToSuggestWidget();
      }));
      this._register(suggestController.onWillInsertSuggestItem(e => {
        const position = this.editor.getPosition();
        const model = this.editor.getModel();
        if (!position || !model) {
          return undefined;
        }
        const suggestItemInfo = SuggestItemInfo.fromSuggestion(suggestController, model, position, e.item, this.isShiftKeyPressed);
        this.onWillAccept(suggestItemInfo);
      }));
    }
    this.update(this._isActive);
  }
  update(newActive) {
    const newInlineCompletion = this.getSuggestItemInfo();
    if (this._isActive !== newActive || !suggestItemInfoEquals(this._currentSuggestItemInfo, newInlineCompletion)) {
      this._isActive = newActive;
      this._currentSuggestItemInfo = newInlineCompletion;
      transaction(tx => {
        this.checkModelVersion(tx);
        this._selectedItem.set(this._isActive ? this._currentSuggestItemInfo : undefined, tx);
      });
    }
  }
  getSuggestItemInfo() {
    const suggestController = SuggestController.get(this.editor);
    if (!suggestController || !this.isSuggestWidgetVisible) {
      return undefined;
    }
    const focusedItem = suggestController.widget.value.getFocusedItem();
    const position = this.editor.getPosition();
    const model = this.editor.getModel();
    if (!focusedItem || !position || !model) {
      return undefined;
    }
    return SuggestItemInfo.fromSuggestion(suggestController, model, position, focusedItem.item, this.isShiftKeyPressed);
  }
  stopForceRenderingAbove() {
    const suggestController = SuggestController.get(this.editor);
    suggestController?.stopForceRenderingAbove();
  }
  forceRenderingAbove() {
    const suggestController = SuggestController.get(this.editor);
    suggestController?.forceRenderingAbove();
  }
}
class SuggestItemInfo {
  static fromSuggestion(suggestController, model, position, item, toggleMode) {
    let {
      insertText
    } = item.completion;
    let isSnippetText = false;
    if (item.completion.insertTextRules & 4) {
      const snippet = new SnippetParser().parse(insertText);
      if (snippet.children.length < 100) {
        SnippetSession.adjustWhitespace(model, position, true, snippet);
      }
      insertText = snippet.toString();
      isSnippetText = true;
    }
    const info = suggestController.getOverwriteInfo(item, toggleMode);
    return new SuggestItemInfo(Range.fromPositions(position.delta(0, -info.overwriteBefore), position.delta(0, Math.max(info.overwriteAfter, 0))), insertText, item.completion.kind, isSnippetText);
  }
  constructor(range, insertText, completionItemKind, isSnippetText) {
    this.range = range;
    this.insertText = insertText;
    this.completionItemKind = completionItemKind;
    this.isSnippetText = isSnippetText;
  }
  equals(other) {
    return this.range.equalsRange(other.range) && this.insertText === other.insertText && this.completionItemKind === other.completionItemKind && this.isSnippetText === other.isSnippetText;
  }
  toSelectedSuggestionInfo() {
    return new SelectedSuggestionInfo(this.range, this.insertText, this.completionItemKind, this.isSnippetText);
  }
  toSingleTextEdit() {
    return new SingleTextEdit(this.range, this.insertText);
  }
}
function suggestItemInfoEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.equals(b);
}
exports.SuggestItemInfo = SuggestItemInfo;
exports.SuggestWidgetAdaptor = SuggestWidgetAdaptor;