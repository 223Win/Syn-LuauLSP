const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  h
} = require('../../../../base/browser/dom.js');
const {
  ActionViewItem
} = require('../../../../base/browser/ui/actionbar/actionViewItems.js');
const {
  KeybindingLabel,
  unthemedKeybindingLabelOptions
} = require('../../../../base/browser/ui/keybindingLabel/keybindingLabel.js');
const {
  Action,
  Separator
} = require('../../../../base/common/actions.js');
const {
  equals
} = require('../../../../base/common/arrays.js');
const {
  RunOnceScheduler
} = require('../../../../base/common/async.js');
const {
  Codicon
} = require('../../../../base/common/codicons.js');
const {
  Disposable,
  toDisposable
} = require('../../../../base/common/lifecycle.js');
const {
  derived
} = require('../../../../base/common/observableInternal/derived.js');
const {
  autorun,
  autorunWithStore
} = require('../../../../base/common/observableInternal/autorun.js');
const {
  observableFromEvent
} = require('../../../../base/common/observableInternal/utils.js');
const {} = require('../../../../base/common/cancellation.js');
const {
  OS
} = require('../../../../base/common/platform.js');
const {
  ThemeIcon
} = require('../../../../base/common/themables.js');
const {} = require('./inlineCompletionsHintsWidget.css.js');
const {
  Position
} = require('../../../common/core/position.js');
const {
  InlineCompletionTriggerKind
} = require('../../../common/languages.js');
const {
  showPreviousInlineSuggestionActionId,
  showNextInlineSuggestionActionId
} = require('./commandIds.js');
const {
  localizeWithPath
} = require('../../../../nls.js');
const {
  MenuEntryActionViewItem,
  createAndFillInActionBarActions
} = require('../../../../platform/actions/browser/menuEntryActionViewItem.js');
const {
  WorkbenchToolBar
} = require('../../../../platform/actions/browser/toolbar.js');
const {
  MenuId,
  MenuItemAction
} = require('../../../../platform/actions/common/actions.js');
const {
  IMenuService
} = require('../../../../platform/actions/common/actions.service.js');
const {
  ICommandService
} = require('../../../../platform/commands/common/commands.service.js');
const {
  IContextKeyService
} = require('../../../../platform/contextkey/common/contextkey.service.js');
const {
  IContextMenuService
} = require('../../../../platform/contextview/browser/contextView.service.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {
  IKeybindingService
} = require('../../../../platform/keybinding/common/keybinding.service.js');
const {
  ITelemetryService
} = require('../../../../platform/telemetry/common/telemetry.service.js');
const {
  registerIcon
} = require('../../../../platform/theme/common/iconRegistry.js');
var InlineSuggestionHintsContentWidget_1;
const _moduleId = "vs/editor/contrib/inlineCompletions/browser/inlineCompletionsHintsWidget";
let InlineCompletionsHintsWidget = class InlineCompletionsHintsWidget extends Disposable {
  constructor(editor, model, instantiationService) {
    super();
    this.editor = editor;
    this.model = model;
    this.instantiationService = instantiationService;
    this.alwaysShowToolbar = observableFromEvent(this.editor.onDidChangeConfiguration, () => this.editor.getOption(62).showToolbar === 'always');
    this.sessionPosition = undefined;
    this.position = derived(this, reader => {
      const ghostText = this.model.read(reader)?.primaryGhostText.read(reader);
      if (!this.alwaysShowToolbar.read(reader) || !ghostText || ghostText.parts.length === 0) {
        this.sessionPosition = undefined;
        return null;
      }
      const firstColumn = ghostText.parts[0].column;
      if (this.sessionPosition && this.sessionPosition.lineNumber !== ghostText.lineNumber) {
        this.sessionPosition = undefined;
      }
      const position = new Position(ghostText.lineNumber, Math.min(firstColumn, this.sessionPosition?.column ?? Number.MAX_SAFE_INTEGER));
      this.sessionPosition = position;
      return position;
    });
    this._register(autorunWithStore((reader, store) => {
      const model = this.model.read(reader);
      if (!model || !this.alwaysShowToolbar.read(reader)) {
        return;
      }
      const contentWidget = store.add(this.instantiationService.createInstance(InlineSuggestionHintsContentWidget, this.editor, true, this.position, model.selectedInlineCompletionIndex, model.inlineCompletionsCount, model.activeCommands));
      editor.addContentWidget(contentWidget);
      store.add(toDisposable(() => editor.removeContentWidget(contentWidget)));
      store.add(autorun(reader => {
        const position = this.position.read(reader);
        if (!position) {
          return;
        }
        if (model.lastTriggerKind.read(reader) !== InlineCompletionTriggerKind.Explicit) {
          model.triggerExplicitly();
        }
      }));
    }));
  }
};
InlineCompletionsHintsWidget = __decorate([__param(2, IInstantiationService)], InlineCompletionsHintsWidget);
const inlineSuggestionHintsNextIcon = registerIcon('inline-suggestion-hints-next', Codicon.chevronRight, localizeWithPath(_moduleId, 0, 'Icon for show next parameter hint.'));
const inlineSuggestionHintsPreviousIcon = registerIcon('inline-suggestion-hints-previous', Codicon.chevronLeft, localizeWithPath(_moduleId, 1, 'Icon for show previous parameter hint.'));
let InlineSuggestionHintsContentWidget = class InlineSuggestionHintsContentWidget extends Disposable {
  static {
    InlineSuggestionHintsContentWidget_1 = this;
  }
  static {
    this._dropDownVisible = false;
  }
  static get dropDownVisible() {
    return this._dropDownVisible;
  }
  static {
    this.id = 0;
  }
  createCommandAction(commandId, label, iconClassName) {
    const action = new Action(commandId, label, iconClassName, true, () => this._commandService.executeCommand(commandId));
    const kb = this.keybindingService.lookupKeybinding(commandId, this._contextKeyService);
    let tooltip = label;
    if (kb) {
      tooltip = localizeWithPath(_moduleId, 2, '{0} ({1})', label, kb.getLabel());
    }
    action.tooltip = tooltip;
    return action;
  }
  constructor(editor, withBorder, _position, _currentSuggestionIdx, _suggestionCount, _extraCommands, _commandService, instantiationService, keybindingService, _contextKeyService, _menuService) {
    super();
    this.editor = editor;
    this.withBorder = withBorder;
    this._position = _position;
    this._currentSuggestionIdx = _currentSuggestionIdx;
    this._suggestionCount = _suggestionCount;
    this._extraCommands = _extraCommands;
    this._commandService = _commandService;
    this.keybindingService = keybindingService;
    this._contextKeyService = _contextKeyService;
    this._menuService = _menuService;
    this.id = `InlineSuggestionHintsContentWidget${InlineSuggestionHintsContentWidget_1.id++}`;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this.nodes = h('div.inlineSuggestionsHints', {
      className: this.withBorder ? '.withBorder' : ''
    }, [h('div@toolBar')]);
    this.previousAction = this.createCommandAction(showPreviousInlineSuggestionActionId, localizeWithPath(_moduleId, 3, 'Previous'), ThemeIcon.asClassName(inlineSuggestionHintsPreviousIcon));
    this.availableSuggestionCountAction = new Action('inlineSuggestionHints.availableSuggestionCount', '', undefined, false);
    this.nextAction = this.createCommandAction(showNextInlineSuggestionActionId, localizeWithPath(_moduleId, 4, 'Next'), ThemeIcon.asClassName(inlineSuggestionHintsNextIcon));
    this.inlineCompletionsActionsMenus = this._register(this._menuService.createMenu(MenuId.InlineCompletionsActions, this._contextKeyService));
    this.clearAvailableSuggestionCountLabelDebounced = this._register(new RunOnceScheduler(() => {
      this.availableSuggestionCountAction.label = '';
    }, 100));
    this.disableButtonsDebounced = this._register(new RunOnceScheduler(() => {
      this.previousAction.enabled = this.nextAction.enabled = false;
    }, 100));
    this.toolBar = this._register(instantiationService.createInstance(CustomizedMenuWorkbenchToolBar, this.nodes.toolBar, MenuId.InlineSuggestionToolbar, {
      menuOptions: {
        renderShortTitle: true
      },
      toolbarOptions: {
        primaryGroup: g => g.startsWith('primary')
      },
      actionViewItemProvider: (action, options) => {
        if (action instanceof MenuItemAction) {
          return instantiationService.createInstance(StatusBarViewItem, action, undefined);
        }
        if (action === this.availableSuggestionCountAction) {
          const a = new ActionViewItemWithClassName(undefined, action, {
            label: true,
            icon: false
          });
          a.setClass('availableSuggestionCount');
          return a;
        }
        return undefined;
      },
      telemetrySource: 'InlineSuggestionToolbar'
    }));
    this.toolBar.setPrependedPrimaryActions([this.previousAction, this.availableSuggestionCountAction, this.nextAction]);
    this._register(this.toolBar.onDidChangeDropdownVisibility(e => {
      InlineSuggestionHintsContentWidget_1._dropDownVisible = e;
    }));
    this._register(autorun(reader => {
      this._position.read(reader);
      this.editor.layoutContentWidget(this);
    }));
    this._register(autorun(reader => {
      const suggestionCount = this._suggestionCount.read(reader);
      const currentSuggestionIdx = this._currentSuggestionIdx.read(reader);
      if (suggestionCount !== undefined) {
        this.clearAvailableSuggestionCountLabelDebounced.cancel();
        this.availableSuggestionCountAction.label = `${currentSuggestionIdx + 1}/${suggestionCount}`;
      } else {
        this.clearAvailableSuggestionCountLabelDebounced.schedule();
      }
      if (suggestionCount !== undefined && suggestionCount > 1) {
        this.disableButtonsDebounced.cancel();
        this.previousAction.enabled = this.nextAction.enabled = true;
      } else {
        this.disableButtonsDebounced.schedule();
      }
    }));
    this._register(autorun(reader => {
      const extraCommands = this._extraCommands.read(reader);
      const extraActions = extraCommands.map(c => ({
        class: undefined,
        id: c.id,
        enabled: true,
        tooltip: c.tooltip || '',
        label: c.title,
        run: event => {
          return this._commandService.executeCommand(c.id);
        }
      }));
      for (const [_, group] of this.inlineCompletionsActionsMenus.getActions()) {
        for (const action of group) {
          if (action instanceof MenuItemAction) {
            extraActions.push(action);
          }
        }
      }
      if (extraActions.length > 0) {
        extraActions.unshift(new Separator());
      }
      this.toolBar.setAdditionalSecondaryActions(extraActions);
    }));
  }
  getId() {
    return this.id;
  }
  getDomNode() {
    return this.nodes.root;
  }
  getPosition() {
    return {
      position: this._position.get(),
      preference: [1, 2],
      positionAffinity: 3
    };
  }
};
InlineSuggestionHintsContentWidget = InlineSuggestionHintsContentWidget_1 = __decorate([__param(6, ICommandService), __param(7, IInstantiationService), __param(8, IKeybindingService), __param(9, IContextKeyService), __param(10, IMenuService)], InlineSuggestionHintsContentWidget);
class ActionViewItemWithClassName extends ActionViewItem {
  constructor() {
    super(...arguments);
    this._className = undefined;
  }
  setClass(className) {
    this._className = className;
  }
  render(container) {
    super.render(container);
    if (this._className) {
      container.classList.add(this._className);
    }
  }
  updateTooltip() {}
}
class StatusBarViewItem extends MenuEntryActionViewItem {
  updateLabel() {
    const kb = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!kb) {
      return super.updateLabel();
    }
    if (this.label) {
      const div = h('div.keybinding').root;
      const k = this._register(new KeybindingLabel(div, OS, {
        disableTitle: true,
        ...unthemedKeybindingLabelOptions
      }));
      k.set(kb);
      this.label.textContent = this._action.label;
      this.label.appendChild(div);
      this.label.classList.add('inlineSuggestionStatusBarItemLabel');
    }
  }
  updateTooltip() {}
}
let CustomizedMenuWorkbenchToolBar = class CustomizedMenuWorkbenchToolBar extends WorkbenchToolBar {
  constructor(container, menuId, options2, menuService, contextKeyService, contextMenuService, keybindingService, commandService, telemetryService) {
    super(container, {
      resetMenu: menuId,
      ...options2
    }, menuService, contextKeyService, contextMenuService, keybindingService, commandService, telemetryService);
    this.menuId = menuId;
    this.options2 = options2;
    this.menuService = menuService;
    this.contextKeyService = contextKeyService;
    this.menu = this._store.add(this.menuService.createMenu(this.menuId, this.contextKeyService, {
      emitEventsForSubmenuChanges: true
    }));
    this.additionalActions = [];
    this.prependedPrimaryActions = [];
    this._store.add(this.menu.onDidChange(() => this.updateToolbar()));
    this.updateToolbar();
  }
  updateToolbar() {
    const primary = [];
    const secondary = [];
    createAndFillInActionBarActions(this.menu, this.options2?.menuOptions, {
      primary,
      secondary
    }, this.options2?.toolbarOptions?.primaryGroup, this.options2?.toolbarOptions?.shouldInlineSubmenu, this.options2?.toolbarOptions?.useSeparatorsInPrimaryActions);
    secondary.push(...this.additionalActions);
    primary.unshift(...this.prependedPrimaryActions);
    this.setActions(primary, secondary);
  }
  setPrependedPrimaryActions(actions) {
    if (equals(this.prependedPrimaryActions, actions, (a, b) => a === b)) {
      return;
    }
    this.prependedPrimaryActions = actions;
    this.updateToolbar();
  }
  setAdditionalSecondaryActions(actions) {
    if (equals(this.additionalActions, actions, (a, b) => a === b)) {
      return;
    }
    this.additionalActions = actions;
    this.updateToolbar();
  }
};
CustomizedMenuWorkbenchToolBar = __decorate([__param(3, IMenuService), __param(4, IContextKeyService), __param(5, IContextMenuService), __param(6, IKeybindingService), __param(7, ICommandService), __param(8, ITelemetryService)], CustomizedMenuWorkbenchToolBar);
exports.CustomizedMenuWorkbenchToolBar = CustomizedMenuWorkbenchToolBar;
exports.InlineCompletionsHintsWidget = InlineCompletionsHintsWidget;
exports.InlineSuggestionHintsContentWidget = InlineSuggestionHintsContentWidget;