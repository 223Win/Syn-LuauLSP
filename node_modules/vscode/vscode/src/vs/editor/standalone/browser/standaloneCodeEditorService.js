const {
  __decorate,
  __param
} = require('../../../../../../external/tslib/tslib.es6.js');
const {
  windowOpenNoOpener
} = require('../../../base/browser/dom.js');
const {
  Schemas
} = require('../../../base/common/network.js');
const {
  AbstractCodeEditorService
} = require('../../browser/services/abstractCodeEditorService.js');
const {
  ICodeEditorService
} = require('../../browser/services/codeEditorService.js');
const {
  IContextKeyService
} = require('../../../platform/contextkey/common/contextkey.service.js');
const {
  registerSingleton
} = require('../../../platform/instantiation/common/extensions.js');
const {
  IThemeService
} = require('../../../platform/theme/common/themeService.service.js');
let StandaloneCodeEditorService = class StandaloneCodeEditorService extends AbstractCodeEditorService {
  constructor(contextKeyService, themeService) {
    super(themeService);
    this._register(this.onCodeEditorAdd(() => this._checkContextKey()));
    this._register(this.onCodeEditorRemove(() => this._checkContextKey()));
    this._editorIsOpen = contextKeyService.createKey('editorIsOpen', false);
    this._activeCodeEditor = null;
    this._register(this.registerCodeEditorOpenHandler(async (input, source, sideBySide) => {
      if (!source) {
        return null;
      }
      return this.doOpenEditor(source, input);
    }));
  }
  _checkContextKey() {
    let hasCodeEditor = false;
    for (const editor of this.listCodeEditors()) {
      if (!editor.isSimpleWidget) {
        hasCodeEditor = true;
        break;
      }
    }
    this._editorIsOpen.set(hasCodeEditor);
  }
  setActiveCodeEditor(activeCodeEditor) {
    this._activeCodeEditor = activeCodeEditor;
  }
  getActiveCodeEditor() {
    return this._activeCodeEditor;
  }
  doOpenEditor(editor, input) {
    const model = this.findModel(editor, input.resource);
    if (!model) {
      if (input.resource) {
        const schema = input.resource.scheme;
        if (schema === Schemas.http || schema === Schemas.https) {
          windowOpenNoOpener(input.resource.toString());
          return editor;
        }
      }
      return null;
    }
    const selection = input.options ? input.options.selection : null;
    if (selection) {
      if (typeof selection.endLineNumber === 'number' && typeof selection.endColumn === 'number') {
        editor.setSelection(selection);
        editor.revealRangeInCenter(selection, 1);
      } else {
        const pos = {
          lineNumber: selection.startLineNumber,
          column: selection.startColumn
        };
        editor.setPosition(pos);
        editor.revealPositionInCenter(pos, 1);
      }
    }
    return editor;
  }
  findModel(editor, resource) {
    const model = editor.getModel();
    if (model && model.uri.toString() !== resource.toString()) {
      return null;
    }
    return model;
  }
};
StandaloneCodeEditorService = __decorate([__param(0, IContextKeyService), __param(1, IThemeService)], StandaloneCodeEditorService);
registerSingleton(ICodeEditorService, StandaloneCodeEditorService, 0);
exports.StandaloneCodeEditorService = StandaloneCodeEditorService;