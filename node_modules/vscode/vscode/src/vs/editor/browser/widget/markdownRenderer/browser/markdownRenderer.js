const {
  __decorate,
  __param
} = require('../../../../../../../../external/tslib/tslib.es6.js');
const {
  renderMarkdown
} = require('../../../../../base/browser/markdownRenderer.js');
const {
  createTrustedTypesPolicy
} = require('../../../../../base/browser/trustedTypes.js');
const {
  onUnexpectedError
} = require('../../../../../base/common/errors.js');
const {
  Emitter
} = require('../../../../../base/common/event.js');
const {
  DisposableStore
} = require('../../../../../base/common/lifecycle.js');
const {} = require('./renderedMarkdown.css.js');
const {
  applyFontInfo
} = require('../../../config/domFontInfo.js');
const {
  ILanguageService
} = require('../../../../common/languages/language.js');
const {
  PLAINTEXT_LANGUAGE_ID
} = require('../../../../common/languages/modesRegistry.js');
const {
  tokenizeToString
} = require('../../../../common/languages/textToHtmlTokenizer.js');
const {
  IOpenerService
} = require('../../../../../platform/opener/common/opener.service.js');
var MarkdownRenderer_1;
let MarkdownRenderer = class MarkdownRenderer {
  static {
    MarkdownRenderer_1 = this;
  }
  static {
    this._ttpTokenizer = createTrustedTypesPolicy('tokenizeToString', {
      createHTML(html) {
        return html;
      }
    });
  }
  constructor(_options, _languageService, _openerService) {
    this._options = _options;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this._onDidRenderAsync = new Emitter();
    this.onDidRenderAsync = this._onDidRenderAsync.event;
  }
  dispose() {
    this._onDidRenderAsync.dispose();
  }
  render(markdown, options, markedOptions) {
    if (!markdown) {
      const element = document.createElement('span');
      return {
        element,
        dispose: () => {}
      };
    }
    const disposables = new DisposableStore();
    const rendered = disposables.add(renderMarkdown(markdown, {
      ...this._getRenderOptions(markdown, disposables),
      ...options
    }, markedOptions));
    rendered.element.classList.add('rendered-markdown');
    return {
      element: rendered.element,
      dispose: () => disposables.dispose()
    };
  }
  _getRenderOptions(markdown, disposables) {
    return {
      codeBlockRenderer: async (languageAlias, value) => {
        let languageId;
        if (languageAlias) {
          languageId = this._languageService.getLanguageIdByLanguageName(languageAlias);
        } else if (this._options.editor) {
          languageId = this._options.editor.getModel()?.getLanguageId();
        }
        if (!languageId) {
          languageId = PLAINTEXT_LANGUAGE_ID;
        }
        const html = await tokenizeToString(this._languageService, value, languageId);
        const element = document.createElement('span');
        element.innerHTML = MarkdownRenderer_1._ttpTokenizer?.createHTML(html) ?? html;
        if (this._options.editor) {
          const fontInfo = this._options.editor.getOption(50);
          applyFontInfo(element, fontInfo);
        } else if (this._options.codeBlockFontFamily) {
          element.style.fontFamily = this._options.codeBlockFontFamily;
        }
        if (this._options.codeBlockFontSize !== undefined) {
          element.style.fontSize = this._options.codeBlockFontSize;
        }
        return element;
      },
      asyncRenderCallback: () => this._onDidRenderAsync.fire(),
      actionHandler: {
        callback: link => openLinkFromMarkdown(this._openerService, link, markdown.isTrusted),
        disposables: disposables
      }
    };
  }
};
MarkdownRenderer = MarkdownRenderer_1 = __decorate([__param(1, ILanguageService), __param(2, IOpenerService)], MarkdownRenderer);
async function openLinkFromMarkdown(openerService, link, isTrusted) {
  try {
    return await openerService.open(link, {
      fromUserGesture: true,
      allowContributedOpeners: true,
      allowCommands: toAllowCommandsOption(isTrusted)
    });
  } catch (e) {
    onUnexpectedError(e);
    return false;
  }
}
function toAllowCommandsOption(isTrusted) {
  if (isTrusted === true) {
    return true;
  }
  if (isTrusted && Array.isArray(isTrusted.enabledCommands)) {
    return isTrusted.enabledCommands;
  }
  return false;
}
exports.MarkdownRenderer = MarkdownRenderer;
exports.openLinkFromMarkdown = openLinkFromMarkdown;