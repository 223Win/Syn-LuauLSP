const {
  __decorate,
  __param
} = require('../../../../../../../external/tslib/tslib.es6.js');
const {
  h,
  getWindow
} = require('../../../../base/browser/dom.js');
const {
  findLast
} = require('../../../../base/common/arraysFind.js');
const {
  onUnexpectedError
} = require('../../../../base/common/errors.js');
const {
  Event
} = require('../../../../base/common/event.js');
const {
  toDisposable
} = require('../../../../base/common/lifecycle.js');
const {
  observableValue,
  subtransaction,
  transaction
} = require('../../../../base/common/observableInternal/base.js');
const {
  derived,
  derivedDisposable
} = require('../../../../base/common/observableInternal/derived.js');
const {
  autorun,
  autorunWithStore
} = require('../../../../base/common/observableInternal/autorun.js');
const {
  recomputeInitiallyAndOnChange,
  observableFromEvent
} = require('../../../../base/common/observableInternal/utils.js');
const {} = require('../../../../base/common/cancellation.js');
const {} = require('../../../../base/common/arrays.js');
const {} = require('./style.css.js');
const {
  EditorExtensionsRegistry
} = require('../../editorExtensions.js');
const {
  ICodeEditorService
} = require('../../services/codeEditorService.js');
const {
  StableEditorScrollState
} = require('../../stableEditorScroll.js');
const {
  CodeEditorWidget
} = require('../codeEditor/codeEditorWidget.js');
const {
  AccessibleDiffViewerModelFromEditors,
  AccessibleDiffViewer
} = require('./components/accessibleDiffViewer.js');
const {
  DiffEditorDecorations
} = require('./components/diffEditorDecorations.js');
const {
  DiffEditorSash
} = require('./components/diffEditorSash.js');
const {
  DiffEditorViewZones
} = require('./components/diffEditorViewZones/diffEditorViewZones.js');
const {
  DiffEditorGutter
} = require('./features/gutterFeature.js');
const {
  HideUnchangedRegionsFeature
} = require('./features/hideUnchangedRegionsFeature.js');
const {
  MovedBlocksLinesFeature
} = require('./features/movedBlocksLinesFeature.js');
const {
  OverviewRulerFeature
} = require('./features/overviewRulerFeature.js');
const {
  RevertButtonsFeature
} = require('./features/revertButtonsFeature.js');
const {
  ObservableElementSizeObserver,
  bindContextKey,
  applyViewZones,
  applyStyle,
  translatePosition,
  readHotReloadableExport
} = require('./utils.js');
const {
  Position
} = require('../../../common/core/position.js');
const {
  Range
} = require('../../../common/core/range.js');
const {
  EditorType
} = require('../../../common/editorCommon.js');
const {
  EditorContextKeys
} = require('../../../common/editorContextKeys.js');
const {
  AccessibilitySignal
} = require('../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js');
const {
  IAccessibilitySignalService
} = require('../../../../platform/accessibilitySignal/browser/accessibilitySignalService.service.js');
const {
  IContextKeyService
} = require('../../../../platform/contextkey/common/contextkey.service.js');
const {
  IInstantiationService
} = require('../../../../platform/instantiation/common/instantiation.js');
const {
  ServiceCollection
} = require('../../../../platform/instantiation/common/serviceCollection.js');
const {
  IEditorProgressService
} = require('../../../../platform/progress/common/progress.service.js');
const {
  DiffEditorEditors
} = require('./components/diffEditorEditors.js');
const {
  DelegatingEditor
} = require('./delegatingEditorImpl.js');
const {
  DiffEditorOptions
} = require('./diffEditorOptions.js');
const {
  DiffEditorViewModel
} = require('./diffEditorViewModel.js');
let DiffEditorWidget = class DiffEditorWidget extends DelegatingEditor {
  static {
    this.ENTIRE_DIFF_OVERVIEW_WIDTH = OverviewRulerFeature.ENTIRE_DIFF_OVERVIEW_WIDTH;
  }
  get onDidContentSizeChange() {
    return this._editors.onDidContentSizeChange;
  }
  get collapseUnchangedRegions() {
    return this._options.hideUnchangedRegions.get();
  }
  constructor(_domElement, options, codeEditorWidgetOptions, _parentContextKeyService, _parentInstantiationService, codeEditorService, _accessibilitySignalService, _editorProgressService) {
    super();
    this._domElement = _domElement;
    this._parentContextKeyService = _parentContextKeyService;
    this._parentInstantiationService = _parentInstantiationService;
    this._accessibilitySignalService = _accessibilitySignalService;
    this._editorProgressService = _editorProgressService;
    this.elements = h('div.monaco-diff-editor.side-by-side', {
      style: {
        position: 'relative',
        height: '100%'
      }
    }, [h('div.editor.original@original', {
      style: {
        position: 'absolute',
        height: '100%'
      }
    }), h('div.editor.modified@modified', {
      style: {
        position: 'absolute',
        height: '100%'
      }
    }), h('div.accessibleDiffViewer@accessibleDiffViewer', {
      style: {
        position: 'absolute',
        height: '100%'
      }
    })]);
    this._diffModel = observableValue(this, undefined);
    this._shouldDisposeDiffModel = false;
    this.onDidChangeModel = Event.fromObservableLight(this._diffModel);
    this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._domElement));
    this._instantiationService = this._parentInstantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService]));
    this._boundarySashes = observableValue(this, undefined);
    this._accessibleDiffViewerShouldBeVisible = observableValue(this, false);
    this._accessibleDiffViewerVisible = derived(this, reader => this._options.onlyShowAccessibleDiffViewer.read(reader) ? true : this._accessibleDiffViewerShouldBeVisible.read(reader));
    this._movedBlocksLinesPart = observableValue(this, undefined);
    this._layoutInfo = derived(this, reader => {
      const fullWidth = this._rootSizeObserver.width.read(reader);
      const fullHeight = this._rootSizeObserver.height.read(reader);
      const sash = this._sash.read(reader);
      const gutter = this._gutter.read(reader);
      const gutterWidth = gutter?.width.read(reader) ?? 0;
      const overviewRulerPartWidth = this._overviewRulerPart.read(reader)?.width ?? 0;
      let originalLeft, originalWidth, modifiedLeft, modifiedWidth, gutterLeft;
      const sideBySide = !!sash;
      if (sideBySide) {
        const sashLeft = sash.sashLeft.read(reader);
        const movedBlocksLinesWidth = this._movedBlocksLinesPart.read(reader)?.width.read(reader) ?? 0;
        originalLeft = 0;
        originalWidth = sashLeft - gutterWidth - movedBlocksLinesWidth;
        gutterLeft = sashLeft - gutterWidth;
        modifiedLeft = sashLeft;
        modifiedWidth = fullWidth - modifiedLeft - overviewRulerPartWidth;
      } else {
        gutterLeft = 0;
        originalLeft = gutterWidth;
        originalWidth = Math.max(5, this._editors.original.getLayoutInfo().decorationsLeft);
        modifiedLeft = gutterWidth + originalWidth;
        modifiedWidth = fullWidth - modifiedLeft - overviewRulerPartWidth;
      }
      this.elements.original.style.left = originalLeft + 'px';
      this.elements.original.style.width = originalWidth + 'px';
      this._editors.original.layout({
        width: originalWidth,
        height: fullHeight
      }, true);
      gutter?.layout(gutterLeft);
      this.elements.modified.style.left = modifiedLeft + 'px';
      this.elements.modified.style.width = modifiedWidth + 'px';
      this._editors.modified.layout({
        width: modifiedWidth,
        height: fullHeight
      }, true);
      return {
        modifiedEditor: this._editors.modified.getLayoutInfo(),
        originalEditor: this._editors.original.getLayoutInfo()
      };
    });
    this._diffValue = this._diffModel.map((m, r) => m?.diff.read(r));
    this.onDidUpdateDiff = Event.fromObservableLight(this._diffValue);
    codeEditorService.willCreateDiffEditor();
    this._contextKeyService.createKey('isInDiffEditor', true);
    this.elements.root.classList.toggle('standalone', codeEditorWidgetOptions.isStandaloneEditor || false);
    this._domElement.appendChild(this.elements.root);
    this._register(toDisposable(() => this._domElement.removeChild(this.elements.root)));
    this._rootSizeObserver = this._register(new ObservableElementSizeObserver(this.elements.root, options.dimension));
    this._rootSizeObserver.setAutomaticLayout(options.automaticLayout ?? false);
    this._options = this._instantiationService.createInstance(DiffEditorOptions, options);
    this._register(autorun(reader => {
      this._options.setWidth(this._rootSizeObserver.width.read(reader));
    }));
    this._contextKeyService.createKey(EditorContextKeys.isEmbeddedDiffEditor.key, false);
    this._register(bindContextKey(EditorContextKeys.isEmbeddedDiffEditor, this._contextKeyService, reader => this._options.isInEmbeddedEditor.read(reader)));
    this._register(bindContextKey(EditorContextKeys.comparingMovedCode, this._contextKeyService, reader => !!this._diffModel.read(reader)?.movedTextToCompare.read(reader)));
    this._register(bindContextKey(EditorContextKeys.diffEditorRenderSideBySideInlineBreakpointReached, this._contextKeyService, reader => this._options.couldShowInlineViewBecauseOfSize.read(reader)));
    this._register(bindContextKey(EditorContextKeys.diffEditorInlineMode, this._contextKeyService, reader => !this._options.renderSideBySide.read(reader)));
    this._register(bindContextKey(EditorContextKeys.hasChanges, this._contextKeyService, reader => (this._diffModel.read(reader)?.diff.read(reader)?.mappings.length ?? 0) > 0));
    this._editors = this._register(this._instantiationService.createInstance(DiffEditorEditors, this.elements.original, this.elements.modified, this._options, codeEditorWidgetOptions, (i, c, o, o2) => this._createInnerEditor(i, c, o, o2)));
    this._register(bindContextKey(EditorContextKeys.diffEditorOriginalWritable, this._contextKeyService, reader => this._options.originalEditable.read(reader)));
    this._register(bindContextKey(EditorContextKeys.diffEditorModifiedWritable, this._contextKeyService, reader => !this._options.readOnly.read(reader)));
    this._register(bindContextKey(EditorContextKeys.diffEditorOriginalUri, this._contextKeyService, reader => this._diffModel.read(reader)?.model.original.uri.toString() ?? ''));
    this._register(bindContextKey(EditorContextKeys.diffEditorModifiedUri, this._contextKeyService, reader => this._diffModel.read(reader)?.model.modified.uri.toString() ?? ''));
    this._overviewRulerPart = derivedDisposable(this, reader => !this._options.renderOverviewRuler.read(reader) ? undefined : this._instantiationService.createInstance(readHotReloadableExport(OverviewRulerFeature, reader), this._editors, this.elements.root, this._diffModel, this._rootSizeObserver.width, this._rootSizeObserver.height, this._layoutInfo.map(i => i.modifiedEditor))).recomputeInitiallyAndOnChange(this._store);
    this._sash = derivedDisposable(this, reader => {
      const showSash = this._options.renderSideBySide.read(reader);
      this.elements.root.classList.toggle('side-by-side', showSash);
      return !showSash ? undefined : new DiffEditorSash(this._options, this.elements.root, {
        height: this._rootSizeObserver.height,
        width: this._rootSizeObserver.width.map((w, reader) => w - (this._overviewRulerPart.read(reader)?.width ?? 0))
      }, this._boundarySashes);
    }).recomputeInitiallyAndOnChange(this._store);
    const unchangedRangesFeature = derivedDisposable(this, reader => this._instantiationService.createInstance(readHotReloadableExport(HideUnchangedRegionsFeature, reader), this._editors, this._diffModel, this._options)).recomputeInitiallyAndOnChange(this._store);
    derivedDisposable(this, reader => this._instantiationService.createInstance(readHotReloadableExport(DiffEditorDecorations, reader), this._editors, this._diffModel, this._options, this)).recomputeInitiallyAndOnChange(this._store);
    const origViewZoneIdsToIgnore = new Set();
    const modViewZoneIdsToIgnore = new Set();
    let isUpdatingViewZones = false;
    const viewZoneManager = derivedDisposable(this, reader => this._instantiationService.createInstance(readHotReloadableExport(DiffEditorViewZones, reader), getWindow(this._domElement), this._editors, this._diffModel, this._options, this, () => isUpdatingViewZones || unchangedRangesFeature.get().isUpdatingHiddenAreas, origViewZoneIdsToIgnore, modViewZoneIdsToIgnore)).recomputeInitiallyAndOnChange(this._store);
    const originalViewZones = derived(this, reader => {
      const orig = viewZoneManager.read(reader).viewZones.read(reader).orig;
      const orig2 = unchangedRangesFeature.read(reader).viewZones.read(reader).origViewZones;
      return orig.concat(orig2);
    });
    const modifiedViewZones = derived(this, reader => {
      const mod = viewZoneManager.read(reader).viewZones.read(reader).mod;
      const mod2 = unchangedRangesFeature.read(reader).viewZones.read(reader).modViewZones;
      return mod.concat(mod2);
    });
    this._register(applyViewZones(this._editors.original, originalViewZones, isUpdatingOrigViewZones => {
      isUpdatingViewZones = isUpdatingOrigViewZones;
    }, origViewZoneIdsToIgnore));
    let scrollState;
    this._register(applyViewZones(this._editors.modified, modifiedViewZones, isUpdatingModViewZones => {
      isUpdatingViewZones = isUpdatingModViewZones;
      if (isUpdatingViewZones) {
        scrollState = StableEditorScrollState.capture(this._editors.modified);
      } else {
        scrollState?.restore(this._editors.modified);
        scrollState = undefined;
      }
    }, modViewZoneIdsToIgnore));
    this._accessibleDiffViewer = derivedDisposable(this, reader => this._instantiationService.createInstance(readHotReloadableExport(AccessibleDiffViewer, reader), this.elements.accessibleDiffViewer, this._accessibleDiffViewerVisible, (visible, tx) => this._accessibleDiffViewerShouldBeVisible.set(visible, tx), this._options.onlyShowAccessibleDiffViewer.map(v => !v), this._rootSizeObserver.width, this._rootSizeObserver.height, this._diffModel.map((m, r) => m?.diff.read(r)?.mappings.map(m => m.lineRangeMapping)), new AccessibleDiffViewerModelFromEditors(this._editors))).recomputeInitiallyAndOnChange(this._store);
    const visibility = this._accessibleDiffViewerVisible.map(v => v ? 'hidden' : 'visible');
    this._register(applyStyle(this.elements.modified, {
      visibility
    }));
    this._register(applyStyle(this.elements.original, {
      visibility
    }));
    this._createDiffEditorContributions();
    codeEditorService.addDiffEditor(this);
    this._gutter = derivedDisposable(this, reader => {
      return this._options.shouldRenderGutterMenu.read(reader) ? this._instantiationService.createInstance(readHotReloadableExport(DiffEditorGutter, reader), this.elements.root, this._diffModel, this._editors) : undefined;
    });
    this._register(recomputeInitiallyAndOnChange(this._layoutInfo));
    derivedDisposable(this, reader => new (readHotReloadableExport(MovedBlocksLinesFeature, reader))(this.elements.root, this._diffModel, this._layoutInfo.map(i => i.originalEditor), this._layoutInfo.map(i => i.modifiedEditor), this._editors)).recomputeInitiallyAndOnChange(this._store, value => {
      this._movedBlocksLinesPart.set(value, undefined);
    });
    this._register(Event.runAndSubscribe(this._editors.modified.onDidChangeCursorPosition, e => this._handleCursorPositionChange(e, true)));
    this._register(Event.runAndSubscribe(this._editors.original.onDidChangeCursorPosition, e => this._handleCursorPositionChange(e, false)));
    const isInitializingDiff = this._diffModel.map(this, (m, reader) => {
      if (!m) {
        return undefined;
      }
      return m.diff.read(reader) === undefined && !m.isDiffUpToDate.read(reader);
    });
    this._register(autorunWithStore((reader, store) => {
      if (isInitializingDiff.read(reader) === true) {
        const r = this._editorProgressService.show(true, 1000);
        store.add(toDisposable(() => r.done()));
      }
    }));
    this._register(toDisposable(() => {
      if (this._shouldDisposeDiffModel) {
        this._diffModel.get()?.dispose();
      }
    }));
    this._register(autorunWithStore((reader, store) => {
      store.add(new (readHotReloadableExport(RevertButtonsFeature, reader))(this._editors, this._diffModel, this._options, this));
    }));
  }
  getViewWidth() {
    return this._rootSizeObserver.width.get();
  }
  getContentHeight() {
    return this._editors.modified.getContentHeight();
  }
  _createInnerEditor(instantiationService, container, options, editorWidgetOptions) {
    const editor = instantiationService.createInstance(CodeEditorWidget, container, options, editorWidgetOptions);
    return editor;
  }
  _createDiffEditorContributions() {
    const contributions = EditorExtensionsRegistry.getDiffEditorContributions();
    for (const desc of contributions) {
      try {
        this._register(this._instantiationService.createInstance(desc.ctor, this));
      } catch (err) {
        onUnexpectedError(err);
      }
    }
  }
  get _targetEditor() {
    return this._editors.modified;
  }
  getEditorType() {
    return EditorType.IDiffEditor;
  }
  onVisible() {
    this._editors.original.onVisible();
    this._editors.modified.onVisible();
  }
  onHide() {
    this._editors.original.onHide();
    this._editors.modified.onHide();
  }
  layout(dimension) {
    this._rootSizeObserver.observe(dimension);
  }
  hasTextFocus() {
    return this._editors.original.hasTextFocus() || this._editors.modified.hasTextFocus();
  }
  saveViewState() {
    const originalViewState = this._editors.original.saveViewState();
    const modifiedViewState = this._editors.modified.saveViewState();
    return {
      original: originalViewState,
      modified: modifiedViewState,
      modelState: this._diffModel.get()?.serializeState()
    };
  }
  restoreViewState(s) {
    if (s && s.original && s.modified) {
      const diffEditorState = s;
      this._editors.original.restoreViewState(diffEditorState.original);
      this._editors.modified.restoreViewState(diffEditorState.modified);
      if (diffEditorState.modelState) {
        this._diffModel.get()?.restoreSerializedState(diffEditorState.modelState);
      }
    }
  }
  handleInitialized() {
    this._editors.original.handleInitialized();
    this._editors.modified.handleInitialized();
  }
  createViewModel(model) {
    return this._instantiationService.createInstance(DiffEditorViewModel, model, this._options);
  }
  getModel() {
    return this._diffModel.get()?.model ?? null;
  }
  setModel(model, tx) {
    if (!model && this._diffModel.get()) {
      this._accessibleDiffViewer.get().close();
    }
    const vm = model ? 'model' in model ? {
      model,
      shouldDispose: false
    } : {
      model: this.createViewModel(model),
      shouldDispose: true
    } : undefined;
    if (this._diffModel.get() !== vm?.model) {
      subtransaction(tx, tx => {
        observableFromEvent.batchEventsGlobally(tx, () => {
          this._editors.original.setModel(vm ? vm.model.model.original : null);
          this._editors.modified.setModel(vm ? vm.model.model.modified : null);
        });
        const prevValue = this._diffModel.get();
        const shouldDispose = this._shouldDisposeDiffModel;
        this._shouldDisposeDiffModel = vm?.shouldDispose ?? false;
        this._diffModel.set(vm?.model, tx);
        if (shouldDispose) {
          prevValue?.dispose();
        }
      });
    }
  }
  updateOptions(changedOptions) {
    this._options.updateOptions(changedOptions);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getOriginalEditor() {
    return this._editors.original;
  }
  getModifiedEditor() {
    return this._editors.modified;
  }
  setBoundarySashes(sashes) {
    this._boundarySashes.set(sashes, undefined);
  }
  get ignoreTrimWhitespace() {
    return this._options.ignoreTrimWhitespace.get();
  }
  get maxComputationTime() {
    return this._options.maxComputationTimeMs.get();
  }
  get renderSideBySide() {
    return this._options.renderSideBySide.get();
  }
  getLineChanges() {
    const diffState = this._diffModel.get()?.diff.get();
    if (!diffState) {
      return null;
    }
    return toLineChanges(diffState);
  }
  getDiffComputationResult() {
    const diffState = this._diffModel.get()?.diff.get();
    if (!diffState) {
      return null;
    }
    return {
      changes: this.getLineChanges(),
      changes2: diffState.mappings.map(m => m.lineRangeMapping),
      identical: diffState.identical,
      quitEarly: diffState.quitEarly
    };
  }
  revert(diff) {
    const model = this._diffModel.get();
    if (!model || !model.isDiffUpToDate.get()) {
      return;
    }
    this._editors.modified.executeEdits('diffEditor', [{
      range: diff.modified.toExclusiveRange(),
      text: model.model.original.getValueInRange(diff.original.toExclusiveRange())
    }]);
  }
  revertRangeMappings(diffs) {
    const model = this._diffModel.get();
    if (!model || !model.isDiffUpToDate.get()) {
      return;
    }
    const changes = diffs.map(c => ({
      range: c.modifiedRange,
      text: model.model.original.getValueInRange(c.originalRange)
    }));
    this._editors.modified.executeEdits('diffEditor', changes);
  }
  _goTo(diff) {
    this._editors.modified.setPosition(new Position(diff.lineRangeMapping.modified.startLineNumber, 1));
    this._editors.modified.revealRangeInCenter(diff.lineRangeMapping.modified.toExclusiveRange());
  }
  goToDiff(target) {
    const diffs = this._diffModel.get()?.diff.get()?.mappings;
    if (!diffs || diffs.length === 0) {
      return;
    }
    const curLineNumber = this._editors.modified.getPosition().lineNumber;
    let diff;
    if (target === 'next') {
      diff = diffs.find(d => d.lineRangeMapping.modified.startLineNumber > curLineNumber) ?? diffs[0];
    } else {
      diff = findLast(diffs, d => d.lineRangeMapping.modified.startLineNumber < curLineNumber) ?? diffs[diffs.length - 1];
    }
    this._goTo(diff);
    if (diff.lineRangeMapping.modified.isEmpty) {
      this._accessibilitySignalService.playSignal(AccessibilitySignal.diffLineDeleted, {
        source: 'diffEditor.goToDiff'
      });
    } else if (diff.lineRangeMapping.original.isEmpty) {
      this._accessibilitySignalService.playSignal(AccessibilitySignal.diffLineInserted, {
        source: 'diffEditor.goToDiff'
      });
    } else if (diff) {
      this._accessibilitySignalService.playSignal(AccessibilitySignal.diffLineModified, {
        source: 'diffEditor.goToDiff'
      });
    }
  }
  revealFirstDiff() {
    const diffModel = this._diffModel.get();
    if (!diffModel) {
      return;
    }
    this.waitForDiff().then(() => {
      const diffs = diffModel.diff.get()?.mappings;
      if (!diffs || diffs.length === 0) {
        return;
      }
      this._goTo(diffs[0]);
    });
  }
  accessibleDiffViewerNext() {
    this._accessibleDiffViewer.get().next();
  }
  accessibleDiffViewerPrev() {
    this._accessibleDiffViewer.get().prev();
  }
  async waitForDiff() {
    const diffModel = this._diffModel.get();
    if (!diffModel) {
      return;
    }
    await diffModel.waitForDiff();
  }
  mapToOtherSide() {
    const isModifiedFocus = this._editors.modified.hasWidgetFocus();
    const source = isModifiedFocus ? this._editors.modified : this._editors.original;
    const destination = isModifiedFocus ? this._editors.original : this._editors.modified;
    let destinationSelection;
    const sourceSelection = source.getSelection();
    if (sourceSelection) {
      const mappings = this._diffModel.get()?.diff.get()?.mappings.map(m => isModifiedFocus ? m.lineRangeMapping.flip() : m.lineRangeMapping);
      if (mappings) {
        const newRange1 = translatePosition(sourceSelection.getStartPosition(), mappings);
        const newRange2 = translatePosition(sourceSelection.getEndPosition(), mappings);
        destinationSelection = Range.plusRange(newRange1, newRange2);
      }
    }
    return {
      destination,
      destinationSelection
    };
  }
  switchSide() {
    const {
      destination,
      destinationSelection
    } = this.mapToOtherSide();
    destination.focus();
    if (destinationSelection) {
      destination.setSelection(destinationSelection);
    }
  }
  exitCompareMove() {
    const model = this._diffModel.get();
    if (!model) {
      return;
    }
    model.movedTextToCompare.set(undefined, undefined);
  }
  collapseAllUnchangedRegions() {
    const unchangedRegions = this._diffModel.get()?.unchangedRegions.get();
    if (!unchangedRegions) {
      return;
    }
    transaction(tx => {
      for (const region of unchangedRegions) {
        region.collapseAll(tx);
      }
    });
  }
  showAllUnchangedRegions() {
    const unchangedRegions = this._diffModel.get()?.unchangedRegions.get();
    if (!unchangedRegions) {
      return;
    }
    transaction(tx => {
      for (const region of unchangedRegions) {
        region.showAll(tx);
      }
    });
  }
  _handleCursorPositionChange(e, isModifiedEditor) {
    if (e?.reason === 3) {
      const diff = this._diffModel.get()?.diff.get()?.mappings.find(m => isModifiedEditor ? m.lineRangeMapping.modified.contains(e.position.lineNumber) : m.lineRangeMapping.original.contains(e.position.lineNumber));
      if (diff?.lineRangeMapping.modified.isEmpty) {
        this._accessibilitySignalService.playSignal(AccessibilitySignal.diffLineDeleted, {
          source: 'diffEditor.cursorPositionChanged'
        });
      } else if (diff?.lineRangeMapping.original.isEmpty) {
        this._accessibilitySignalService.playSignal(AccessibilitySignal.diffLineInserted, {
          source: 'diffEditor.cursorPositionChanged'
        });
      } else if (diff) {
        this._accessibilitySignalService.playSignal(AccessibilitySignal.diffLineModified, {
          source: 'diffEditor.cursorPositionChanged'
        });
      }
    }
  }
};
DiffEditorWidget = __decorate([__param(3, IContextKeyService), __param(4, IInstantiationService), __param(5, ICodeEditorService), __param(6, IAccessibilitySignalService), __param(7, IEditorProgressService)], DiffEditorWidget);
function toLineChanges(state) {
  return state.mappings.map(x => {
    const m = x.lineRangeMapping;
    let originalStartLineNumber;
    let originalEndLineNumber;
    let modifiedStartLineNumber;
    let modifiedEndLineNumber;
    let innerChanges = m.innerChanges;
    if (m.original.isEmpty) {
      originalStartLineNumber = m.original.startLineNumber - 1;
      originalEndLineNumber = 0;
      innerChanges = undefined;
    } else {
      originalStartLineNumber = m.original.startLineNumber;
      originalEndLineNumber = m.original.endLineNumberExclusive - 1;
    }
    if (m.modified.isEmpty) {
      modifiedStartLineNumber = m.modified.startLineNumber - 1;
      modifiedEndLineNumber = 0;
      innerChanges = undefined;
    } else {
      modifiedStartLineNumber = m.modified.startLineNumber;
      modifiedEndLineNumber = m.modified.endLineNumberExclusive - 1;
    }
    return {
      originalStartLineNumber,
      originalEndLineNumber,
      modifiedStartLineNumber,
      modifiedEndLineNumber,
      charChanges: innerChanges?.map(m => ({
        originalStartLineNumber: m.originalRange.startLineNumber,
        originalStartColumn: m.originalRange.startColumn,
        originalEndLineNumber: m.originalRange.endLineNumber,
        originalEndColumn: m.originalRange.endColumn,
        modifiedStartLineNumber: m.modifiedRange.startLineNumber,
        modifiedStartColumn: m.modifiedRange.startColumn,
        modifiedEndLineNumber: m.modifiedRange.endLineNumber,
        modifiedEndColumn: m.modifiedRange.endColumn
      }))
    };
  });
}
exports.DiffEditorWidget = DiffEditorWidget;