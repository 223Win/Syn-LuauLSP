const {
  __decorate,
  __param
} = require('../../../../../../external/tslib/tslib.es6.js');
const {
  isSafari,
  isWebkitWebView
} = require('../../../base/browser/browser.js');
const {
  onDidRegisterWindow,
  addDisposableListener,
  getActiveDocument,
  $
} = require('../../../base/browser/dom.js');
const {
  mainWindow
} = require('../../../base/browser/window.js');
const {
  DeferredPromise
} = require('../../../base/common/async.js');
const {
  Event
} = require('../../../base/common/event.js');
const {
  hash
} = require('../../../base/common/hash.js');
const {
  Disposable
} = require('../../../base/common/lifecycle.js');
const {
  ILayoutService
} = require('../../layout/browser/layoutService.service.js');
const {
  ILogService
} = require('../../log/common/log.service.js');
var BrowserClipboardService_1;
let BrowserClipboardService = class BrowserClipboardService extends Disposable {
  static {
    BrowserClipboardService_1 = this;
  }
  constructor(layoutService, logService) {
    super();
    this.layoutService = layoutService;
    this.logService = logService;
    this.mapTextToType = new Map();
    this.findText = '';
    this.resources = [];
    this.resourcesStateHash = undefined;
    if (isSafari || isWebkitWebView) {
      this.installWebKitWriteTextWorkaround();
    }
    this._register(Event.runAndSubscribe(onDidRegisterWindow, ({
      window,
      disposables
    }) => {
      disposables.add(addDisposableListener(window.document, 'copy', () => this.clearResources()));
    }, {
      window: mainWindow,
      disposables: this._store
    }));
  }
  installWebKitWriteTextWorkaround() {
    const handler = () => {
      const currentWritePromise = new DeferredPromise();
      if (this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled) {
        this.webKitPendingClipboardWritePromise.cancel();
      }
      this.webKitPendingClipboardWritePromise = currentWritePromise;
      navigator.clipboard.write([new ClipboardItem({
        'text/plain': currentWritePromise.p
      })]).catch(async err => {
        if (!(err instanceof Error) || err.name !== 'NotAllowedError' || !currentWritePromise.isRejected) {
          this.logService.error(err);
        }
      });
    };
    this._register(Event.runAndSubscribe(this.layoutService.onDidAddContainer, ({
      container,
      disposables
    }) => {
      disposables.add(addDisposableListener(container, 'click', handler));
      disposables.add(addDisposableListener(container, 'keydown', handler));
    }, {
      container: this.layoutService.mainContainer,
      disposables: this._store
    }));
  }
  async writeText(text, type) {
    this.writeResources([]);
    if (type) {
      this.mapTextToType.set(type, text);
      return;
    }
    if (this.webKitPendingClipboardWritePromise) {
      return this.webKitPendingClipboardWritePromise.complete(text);
    }
    try {
      return await navigator.clipboard.writeText(text);
    } catch (error) {
      console.error(error);
    }
    this.fallbackWriteText(text);
  }
  fallbackWriteText(text) {
    const activeDocument = getActiveDocument();
    const activeElement = activeDocument.activeElement;
    const textArea = activeDocument.body.appendChild($('textarea', {
      'aria-hidden': true
    }));
    textArea.style.height = '1px';
    textArea.style.width = '1px';
    textArea.style.position = 'absolute';
    textArea.value = text;
    textArea.focus();
    textArea.select();
    activeDocument.execCommand('copy');
    if (activeElement instanceof HTMLElement) {
      activeElement.focus();
    }
    activeDocument.body.removeChild(textArea);
  }
  async readText(type) {
    if (type) {
      return this.mapTextToType.get(type) || '';
    }
    try {
      return await navigator.clipboard.readText();
    } catch (error) {
      console.error(error);
    }
    return '';
  }
  async readFindText() {
    return this.findText;
  }
  async writeFindText(text) {
    this.findText = text;
  }
  static {
    this.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1000;
  }
  async writeResources(resources) {
    if (resources.length === 0) {
      this.clearResources();
    } else {
      this.resources = resources;
      this.resourcesStateHash = await this.computeResourcesStateHash();
    }
  }
  async readResources() {
    const resourcesStateHash = await this.computeResourcesStateHash();
    if (this.resourcesStateHash !== resourcesStateHash) {
      this.clearResources();
    }
    return this.resources;
  }
  async computeResourcesStateHash() {
    if (this.resources.length === 0) {
      return undefined;
    }
    const clipboardText = await this.readText();
    return hash(clipboardText.substring(0, BrowserClipboardService_1.MAX_RESOURCE_STATE_SOURCE_LENGTH));
  }
  async hasResources() {
    return this.resources.length > 0;
  }
  clearResources() {
    this.resources = [];
    this.resourcesStateHash = undefined;
  }
};
BrowserClipboardService = BrowserClipboardService_1 = __decorate([__param(0, ILayoutService), __param(1, ILogService)], BrowserClipboardService);
exports.BrowserClipboardService = BrowserClipboardService;