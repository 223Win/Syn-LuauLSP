const {
  reset,
  $,
  EventType,
  createCSSRule,
  asCSSUrl,
  isEventLike,
  EventHelper
} = require('../../../base/browser/dom.js');
const {
  DomEmitter
} = require('../../../base/browser/event.js');
const {
  Event
} = require('../../../base/common/event.js');
const {
  StandardKeyboardEvent
} = require('../../../base/browser/keyboardEvent.js');
const {
  Gesture,
  EventType$1
} = require('../../../base/browser/touch.js');
const {
  renderLabelWithIcons
} = require('../../../base/browser/ui/iconLabel/iconLabels.js');
const {
  IdGenerator
} = require('../../../base/common/idGenerator.js');
const {
  parseLinkedText
} = require('../../../base/common/linkedText.js');
const {} = require('./media/quickInput.css.js');
const {
  localizeWithPath
} = require('../../../nls.js');
const _moduleId = "vs/platform/quickinput/browser/quickInputUtils";
const iconPathToClass = {};
const iconClassGenerator = new IdGenerator('quick-input-button-icon-');
function getIconClass(iconPath) {
  if (!iconPath) {
    return undefined;
  }
  let iconClass;
  const key = iconPath.dark.toString();
  if (iconPathToClass[key]) {
    iconClass = iconPathToClass[key];
  } else {
    iconClass = iconClassGenerator.nextId();
    createCSSRule(`.${iconClass}, .hc-light .${iconClass}`, `background-image: ${asCSSUrl(iconPath.light || iconPath.dark)}`);
    createCSSRule(`.vs-dark .${iconClass}, .hc-black .${iconClass}`, `background-image: ${asCSSUrl(iconPath.dark)}`);
    iconPathToClass[key] = iconClass;
  }
  return iconClass;
}
function quickInputButtonToAction(button, id, run) {
  let cssClasses = button.iconClass || getIconClass(button.iconPath);
  if (button.alwaysVisible) {
    cssClasses = cssClasses ? `${cssClasses} always-visible` : 'always-visible';
  }
  return {
    id,
    label: '',
    tooltip: button.tooltip || '',
    class: cssClasses,
    enabled: true,
    run
  };
}
function renderQuickInputDescription(description, container, actionHandler) {
  reset(container);
  const parsed = parseLinkedText(description);
  let tabIndex = 0;
  for (const node of parsed.nodes) {
    if (typeof node === 'string') {
      container.append(...renderLabelWithIcons(node));
    } else {
      let title = node.title;
      if (!title && node.href.startsWith('command:')) {
        title = localizeWithPath(_moduleId, 0, "Click to execute command '{0}'", node.href.substring('command:'.length));
      } else if (!title) {
        title = node.href;
      }
      const anchor = $('a', {
        href: node.href,
        title,
        tabIndex: tabIndex++
      }, node.label);
      anchor.style.textDecoration = 'underline';
      const handleOpen = e => {
        if (isEventLike(e)) {
          EventHelper.stop(e, true);
        }
        actionHandler.callback(node.href);
      };
      const onClick = actionHandler.disposables.add(new DomEmitter(anchor, EventType.CLICK)).event;
      const onKeydown = actionHandler.disposables.add(new DomEmitter(anchor, EventType.KEY_DOWN)).event;
      const onSpaceOrEnter = Event.chain(onKeydown, $ => $.filter(e => {
        const event = new StandardKeyboardEvent(e);
        return event.equals(10) || event.equals(3);
      }));
      actionHandler.disposables.add(Gesture.addTarget(anchor));
      const onTap = actionHandler.disposables.add(new DomEmitter(anchor, EventType$1.Tap)).event;
      Event.any(onClick, onTap, onSpaceOrEnter)(handleOpen, null, actionHandler.disposables);
      container.appendChild(anchor);
    }
  }
}
exports.quickInputButtonToAction = quickInputButtonToAction;
exports.renderQuickInputDescription = renderQuickInputDescription;