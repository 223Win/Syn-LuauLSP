const {
  __decorate,
  __param
} = require('../../../../../../external/tslib/tslib.es6.js');
const {
  CancellationToken
} = require('../../../base/common/cancellation.js');
const {
  Emitter
} = require('../../../base/common/event.js');
const {
  RawContextKey
} = require('../../contextkey/common/contextkey.js');
const {
  IContextKeyService
} = require('../../contextkey/common/contextkey.service.js');
const {
  IInstantiationService
} = require('../../instantiation/common/instantiation.js');
const {
  ILayoutService
} = require('../../layout/browser/layoutService.service.js');
const {
  IOpenerService
} = require('../../opener/common/opener.service.js');
const {
  QuickAccessController
} = require('./quickAccess.js');
const {
  defaultInputBoxStyles,
  defaultToggleStyles,
  defaultCountBadgeStyles,
  defaultButtonStyles,
  defaultProgressBarStyles,
  defaultKeybindingLabelStyles,
  getListStyles
} = require('../../theme/browser/defaultStyles.js');
const {
  asCssVariable
} = require('../../theme/common/colorUtils.js');
const {
  activeContrastBorder
} = require('../../theme/common/colors/baseColors.js');
const {} = require('../../theme/common/colors/chartsColors.js');
const {
  widgetBorder,
  widgetShadow
} = require('../../theme/common/colors/editorColors.js');
const {} = require('../../theme/common/colors/inputColors.js');
const {} = require('../../theme/common/colors/listColors.js');
const {} = require('../../theme/common/colors/menuColors.js');
const {} = require('../../theme/common/colors/minimapColors.js');
const {} = require('../../theme/common/colors/miscColors.js');
const {
  quickInputBackground,
  quickInputForeground,
  quickInputTitleBackground,
  quickInputListFocusBackground,
  quickInputListFocusForeground,
  quickInputListFocusIconForeground,
  pickerGroupBorder,
  pickerGroupForeground
} = require('../../theme/common/colors/quickpickColors.js');
const {} = require('../../theme/common/colors/searchColors.js');
const {
  Themable
} = require('../../theme/common/themeService.js');
const {
  IThemeService
} = require('../../theme/common/themeService.service.js');
const {
  QuickInputHoverDelegate
} = require('./quickInput.js');
const {
  QuickInputController
} = require('./quickInputController.js');
const {
  IConfigurationService
} = require('../../configuration/common/configuration.service.js');
const {
  getWindow
} = require('../../../base/browser/dom.js');
let QuickInputService = class QuickInputService extends Themable {
  get backButton() {
    return this.controller.backButton;
  }
  get controller() {
    if (!this._controller) {
      this._controller = this._register(this.createController());
    }
    return this._controller;
  }
  get hasController() {
    return !!this._controller;
  }
  get quickAccess() {
    if (!this._quickAccess) {
      this._quickAccess = this._register(this.instantiationService.createInstance(QuickAccessController));
    }
    return this._quickAccess;
  }
  constructor(instantiationService, contextKeyService, themeService, layoutService, configurationService) {
    super(themeService);
    this.instantiationService = instantiationService;
    this.contextKeyService = contextKeyService;
    this.layoutService = layoutService;
    this.configurationService = configurationService;
    this._onShow = this._register(new Emitter());
    this.onShow = this._onShow.event;
    this._onHide = this._register(new Emitter());
    this.onHide = this._onHide.event;
    this.contexts = new Map();
  }
  createController(host = this.layoutService, options) {
    const defaultOptions = {
      idPrefix: 'quickInput_',
      container: host.activeContainer,
      ignoreFocusOut: () => false,
      backKeybindingLabel: () => undefined,
      setContextKey: id => this.setContextKey(id),
      linkOpenerDelegate: content => {
        this.instantiationService.invokeFunction(accessor => {
          const openerService = accessor.get(IOpenerService);
          openerService.open(content, {
            allowCommands: true,
            fromUserGesture: true
          });
        });
      },
      returnFocus: () => host.focus(),
      styles: this.computeStyles(),
      hoverDelegate: this._register(this.instantiationService.createInstance(QuickInputHoverDelegate))
    };
    const controller = this._register(this.instantiationService.createInstance(QuickInputController, {
      ...defaultOptions,
      ...options
    }));
    controller.layout(host.activeContainerDimension, host.activeContainerOffset.quickPickTop);
    this._register(host.onDidLayoutActiveContainer(dimension => {
      if (getWindow(host.activeContainer) === getWindow(controller.container)) {
        controller.layout(dimension, host.activeContainerOffset.quickPickTop);
      }
    }));
    this._register(host.onDidChangeActiveContainer(() => {
      if (controller.isVisible()) {
        return;
      }
      controller.layout(host.activeContainerDimension, host.activeContainerOffset.quickPickTop);
    }));
    this._register(controller.onShow(() => {
      this.resetContextKeys();
      this._onShow.fire();
    }));
    this._register(controller.onHide(() => {
      this.resetContextKeys();
      this._onHide.fire();
    }));
    return controller;
  }
  setContextKey(id) {
    let key;
    if (id) {
      key = this.contexts.get(id);
      if (!key) {
        key = new RawContextKey(id, false).bindTo(this.contextKeyService);
        this.contexts.set(id, key);
      }
    }
    if (key && key.get()) {
      return;
    }
    this.resetContextKeys();
    key?.set(true);
  }
  resetContextKeys() {
    this.contexts.forEach(context => {
      if (context.get()) {
        context.reset();
      }
    });
  }
  pick(picks, options = {}, token = CancellationToken.None) {
    return this.controller.pick(picks, options, token);
  }
  input(options = {}, token = CancellationToken.None) {
    return this.controller.input(options, token);
  }
  createQuickPick() {
    return this.controller.createQuickPick();
  }
  createInputBox() {
    return this.controller.createInputBox();
  }
  createQuickWidget() {
    return this.controller.createQuickWidget();
  }
  focus() {
    this.controller.focus();
  }
  toggle() {
    this.controller.toggle();
  }
  navigate(next, quickNavigate) {
    this.controller.navigate(next, quickNavigate);
  }
  accept(keyMods) {
    return this.controller.accept(keyMods);
  }
  back() {
    return this.controller.back();
  }
  cancel() {
    return this.controller.cancel();
  }
  updateStyles() {
    if (this.hasController) {
      this.controller.applyStyles(this.computeStyles());
    }
  }
  computeStyles() {
    return {
      widget: {
        quickInputBackground: asCssVariable(quickInputBackground),
        quickInputForeground: asCssVariable(quickInputForeground),
        quickInputTitleBackground: asCssVariable(quickInputTitleBackground),
        widgetBorder: asCssVariable(widgetBorder),
        widgetShadow: asCssVariable(widgetShadow)
      },
      inputBox: defaultInputBoxStyles,
      toggle: defaultToggleStyles,
      countBadge: defaultCountBadgeStyles,
      button: defaultButtonStyles,
      progressBar: defaultProgressBarStyles,
      keybindingLabel: defaultKeybindingLabelStyles,
      list: getListStyles({
        listBackground: quickInputBackground,
        listFocusBackground: quickInputListFocusBackground,
        listFocusForeground: quickInputListFocusForeground,
        listInactiveFocusForeground: quickInputListFocusForeground,
        listInactiveSelectionIconForeground: quickInputListFocusIconForeground,
        listInactiveFocusBackground: quickInputListFocusBackground,
        listFocusOutline: activeContrastBorder,
        listInactiveFocusOutline: activeContrastBorder
      }),
      pickerGroup: {
        pickerGroupBorder: asCssVariable(pickerGroupBorder),
        pickerGroupForeground: asCssVariable(pickerGroupForeground)
      }
    };
  }
};
QuickInputService = __decorate([__param(0, IInstantiationService), __param(1, IContextKeyService), __param(2, IThemeService), __param(3, ILayoutService), __param(4, IConfigurationService)], QuickInputService);
exports.QuickInputService = QuickInputService;