const {
  __decorate,
  __param
} = require('../../../../../../external/tslib/tslib.es6.js');
const {
  FindInput
} = require('../../../base/browser/ui/findinput/findInput.js');
const {
  ReplaceInput
} = require('../../../base/browser/ui/findinput/replaceInput.js');
const {
  HistoryInputBox
} = require('../../../base/browser/ui/inputbox/inputBox.js');
const {
  ContextKeyExpr,
  RawContextKey
} = require('../../contextkey/common/contextkey.js');
const {
  IContextKeyService
} = require('../../contextkey/common/contextkey.service.js');
const {
  KeybindingsRegistry
} = require('../../keybinding/common/keybindingsRegistry.js');
const {
  localizeWithPath
} = require('../../../nls.js');
const {
  toDisposable,
  DisposableStore
} = require('../../../base/common/lifecycle.js');
const {
  isActiveElement
} = require('../../../base/browser/dom.js');
const _moduleId = "vs/platform/history/browser/contextScopedHistoryWidget";
const historyNavigationVisible = new RawContextKey('suggestWidgetVisible', false, localizeWithPath(_moduleId, 0, "Whether suggestion are visible"));
const HistoryNavigationWidgetFocusContext = 'historyNavigationWidgetFocus';
const HistoryNavigationForwardsEnablementContext = 'historyNavigationForwardsEnabled';
const HistoryNavigationBackwardsEnablementContext = 'historyNavigationBackwardsEnabled';
let lastFocusedWidget = undefined;
const widgets = [];
function registerAndCreateHistoryNavigationContext(scopedContextKeyService, widget) {
  if (widgets.includes(widget)) {
    throw new Error('Cannot register the same widget multiple times');
  }
  widgets.push(widget);
  const disposableStore = new DisposableStore();
  const historyNavigationWidgetFocus = new RawContextKey(HistoryNavigationWidgetFocusContext, false).bindTo(scopedContextKeyService);
  const historyNavigationForwardsEnablement = new RawContextKey(HistoryNavigationForwardsEnablementContext, true).bindTo(scopedContextKeyService);
  const historyNavigationBackwardsEnablement = new RawContextKey(HistoryNavigationBackwardsEnablementContext, true).bindTo(scopedContextKeyService);
  const onDidFocus = () => {
    historyNavigationWidgetFocus.set(true);
    lastFocusedWidget = widget;
  };
  const onDidBlur = () => {
    historyNavigationWidgetFocus.set(false);
    if (lastFocusedWidget === widget) {
      lastFocusedWidget = undefined;
    }
  };
  if (isActiveElement(widget.element)) {
    onDidFocus();
  }
  disposableStore.add(widget.onDidFocus(() => onDidFocus()));
  disposableStore.add(widget.onDidBlur(() => onDidBlur()));
  disposableStore.add(toDisposable(() => {
    widgets.splice(widgets.indexOf(widget), 1);
    onDidBlur();
  }));
  return {
    historyNavigationForwardsEnablement,
    historyNavigationBackwardsEnablement,
    dispose() {
      disposableStore.dispose();
    }
  };
}
let ContextScopedHistoryInputBox = class ContextScopedHistoryInputBox extends HistoryInputBox {
  constructor(container, contextViewProvider, options, contextKeyService) {
    super(container, contextViewProvider, options);
    const scopedContextKeyService = this._register(contextKeyService.createScoped(this.element));
    this._register(registerAndCreateHistoryNavigationContext(scopedContextKeyService, this));
  }
};
ContextScopedHistoryInputBox = __decorate([__param(3, IContextKeyService)], ContextScopedHistoryInputBox);
let ContextScopedFindInput = class ContextScopedFindInput extends FindInput {
  constructor(container, contextViewProvider, options, contextKeyService) {
    super(container, contextViewProvider, options);
    const scopedContextKeyService = this._register(contextKeyService.createScoped(this.inputBox.element));
    this._register(registerAndCreateHistoryNavigationContext(scopedContextKeyService, this.inputBox));
  }
};
ContextScopedFindInput = __decorate([__param(3, IContextKeyService)], ContextScopedFindInput);
let ContextScopedReplaceInput = class ContextScopedReplaceInput extends ReplaceInput {
  constructor(container, contextViewProvider, options, contextKeyService, showReplaceOptions = false) {
    super(container, contextViewProvider, showReplaceOptions, options);
    const scopedContextKeyService = this._register(contextKeyService.createScoped(this.inputBox.element));
    this._register(registerAndCreateHistoryNavigationContext(scopedContextKeyService, this.inputBox));
  }
};
ContextScopedReplaceInput = __decorate([__param(3, IContextKeyService)], ContextScopedReplaceInput);
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: 'history.showPrevious',
  weight: 200,
  when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetFocusContext), ContextKeyExpr.equals(HistoryNavigationBackwardsEnablementContext, true), ContextKeyExpr.not('isComposing'), historyNavigationVisible.isEqualTo(false)),
  primary: 16,
  secondary: [512 | 16],
  handler: accessor => {
    lastFocusedWidget?.showPreviousValue();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: 'history.showNext',
  weight: 200,
  when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetFocusContext), ContextKeyExpr.equals(HistoryNavigationForwardsEnablementContext, true), ContextKeyExpr.not('isComposing'), historyNavigationVisible.isEqualTo(false)),
  primary: 18,
  secondary: [512 | 18],
  handler: accessor => {
    lastFocusedWidget?.showNextValue();
  }
});
exports.ContextScopedFindInput = ContextScopedFindInput;
exports.ContextScopedHistoryInputBox = ContextScopedHistoryInputBox;
exports.ContextScopedReplaceInput = ContextScopedReplaceInput;
exports.historyNavigationVisible = historyNavigationVisible;
exports.registerAndCreateHistoryNavigationContext = registerAndCreateHistoryNavigationContext;