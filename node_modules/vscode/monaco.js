const {
  __decorate,
  __param
} = require('./external/tslib/tslib.es6.js');
const {
  StandaloneServices,
  StandaloneKeybindingService
} = require('./vscode/src/vs/editor/standalone/browser/standaloneServices.js');
const {
  ITextResourceConfigurationService
} = require('./vscode/src/vs/editor/common/services/textResourceConfiguration.js');
const {
  IInstantiationService
} = require('./vscode/src/vs/platform/instantiation/common/instantiation.js');
const {
  StandaloneCodeEditor,
  StandaloneEditor,
  StandaloneDiffEditor2
} = require('./vscode/src/vs/editor/standalone/browser/standaloneCodeEditor.js');
const {
  isObject
} = require('./vscode/src/vs/base/common/types.js');
const {
  distinct,
  deepClone
} = require('./vscode/src/vs/base/common/objects.js');
exports.errorHandler = errorHandler;
exports.FoldingModel = FoldingModel;
exports.setCollapseStateForMatchingLines = setCollapseStateForMatchingLines;
exports.FoldingController = FoldingController;
exports.DisposableStore = DisposableStore;
exports.Registry = Registry;
const {
  Extensions$1
} = require('./vscode/src/vs/platform/jsonschemas/common/jsonContributionRegistry.js');
exports.CommandsRegistry = CommandsRegistry;
exports.MenuId = MenuId;
exports.MenuRegistry = MenuRegistry;
exports.KeybindingsRegistry = KeybindingsRegistry;
const {
  Extensions$2
} = require('./vscode/src/vs/platform/configuration/common/configurationRegistry.js');
const {
  EditorOptionsUtil
} = require('./vscode/src/vs/editor/browser/config/editorConfiguration.js');
exports.registerColor = registerColor;
const {} = require('./vscode/src/vs/platform/theme/common/colors/baseColors.js');
const {} = require('./vscode/src/vs/platform/theme/common/colors/chartsColors.js');
const {} = require('./vscode/src/vs/platform/theme/common/colors/editorColors.js');
const {} = require('./vscode/src/vs/platform/theme/common/colors/inputColors.js');
const {} = require('./vscode/src/vs/platform/theme/common/colors/listColors.js');
const {} = require('./vscode/src/vs/platform/theme/common/colors/menuColors.js');
const {} = require('./vscode/src/vs/platform/theme/common/colors/minimapColors.js');
const {} = require('./vscode/src/vs/platform/theme/common/colors/miscColors.js');
const {} = require('./vscode/src/vs/platform/theme/common/colors/quickpickColors.js');
const {} = require('./vscode/src/vs/platform/theme/common/colors/searchColors.js');
const {
  ITextModelService
} = require('./vscode/src/vs/editor/common/services/resolverService.js');
const {
  VSBuffer
} = require('./vscode/src/vs/base/common/buffer.js');
const {
  ServiceCollection
} = require('./vscode/src/vs/platform/instantiation/common/serviceCollection.js');
const {
  StandaloneQuickInputService
} = require('./vscode/src/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js');
const {
  SyncDescriptor
} = require('./vscode/src/vs/platform/instantiation/common/descriptors.js');
exports.ContextKeyExpr = ContextKeyExpr;
exports.RawContextKey = RawContextKey;
const {
  ICodeEditorService
} = require('./vscode/src/vs/editor/browser/services/codeEditorService.js');
const {
  IFileService
} = require('./vscode/src/vs/platform/files/common/files.service.js');
const {
  ResourceContextKey
} = require('./vscode/src/vs/workbench/common/contextkeys.js');
const {
  IContextKeyService
} = require('./vscode/src/vs/platform/contextkey/common/contextkey.service.js');
const {
  IKeybindingService
} = require('./vscode/src/vs/platform/keybinding/common/keybinding.service.js');
const {
  ICommandService
} = require('./vscode/src/vs/platform/commands/common/commands.service.js');
const {
  ITelemetryService
} = require('./vscode/src/vs/platform/telemetry/common/telemetry.service.js');
const {
  INotificationService
} = require('./vscode/src/vs/platform/notification/common/notification.service.js');
const {
  ILogService
} = require('./vscode/src/vs/platform/log/common/log.service.js');
const {
  IQuickInputService
} = require('./vscode/src/vs/platform/quickinput/common/quickInput.service.js');
const {
  createInjectedClass
} = require('./tools/injection.js');
const {
  getService
} = require('./services.js');
exports.EditorAction = EditorAction;
exports.EditorCommand = EditorCommand;
exports.registerDiffEditorContribution = registerDiffEditorContribution;
exports.registerEditorAction = registerEditorAction;
exports.registerEditorContribution = registerEditorContribution;
exports.registerMultiEditorAction = registerMultiEditorAction;
function computeConfiguration(configuration, overrides) {
  const editorConfiguration = isObject(configuration.editor) ? deepClone(configuration.editor) : Object.create(null);
  Object.assign(editorConfiguration, deepClone(overrides));
  return editorConfiguration;
}
function computeDiffConfiguration(configuration, overrides) {
  const editorConfiguration = computeConfiguration(configuration);
  if (isObject(configuration.diffEditor)) {
    const diffEditorConfiguration = deepClone(configuration.diffEditor);
    diffEditorConfiguration.diffCodeLens = diffEditorConfiguration.codeLens;
    delete diffEditorConfiguration.codeLens;
    diffEditorConfiguration.diffWordWrap = diffEditorConfiguration.wordWrap;
    delete diffEditorConfiguration.wordWrap;
    Object.assign(editorConfiguration, diffEditorConfiguration);
  }
  editorConfiguration.accessibilityVerbose = configuration.accessibility?.verbosity?.diffEditor ?? false;
  Object.assign(editorConfiguration, deepClone(overrides));
  return editorConfiguration;
}
function createConfiguredEditorClass(impl) {
  let ConfiguredStandaloneEditor = class ConfiguredStandaloneEditor extends impl {
    constructor(domElement, _options = {}, instantiationService, textResourceConfigurationService) {
      const {
        theme,
        autoDetectHighContrast,
        model,
        value,
        language,
        accessibilityHelpUrl,
        ariaContainerElement,
        overflowWidgetsDomNode,
        dimension,
        ...options
      } = _options;
      const computedOptions = computeConfiguration(textResourceConfigurationService.getValue(_options.model?.uri), options);
      super(instantiationService, domElement, {
        ...computedOptions,
        overflowWidgetsDomNode,
        dimension,
        theme,
        autoDetectHighContrast,
        model,
        value,
        language,
        accessibilityHelpUrl,
        ariaContainerElement
      });
      this.textResourceConfigurationService = textResourceConfigurationService;
      this.optionsOverrides = {};
      this.lastAppliedEditorOptions = computedOptions;
      this.optionsOverrides = options;
      this._register(textResourceConfigurationService.onDidChangeConfiguration(e => {
        const resource = this.getModel()?.uri;
        if (resource != null && e.affectsConfiguration(resource, 'editor')) {
          this.updateEditorConfiguration();
        }
      }));
      this._register(this.onDidChangeModelLanguage(() => this.updateEditorConfiguration()));
      this._register(this.onDidChangeModel(() => this.updateEditorConfiguration()));
      this.updateEditorConfiguration();
      const scopedInstantiationService = instantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService]));
      const resourceContext = this._register(scopedInstantiationService.createInstance(ResourceContextKey));
      this.onDidChangeModel(e => {
        resourceContext.set(e.newModelUrl);
      });
      resourceContext.set(this.getModel()?.uri);
    }
    updateEditorConfiguration() {
      if (!this.hasModel() || this.textResourceConfigurationService == null) {
        return;
      }
      const resource = this.getModel().uri;
      const configuration = this.textResourceConfigurationService.getValue(resource);
      if (configuration == null) {
        return;
      }
      const editorConfiguration = computeConfiguration(configuration, this.optionsOverrides);
      let editorSettingsToApply = editorConfiguration;
      if (this.lastAppliedEditorOptions != null) {
        editorSettingsToApply = distinct(this.lastAppliedEditorOptions, editorSettingsToApply);
      }
      if (Object.keys(editorSettingsToApply).length > 0) {
        this.lastAppliedEditorOptions = editorConfiguration;
        super.updateOptions(editorSettingsToApply);
      }
    }
    updateOptions(newOptions) {
      this.optionsOverrides ?? (this.optionsOverrides = {});
      const didChange = EditorOptionsUtil.applyUpdate(this.optionsOverrides, newOptions);
      if (!didChange) {
        return;
      }
      this.updateEditorConfiguration();
    }
  };
  ConfiguredStandaloneEditor = __decorate([__param(2, IInstantiationService), __param(3, ITextResourceConfigurationService)], ConfiguredStandaloneEditor);
  return ConfiguredStandaloneEditor;
}
const ConfiguredStandaloneCodeEditor = createConfiguredEditorClass(createInjectedClass(StandaloneCodeEditor));
const ConfiguredStandaloneEditor = createConfiguredEditorClass(createInjectedClass(StandaloneEditor));
let ConfiguredStandaloneDiffEditor = class ConfiguredStandaloneDiffEditor extends createInjectedClass(StandaloneDiffEditor2) {
  constructor(domElement, _options = {}, instantiationService, textResourceConfigurationService) {
    const {
      theme,
      autoDetectHighContrast,
      modifiedAriaLabel,
      originalAriaLabel,
      overflowWidgetsDomNode,
      dimension,
      ...options
    } = _options;
    const computedOptions = computeDiffConfiguration(textResourceConfigurationService.getValue(undefined), options);
    super(instantiationService, domElement, {
      ...computedOptions,
      overflowWidgetsDomNode,
      dimension,
      theme,
      autoDetectHighContrast,
      modifiedAriaLabel,
      originalAriaLabel
    });
    this.textResourceConfigurationService = textResourceConfigurationService;
    this.optionsOverrides = {};
    this.lastAppliedEditorOptions = computedOptions;
    this.optionsOverrides = options;
    this._register(textResourceConfigurationService.onDidChangeConfiguration(e => {
      const resource = this._targetEditor.getModel()?.uri;
      if (resource != null && (e.affectsConfiguration(resource, 'editor') || e.affectsConfiguration(resource, 'diffEditor') || e.affectsConfiguration(resource, 'accessibility.verbosity.diffEditor'))) {
        this.updateEditorConfiguration();
      }
    }));
    this._register(this._targetEditor.onDidChangeModelLanguage(() => this.updateEditorConfiguration()));
    this._register(this.onDidChangeModel(() => this.updateEditorConfiguration()));
    this.updateEditorConfiguration();
  }
  updateEditorConfiguration() {
    if (this.getModel() == null || this.textResourceConfigurationService == null) {
      return;
    }
    const resource = this._targetEditor.getModel()?.uri;
    const configuration = this.textResourceConfigurationService.getValue(resource);
    if (configuration == null) {
      return;
    }
    const editorConfiguration = computeDiffConfiguration(configuration, this.optionsOverrides);
    let editorSettingsToApply = editorConfiguration;
    if (this.lastAppliedEditorOptions != null) {
      editorSettingsToApply = distinct(this.lastAppliedEditorOptions, editorSettingsToApply);
    }
    if (Object.keys(editorSettingsToApply).length > 0) {
      this.lastAppliedEditorOptions = editorConfiguration;
      super.updateOptions(editorSettingsToApply);
    }
  }
  updateOptions(newOptions) {
    this.optionsOverrides ?? (this.optionsOverrides = {});
    this.optionsOverrides = {
      ...this.optionsOverrides,
      ...newOptions
    };
    this.updateEditorConfiguration();
  }
  _createInnerEditor(instantiationService, container, options) {
    return instantiationService.createInstance(ConfiguredStandaloneCodeEditor, container, options);
  }
};
ConfiguredStandaloneDiffEditor = __decorate([__param(2, IInstantiationService), __param(3, ITextResourceConfigurationService)], ConfiguredStandaloneDiffEditor);
async function writeFile(uri, content) {
  const fileService = await getService(IFileService);
  await fileService.writeFile(uri, VSBuffer.fromString(content));
}
async function deleteFile(uri, options) {
  const fileService = await getService(IFileService);
  await fileService.del(uri, options);
}
async function createModelReference(resource, content) {
  if (content != null) {
    await writeFile(resource, content);
  }
  const textModelService = await getService(ITextModelService);
  return await textModelService.createModelReference(resource);
}
function isDynamicKeybindingService(keybindingService) {
  return keybindingService.registerKeybindingProvider != null;
}
let DelegateStandaloneKeybindingService = class DelegateStandaloneKeybindingService extends StandaloneKeybindingService {
  constructor(delegate, contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService) {
    super(contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService);
    this.delegate = delegate;
    this._register(delegate.registerKeybindingProvider({
      provideKeybindings: () => {
        return this.getUserKeybindingItems();
      },
      onDidChangeKeybindings: this.onDidUpdateKeybindings
    }));
  }
  _getResolver() {
    return this.delegate._getResolver();
  }
  resolveKeyboardEvent(keyboardEvent) {
    return this.delegate.resolveKeyboardEvent(keyboardEvent);
  }
  resolveKeybinding(keybinding) {
    return this.delegate.resolveKeybinding(keybinding);
  }
  resolveUserBinding(userBinding) {
    return this.delegate.resolveUserBinding(userBinding);
  }
  _dumpDebugInfo() {
    return this.delegate._dumpDebugInfo();
  }
  _dumpDebugInfoJSON() {
    return this.delegate._dumpDebugInfoJSON();
  }
  registerSchemaContribution(contribution) {
    return this.delegate.registerSchemaContribution(contribution);
  }
  enableKeybindingHoldMode(commandId) {
    return this.delegate.enableKeybindingHoldMode(commandId);
  }
};
DelegateStandaloneKeybindingService = __decorate([__param(1, IContextKeyService), __param(2, ICommandService), __param(3, ITelemetryService), __param(4, INotificationService), __param(5, ILogService), __param(6, ICodeEditorService)], DelegateStandaloneKeybindingService);
let standaloneEditorInstantiationService = null;
function getStandaloneEditorInstantiationService(accessor) {
  if (standaloneEditorInstantiationService == null) {
    const serviceCollection = new ServiceCollection();
    serviceCollection.set(IQuickInputService, new SyncDescriptor(StandaloneQuickInputService, undefined, true));
    const keybindingService = accessor.get(IKeybindingService);
    if (!(keybindingService instanceof StandaloneKeybindingService) && isDynamicKeybindingService(keybindingService)) {
      serviceCollection.set(IKeybindingService, new SyncDescriptor(DelegateStandaloneKeybindingService, [keybindingService], true));
    }
    standaloneEditorInstantiationService = accessor.get(IInstantiationService).createChild(serviceCollection);
  }
  return standaloneEditorInstantiationService;
}
const createConfiguredEditor = (domElement, options, override) => {
  const instantiationService = StandaloneServices.initialize(override ?? {});
  return instantiationService.invokeFunction(getStandaloneEditorInstantiationService).createInstance(ConfiguredStandaloneEditor, domElement, options);
};
const createConfiguredDiffEditor = (domElement, options, override) => {
  const instantiationService = StandaloneServices.initialize(override ?? {});
  return instantiationService.invokeFunction(getStandaloneEditorInstantiationService).createInstance(ConfiguredStandaloneDiffEditor, domElement, options);
};
const Extensions = {
  ...Extensions$1,
  ...Extensions$2
};
exports.Extensions = Extensions;
exports.createConfiguredDiffEditor = createConfiguredDiffEditor;
exports.createConfiguredEditor = createConfiguredEditor;
exports.createModelReference = createModelReference;
exports.deleteFile = deleteFile;
exports.writeFile = writeFile;